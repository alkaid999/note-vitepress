# 格式化与挂载

在 Linux 中，给硬盘分区只是使用硬盘的第一步，分区后必须通过格式化（创建文件系统） 和挂载（让系统识别分区），才能真正用于存储数据。

## 格式化

在 Linux 中，格式化是管理本地存储的核心操作，但它并非删除数据这么简单，其本质是为本地硬盘分区（或本地存储设备）创建文件系统结构的过程，将原始块设备（如 `/dev/nvme0n4`）转化为可被 VFS（虚拟文件系统层）识别的存储实体。

通过 `mkfs` 格式化工具，为本地硬盘分区或本地存储设备，写入 ext4、XFS、Btrfs 等本地文件系统的数据管理结构，让 Linux 能通过这些结构实现文件存储、读取、权限控制的操作。

> [!NOTE] 只有本地分区需要格式化
> 网络文件系统（Ceph FS、HDFS、GlusterFS 等）的核心是分布式集群架构，它们不依赖单个本地分区，而是整合多台服务器的存储资源形成「虚拟存储池」。这类文件系统的启用不是格式化某个分区，而是「搭建集群 + 创建存储卷」。
>
> 特殊虚拟文件系统则是内核自动创建，无实体分区，由内核动态生成或依赖已有文件系统。

### mkfs

`mkfs`（make filesystem）工具集是 Linux 中管理本地存储文件系统的核心工具，其设计采用主命令 + 子命令的架构：主命令 `mkfs` 作为统一入口，根据文件系统类型调用对应的子命令（如 `mkfs.ext4`、`mkfs.xfs`），最终完成格式化为指定文件系统的操作。

`mkfs` 主命令本身不直接执行格式化，而是作为调度器，根据参数调用对应的子命令。其核心价值在于提供统一的语法接口，让用户无需记忆不同子命令的启动方式。

```shell
mkfs [options] [-t <type>] [fs-options] <device> [<size>]
```

| 参数部分     | 描述                                                               | 关键说明                                                              |
| ------------ | ------------------------------------------------------------------ | --------------------------------------------------------------------- |
| `options`    | 主命令自身的选项（控制 mkfs 行为）                                 | 如 `-V`（显示过程）、`-h`（帮助），不涉及文件系统具体特性配置。       |
| `-t <type>`  | 指定目标文件系统类型（如 ext4、xfs），决定调用哪个子命令           | 默认值为 ext2（较老旧，现代系统建议显式指定 `-t ext4` 或 `-t xfs`）。 |
| `fs-options` | 传递给子命令的选项（定制文件系统特性，如块大小、卷标等）           | 这些选项会被直接转发给子命令（如 `mkfs.ext4` 的 `-L`、`-b` 等）。     |
| `device`     | 目标本地存储路径（如 `/dev/sda1` 分区、`/dev/nvme0n4` 磁盘）       | 必须是未挂载的本地存储（网络存储或虚拟文件系统不可用）。              |
| `size`       | 可选，指定使用的块数量（默认由工具自动识别设备大小，极少手动指定） | 仅在特殊场景（如限制使用部分磁盘空间）下使用。                        |

`mkfs` 主命令的核心逻辑是根据` -t <type>` 调用对应子命令，例如：

```shell
# 以下两条命令完全等价
mkfs -t ext4 -L "data" /dev/nvme0n4p1  # 主命令调用方式
mkfs.ext4 -L "data" /dev/nvme0n4p1     # 直接调用子命令方式
```

- 手动操作推荐直接用子命令（如 `mkfs.ext4`），更简洁直观
- 脚本自动化推荐用主命令（如 `mkfs -t $TYPE ...`），可通过变量动态切换文件系统类型

### mkfs.ext4

`mkfs.ext4` 用于创建 ext4 文件系统，是 ext 系列的最新版本（前身为 ext2、ext3），凭借极佳的兼容性（所有 Linux 发行版默认支持）和平衡的性能，成为系统盘、日常数据盘的首选。

#### 核心结构创建逻辑

`mkfs.ext4` 的本质是在磁盘分区上按固定规则创建 ext4 的五大核心结构，这些结构共同构成文件管理框架。执行命令时，会按以下逻辑生成结构：

| 核心结构              | 存储内容                                                                                         | 作用（类比仓库）                  | mkfs.ext4 如何创建与配置                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| 超级块（Super Block） | 文件系统总大小、块大小（`-b` 指定）、inode 总数（`-i`/`-N` 控制）、卷标（`-L` 设置）、创建时间等 | 仓库说明书，记录全局配置          | 命令执行时首先在分区开头写入主超级块，并在其他块组备份（防止损坏），配置参数来自命令选项（如 `-b 4096` 会写入块大小）。  |
| 块组描述符表          | 每个块组的位置、空闲空间 /inode 数量、数据块区起始地址等                                         | 仓库分区索引，定位各区域资源      | 按分区大小拆分块组（默认每个 128MB），为每个块组创建描述符，集中存放在超级块后，记录块组资源分布。                       |
| inode 表              | 每个文件的元信息（大小、权限、修改时间、数据块位置），inode 数量由 `-i`/`-N` 决定                | 文件标签库，通过 inode 找文件内容 | 在每个块组内划分连续空间，初始化所有 inode（默认 256 字节 / 个），`-E lazy_itable_init=1` 选项会延迟初始化以加速格式化。 |
| 数据块区              | 实际存储文件内容，目录的「文件名→inode 映射」也存在这里，块大小由 `-b` 指定                      | 仓库货架，放实际货物              | 块组中最大的区域，按 `-b` 指定的大小划分块（如 4KB），标记为空闲，后续文件写入时分配。                                   |
| 日志区（Journal）     | 记录磁盘操作（如修改了 inode 123），大小可通过 `-J size` 设置                                    | 仓库操作日志本，保障数据安全      | 默认在分区内创建（大小为分区的 1%），也可通过 `-J device` 指定独立分区，`-O ^has_journal` 选项可禁用日志。               |

#### 语法选项

```shell
mkfs.ext4 [options] device [blocks-count]
```

| 选项                                                       | 描述                                                                                                          | 适用场景与配置建议                                                                                                                                                |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-b 块大小`                                                | 指定数据块尺寸（单位：字节，支持 `1k`/`4k`，默认 `4096`）                                                     | **工作负载优化**<br>• 小文件（日志/配置）：`-b 1024` 减少空间浪费<br>• 大文件（视频/备份）：`-b 4096` 或 `-b 8192` 提升吞吐量<br>• 通用场景：默认 `4096` 最佳平衡 |
| `-c`                                                       | 格式化前检测坏块（读写验证）                                                                                  | **磁盘健康检查**<br>• 新盘首用：全面检测物理坏块<br>• 旧盘复用：排查损坏区域<br>• 时间成本：检测时间与磁盘容量成正比                                              |
| `-l 文件名`                                                | 从文件读取坏块列表（跳过检测）                                                                                | **快速复用**<br>• 已知坏块：复用历史检测结果（`badblocks -o badblocks.txt`生成）<br>• 批量部署：避免重复检测节省时间                                              |
| `-C 簇大小`                                                | 为嵌入式设备指定簇大小（兼容 FAT）                                                                            | **嵌入式场景**<br>• SD 卡/U 盘：`-C 4096` 匹配闪存页大小<br>• 旧设备兼容：`-C 512` 兼容老式控制器                                                                 |
| `-i 字节/inode`                                            | 控制 inode 密度（默认 `16384`）                                                                               | **inode 优化**<br>• 海量小文件：`-i 4096`（百万级文件）<br>• 大文件为主：`-i 32768` 减少元数据开销<br>• 计算公式：`inode 数 ≈ 分区大小 / -i 值`                   |
| `-I inode 大小`                                            | 指定单个 inode 尺寸（默认 `256`）                                                                             | **扩展属性支持**<br>• 复杂 ACL 权限：`-I 512` 容纳更多属性<br>• SELinux 环境：需 `-I 512` 存储安全上下文                                                          |
| `-J 日志选项`<br>`size=大小`<br>`device=设备`              | 配置日志区：<br>• 日志大小（默认分区 1%）<br>• 独立日志设备                                                   | **日志策略**<br>• 高频写入：`-J size=128M` 提升崩溃恢复速度<br>• 关键业务：`-J device=/dev/nvme1n2` 外置日志盘<br>• 临时数据：`-O ^has_journal` 完全禁用日志      |
| `-G 弹性组大小`                                            | 设置弹性块组包含的块组数（默认 `16`）                                                                         | **超大分区优化**<br>• 1TB+分区：`-G 32` 提升大文件并发性能<br>• 默认值：每个弹性组含 `16` 个块组（约 `2GB`）                                                      |
| `-N inode 总数`                                            | 直接指定 inode 数量                                                                                           | **精确控制**<br>• 固定文件数：`-N 1000000`（百万文件）<br>• 容器镜像：避免 inode 浪费<br>• 覆盖 `-i` 参数                                                         |
| `-d 源路径`                                                | 预写入目录或压缩包内容                                                                                        | **系统预制**<br>• 嵌入式设备：`-d /path/to/rootfs` 植入固件<br>• 环境标准化：`-d config.tar.gz` 预置配置                                                          |
| `-m 预留比例`                                              | root 用户保留空间（默认 `5%`）                                                                                | **空间策略**<br>• 系统分区：`-m 5` 保障紧急恢复<br>• 数据盘：`-m 0` 最大化可用空间<br>• 1TB 硬盘：默认预留 50GB，可设 `-m 1` 保留 10GB                            |
| `-o 创建者 OS`                                             | 标记文件系统创建者（如 `-o linux`）                                                                           | **兼容性标识**<br>• 跨平台共享：`-o windows` 兼容 NTFS 工具<br>• 特殊场景：极少需要手动指定                                                                       |
| `-g 块/组`                                                 | 设置每个块组的块数量（默认 `32768`）                                                                          | **元数据优化**<br>• 默认块组大小：`128MB`（32768×4K）<br>• 超大分区：`-g 131072` 创建 `512MB` 块组减少元数据量                                                    |
| `-L 卷标`                                                  | 设置卷标（最大 `16` 字符）                                                                                    | **设备标识**<br>• 多磁盘：`-L "WEB_DATA"` 直观区分<br>• 稳定挂载：通过 `/dev/disk/by-label/` 引用                                                                 |
| `-M 最后挂载点`                                            | 记录最后挂载目录（调试用）                                                                                    | **故障排查**<br>• 异常卸载：追踪最后访问路径<br>• 默认不设置，需调试时启用                                                                                        |
| `-O 特性开关`<br>`^`前缀表示禁用                           | 启用/禁用 ext4 特性：<br>• `dir_index`：目录哈希索引<br>• `extents`：大文件支持<br>• `^has_journal`：禁用日志 | **性能调优**<br>• 大目录优化：`-O dir_index` 加速 `ls`/`find`<br>• 临时数据盘：`-O ^has_journal` 提升写入速度<br>• 默认开启：`extents,has_journal` 核心特性       |
| `-r 文件系统版本`                                          | 指定文件系统版本（兼容性）                                                                                    | **旧系统兼容**<br>• 兼容内核 2.4：`-r 0` 使用旧格式<br>• 现代系统：无需指定（默认最优）                                                                           |
| `-E 扩展选项`<br>`lazy_itable_init=1`<br>`stripe_width=值` | 高级参数：<br>• 延迟初始化：加速格式化<br>• RAID 条带对齐                                                     | **大规模部署**<br>• 1TB+分区：`-E lazy_itable_init=1` 格式化时间从 10 分钟 → 10 秒<br>• RAID10 环境：`-E stripe_width=128` 匹配条带大小                           |
| `-t 文件系统类型`                                          | 兼容性参数（实际被忽略）                                                                                      | **历史遗留**<br>• 保持 `ext4` 无需修改                                                                                                                            |
| `-T 使用类型`                                              | 预设优化配置（如 `news`/`largefile`）                                                                         | **快速配置**<br>• 新闻服务器：`-T news` 优化小文件<br>• 媒体存储：`-T largefile` 大文件优化<br>• 查看预设：`tune2fs -l` 显示 `Filesystem flags`                   |
| `-U UUID`                                                  | 手动指定 UUID                                                                                                 | **集群管理**<br>• 统一配置：`-U $(uuidgen)` 生成唯一 ID<br>• 系统迁移：保持 UUID 避免挂载失效                                                                     |
| `-e 错误处理`<br>`continue`<br>`remount-ro`<br>`panic`     | 错误响应策略：<br>• 忽略继续<br>• 只读挂载<br>• 系统崩溃                                                      | **容错分级**<br>• 生产环境：`-e remount-ro` 防止错误扩散<br>• 开发测试：`-e continue` 保持服务<br>• 关键系统：`-e panic` 强制停机保护数据                         |
| `-z 撤销文件`                                              | 创建撤销文件（实验性功能）                                                                                    | **数据安全**<br>• 误格式化恢复：通过 `e2undo` 回退操作<br>• 启用：`-z undo_file.bin`                                                                              |
| `-j`                                                       | 启用日志（等价于 `-O has_journal`）                                                                           | **兼容写法**<br>• 替代 `-O has_journal` 的简写形式                                                                                                                |
| `-q`                                                       | 安静模式（仅输出错误）                                                                                        | **脚本集成**<br>• 自动化部署：避免日志干扰<br>• 后台任务：减少输出占用资源                                                                                        |
| `-v`                                                       | 详细模式（显示更多信息）                                                                                      | **调试排错**<br>• 查看格式化细节：块组分配过程<br>• 结合 `-N` 模拟运行验证参数                                                                                    |
| `-S`                                                       | 仅写入超级块和组描述符（元数据恢复）                                                                          | **灾难恢复**<br>• 修复损坏文件系统：`-S` + `e2fsck -f`<br>• **⚠️ 危险**：可能造成数据丢失                                                                          |

> [!TIP]
> 对于绝大多数日常使用场景（如格式化普通数据盘或系统盘），非专业用户无需纠结复杂选项，直接使用 `mkfs.ext4` 默认选项即可。ext4 的默认配置（4K 块大小、5%预留空间、启用日志等）已经开发者精心优化，在兼容性、性能与安全性之间取得了最佳平衡，除非明确知道需要调优（如百万级小文件/数据库专用盘），否则默认配置即是 90% 场景的最佳选择。

#### 创建 ext4 文件系统

首先确认目标分区​，通过 `lsblk` 命令查看分区信息，`FSTYPE` 表示文件系统类型：

```bash
lsblk -o NAME,FSTYPE
```

```console
NAME        FSTYPE
sr0         iso9660
nvme0n1     
├─nvme0n1p1 
├─nvme0n1p2 xfs
└─nvme0n1p3 LVM2_member
├─rl-root xfs
└─rl-swap swap
nvme0n2     
├─nvme0n2p1 
└─nvme0n2p2 
nvme0n3     
├─nvme0n3p1 
└─nvme0n3p2 
nvme0n4     
├─nvme0n4p1 
└─nvme0n4p2 
```

`FSTYPE` 列为空的分区都是未格式化，可以进行格式化操作。

> [!WARNING]
> 虽然 `nvme0n1p1` 的 `FSTYPE` 也显示为空（和 `nvme0n2p1` 等空闲分区一样），但它本质是 UEFI 启动架构下的 ESP 分区（EFI 系统分区），是系统能正常开机的核心引导分区，绝对不能像空闲分区那样格式化或删除。

这里选择 `nvme0n2` 硬盘的两个分区进行格式化（普通数据盘，用默认选项即可）：

```bash
mkfs.ext4 /dev/nvme0n2p1
```

```console
mke2fs 1.47.1 (20-May-2024)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: e7632ba2-a3b6-460d-b932-8b5620639cc1
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
```

执行 `mkfs.ext4 /dev/nvme0n2p1` 后的输出，本质是 ext4 文件系统创建过程的实时日志，每一行都对应 ext4 核心结构（超级块、inode 表、日志区等）的创建步骤：

| 行号 | 控制台输出内容                                                      | 说明                                                                                                                                                                                                                                    | 关联结构              | 核心含义 / 用途                                                                                                                                    |
| ---- | ------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | `mke2fs 1.47.1 (20-May-2024)`                                       | `mkfs.ext4` 是 `mke2fs` 的软链接，此行为工具版本和编译日期                                                                                                                                                                              | -                     | 用于排查格式化兼容性问题（如旧系统无法识别新格式）                                                                                                 |
| 2    | `Creating filesystem with 262144 4k blocks and 65536 inodes`        | 按默认配置创建 ext4 结构：总共有 `262144` 个 4KB 数据块（262144 × 4KB = 1024MB = 1GB，说明 `nvme0n2p1` 分区大小是 1GB）；创建 `65536` 个 inode（ext4 默认按每 16KB 空间分配 1 个 inode 计算，1GB ÷ 16KB = 65536），足够存储数万级文件。 | 数据块区、inode 表    | 初始化文件系统的基础存储单元（块用于存内容，inode 用于存文件元信息）                                                                               |
| 3    | `Filesystem UUID: e7632ba2-a3b6-460d-b932-8b5620639cc1`             | UUID 是文件系统的唯一标识，不受设备路径变化影响                                                                                                                                                                                         | -                     | 用于永久挂载（`/etc/fstab`），比设备路径（如 `/dev/nvme0n2p1`）更可靠                                                                              |
| 4    | `Superblock backups stored on blocks: 32768, 98304, 163840, 229376` | 超级块（记录全局配置）的备份位置，一旦主超级块损坏，文件系统可能无法识别                                                                                                                                                                | 超级块（Super Block） | 工具会自动在 `32768`、`98304` 等数据块位置，创建超级块备份，后续若主超级块损坏时，可通过 `e2fsck -b 32768 /dev/nvme0n2p1` 用备份恢复，避免数据丢失 |
| 5    | `Allocating group tables: done`                                     | ext4 会把分区按「块组」拆分（1GB 分区默认拆成 8 个 128MB 块组），这行表示块组的管理表已创建完成，这个表会记录每个块组的空闲空间、空闲 inode 数量、数据块区位置等，后续文件写入时，系统靠它快速定位可用资源                              | 块组描述符表          | 记录每个块组的空闲资源（空间、inode），供系统快速定位可用存储                                                                                      |
| 6    | `Writing inode tables: done`                                        | 工具已完成 `65536` 个 inode 的初始化，每个 inode 会预留空间，用于后续存储文件的元信息（如文件大小、权限、修改时间、数据块位置）。这一步完成后，分区才能开始创建文件                                                                     | inode 表              | 为后续文件创建准备元信息存储（记录文件大小、权限、数据块位置等）                                                                                   |
| 7    | `Creating journal (8192 blocks): done`                              | 这里创建的日志区占用 `8192` 个 4KB 块，总大小 = 8192 × 4KB = 32MB（ext4 默认日志区大小，按分区比例自动分配）                                                                                                                            | 日志区（Journal）     | 记录磁盘操作日志，防止断电导致数据混乱，保障文件系统崩溃后可恢复                                                                                   |
| 8    | `Writing superblocks and filesystem accounting information: done`   | 写入最终配置到超级块，记录文件系统统计信息（总块数、空闲 inode 数等）                                                                                                                                                                   | 超级块                | 标志 ext4 核心结构创建完成，`/dev/nvme0n2p1` 成为可用分区，后续可挂载使用                                                                          |

这个输出不仅是格式化成功的证明，还包含两个关键信息供后续使用：

- UUID：用于永久挂载（/etc/fstab）
- 超级块备份地址：用于后续文件系统损坏时恢复

再格式化第二个分区：

```bash
mkfs.ext4 /dev/nvme0n2p2
```

```console
mke2fs 1.47.1 (20-May-2024)
Creating filesystem with 1048320 4k blocks and 262144 inodes
Filesystem UUID: c4055cd5-31fd-4e50-bfa5-0114fbc0d08b
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done 
```

验证格式化结果：

```bash
blkid /dev/nvme0n2p1 /dev/nvme0n2p2
```

```console
/dev/nvme0n2p1: UUID="e7632ba2-a3b6-460d-b932-8b5620639cc1" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-01"
/dev/nvme0n2p2: UUID="c4055cd5-31fd-4e50-bfa5-0114fbc0d08b" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-02"
```

可以看到格式化分区成功，接下来就可以执行挂载分区，开始使用了。

### mkfs.xfs

`mkfs.xfs` 是创建 XFS 文件系统的工具，XFS 以大文件支持好、读写吞吐高、可在线扩容为核心优势，特别适合存储视频、备份数据、数据库文件等场景，性能远超 ext4。

#### 核心结构创建逻辑

创建 XFS 文件系统结构，采用「分配组（AG）」设计，为核心的五大结构，每个 AG 都是独立的小文件系统：

| 核心结构              | 存储内容                                                                          | 作用（类比仓库）                     | mkfs.xfs 如何创建与配置                                                                                             |
| --------------------- | --------------------------------------------------------------------------------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| 超级块（Super Block） | 文件系统总大小、分配组（AG）数量（`-d agcount` 指定）、块大小（`-b size` 设置）等 | 仓库全局索引，定位各分配组           | 仅在分区开头写入 1 个主超级块（不备份），记录 AG 总数和分布，`-d agcount=8` 会在此记录 8 个 AG 的位置。             |
| 分配组（AG）          | 每个 AG 包含独立的「AG 超级块、inode 区、数据块区」，可并行读写                   | 仓库独立分区，多分区并行干活，速度快 | 按分区大小拆分 AG（默认 1GB/AG，大分区可到 16GB），`-d agcount` 可手动指定数量（如 8 个 AG 对应 8 核 CPU）。        |
| inode 区              | 动态创建 inode（按需分配，不预占空间），记录文件元信息，支持扩展属性              | 灵活的标签库，避免空间浪费           | 不在 AG 中预分配 inode 表，而是预留空间，后续创建文件时动态生成（无需像 ext4 那样担心 inode 耗尽）。                |
| 数据块区              | 用 B + 树管理数据块索引（找大文件更快），块大小由 `-b size` 指定，存储文件内容    | 高性能货架，适合大文件               | 每个 AG 内的块按 `-b size` 划分（如 8KB），B + 树索引自动维护，大文件可跨 AG 存储，提升读写效率。                   |
| 日志区（Log）         | 只记录元数据操作（如分配 inode），不记录数据内容，大小由 `-l size` 设置           | 轻量操作日志，平衡性能与安全         | 默认在分区末尾创建（大小 0.5%-2%），`-l size=128M` 可增大日志区，`-l device` 可指定独立日志分区（推荐高并发场景）。 |

#### 语法选项

```shell
mkfs.xfs [options] device [blocks-count]
```

| 选项                                                                                                                                                                                   | 描述                                                                                                                                                                                                                                                                                     | 适用场景与配置建议                                                                                                                                                                                                                   |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-b size=块大小`                                                                                                                                                                       | 指定数据块大小（单位：字节/K/M/G，如 `1k`/`4k`，默认 `4k`）                                                                                                                                                                                                                              | **按工作负载优化**<br>• 小文件场景（日志/配置）：`-b size=1k` 减少空间浪费<br>• 大文件场景（视频/备份）：`-b size=4k` 或 `-b size=8k` 提升吞吐量<br>• 通用场景：默认 `4k` 最佳平衡                                                   |
| `-c options=配置项`                                                                                                                                                                    | 从配置文件读取参数（支持批量标准化配置）                                                                                                                                                                                                                                                 | **大规模部署**<br>• 集群环境：通过 `-c options /etc/mkfs.xfs.conf` 统一配置<br>• 自动化脚本：确保多节点参数一致性<br>• 审计需求：记录格式化参数便于追溯                                                                              |
| `-m 元数据选项`<br>`crc=0\|1`<br>`finobt=0\|1`<br>`uuid=xxx`<br>`rmapbt=0\|1`<br>`reflink=0\|1`<br>`inobtcount=0\|1`<br>`bigtime=0\|1`<br>`autofsck=xxx`                               | 配置元数据特性：<br>• CRC 校验：防止元数据损坏<br>• 空闲 inode B+ 树：优化 inode 分配<br>• 手动 UUID：固定文件系统标识<br>• 反向映射 B+树：支持高级功能<br>• 写时复制：高效文件克隆<br>• inode 计数：提升大目录性能<br>• 扩展时间戳：支持 2038 年后时间<br>• 自动 fsck：设置自动检查策略 | **数据安全与效率**<br>• 生产环境：`-m crc=1,reflink=1` 启用校验和写时复制<br>• 性能优化：`-m finobt=1,inobtcount=1` 提升大目录操作效率<br>• 长期系统：`-m bigtime=1` 支持扩展时间戳<br>• 特殊需求：`-m uuid=固定值` 保持挂载配置稳定 |
| `-d 数据区选项`<br>`agcount=数量`<br>`agsize=大小`<br>`file,name=xxx`<br>`size=大小`<br>`sunit=值，swidth=值`<br>`su=num,sw=num`<br>`noalign`<br>`sectsize=大小`<br>`concurrency=数量` | 配置数据分配组（AG）：<br>• AG 数量/大小：控制并发粒度<br>• 子卷名称：指定逻辑卷名<br>• 条带对齐：优化 RAID 性能<br>• 扇区大小：设置物理扇区对齐<br>• 并发数量：控制格式化并发度                                                                                                         | **存储优化**<br>• RAID 环境：`-d su=64k,sw=4` 匹配 RAID 条带参数<br>• 超大分区：`-d agcount=32` 增加并发（>4TB）<br>• 逻辑卷管理：`-d file,name=logical_vol` 指定卷名<br>• 高性能 SSD：`-d sectsize=4096` 对齐 4K 扇区               |
| `-f`                                                                                                                                                                                   | 强制覆盖现有文件系统（忽略安全警告）                                                                                                                                                                                                                                                     | **危险操作确认**<br>• 重新初始化：覆盖旧分区数据<br>• 自动化脚本：避免交互确认提示<br>• **⚠️ 注意**：确保数据已备份，操作不可逆                                                                                                       |
| `-i inode 选项`<br>`perblock=数量`<br>`size=大小`<br>`maxpct=百分比`<br>`attr=0\|1\|2`<br>`projid32bit=0\|1`<br>`sparse=0\|1`<br>`nrext64=0\|1`<br>`exchange=0\|1`                     | 配置 inode 特性：<br>• 每块 inode 数：控制 inode 密度<br>• inode 大小：存储扩展属性能力<br>• 空间占比：限制元数据开销<br>• 属性存储：优化 ACL 性能<br>• 32 位项目 ID：兼容性设置<br>• 稀疏 inode：节省空间<br>• 64 位扩展：大文件支持<br>• 交换支持：特殊场景优化                        | **元数据优化**<br>• 复杂权限：`-i size=512,attr=2` 容纳更多扩展属性<br>• 海量小文件：`-i perblock=4096` 增加 inode 密度<br>• 大文件为主：`-i maxpct=5` 减少 inode 开销<br>• 现代系统：`-i nrext64=1` 启用 64 位扩展支持              |
| `-K`                                                                                                                                                                                   | 跳过 TRIM 操作（不发送丢弃指令）                                                                                                                                                                                                                                                         | **特殊场景优化**<br>• 老旧设备：部分机械硬盘不支持 TRIM<br>• 数据恢复：避免立即擦除原有数据<br>• 性能测试：排除 TRIM 对格式化时间影响                                                                                                |
| `-l 日志选项`<br>`agnum=数量`<br>`internal`<br>`size=大小`<br>`logdev=设备`<br>`version=版本`<br>`sunit=值、|su=数量`<br>`sectsize=大小`<br>`lazy-count=0\|1`<br>`concurrency=数量`     | 配置日志区域：<br>• 日志位置：指定 AG 编号<br>• 内部日志：内置日志模式<br>• 日志大小：影响崩溃恢复速度<br>• 独立设备：提升性能与可靠性<br>• 日志版本：功能与兼容性<br>• 懒计数：优化元数据更新                                                                                           | **高可用配置**<br>• 数据库服务器：`-l size=2G` 增大日志缓冲区<br>• 关键业务：`-l logdev=/dev/ssdlog` 独立日志设备<br>• 性能敏感：`-l version=2,lazy-count=1` 启用优化<br>• 大容量系统：`-l size=4G` 支持更大事务                     |
| `-L 卷标名`                                                                                                                                                                            | 设置文件系统卷标（最大 12 字符）                                                                                                                                                                                                                                                         | **设备标识管理**<br>• 多磁盘环境：`-L "DATA_01"` 直观标识用途<br>• 自动化挂载：通过`/dev/disk/by-label/`稳定引用<br>• 避免设备名变更：不依赖易变的`/dev/sdX`路径                                                                     |
| `-n 目录选项`<br>`size=大小`<br>`version=2\|ci`<br>`ftype=0\|1`<br>`parent=0\|1`                                                                                                       | 配置目录结构：<br>• 目录块大小：影响目录项容量<br>• 版本控制：目录格式版本<br>• 文件类型记录：加速目录操作<br>• 父目录记录：优化目录遍历                                                                                                                                                 | **目录性能优化**<br>• 海量文件目录：`-n size=8k,ftype=1` 提升`ls`/`find`效率<br>• 现代系统：`-n version=ci` 启用大小写不敏感支持<br>• 深度目录：`-n parent=1` 优化深层目录遍历<br>• 默认配置：`-n size=4k,ftype=1` 平衡性能与空间    |
| `-N`                                                                                                                                                                                   | 模拟运行（显示参数但不执行）                                                                                                                                                                                                                                                             | **参数验证**<br>• 脚本调试：检查命令语法是否正确<br>• 风险评估：预览格式化将执行的操作<br>• 学习用途：了解各参数对文件系统的影响                                                                                                     |
| `-p 原型文件`                                                                                                                                                                          | 从原型文件复制文件系统结构                                                                                                                                                                                                                                                               | **标准化部署**<br>• 嵌入式系统：基于模板快速生成一致结构<br>• 批量创建：确保多个文件系统元数据一致<br>• 特殊配置：继承原型文件的复杂权限设置                                                                                         |
| `-q`                                                                                                                                                                                   | 安静模式（仅输出错误信息）                                                                                                                                                                                                                                                               | **自动化环境**<br>• 部署脚本：减少日志输出干扰<br>• 流水线操作：配合返回值判断执行状态<br>• 后台任务：避免控制台输出占用资源                                                                                                         |
| `-r 实时区选项`<br>`extsize=大小`<br>`size=大小`<br>`rtdev=设备`                                                                                                                       | 配置实时子卷：<br>• 扩展大小：实时文件分配单元<br>• 实时区大小：限制实时文件容量<br>• 独立设备：专用高速存储区域                                                                                                                                                                         | **高性能写入**<br>• 视频采集：`-r rtdev=/dev/nvme1n1` 专用实时存储<br>• 数据流处理：`-r extsize=64k` 优化连续写入<br>• 科学计算：隔离实时数据与普通文件 IO<br>• 大文件处理：`-r size=100g` 分配专用实时空间                          |
| `-s 扇区大小`                                                                                                                                                                          | 指定逻辑扇区大小（默认自动检测）                                                                                                                                                                                                                                                         | **存储对齐优化**<br>• 4K 高级格式硬盘：`-s size=4096` 强制 4K 对齐<br>• 传统环境：`-s size=512` 兼容旧系统<br>• 性能调优：匹配底层设备物理扇区大小                                                                                   |
| `-V`                                                                                                                                                                                   | 显示版本和功能支持信息                                                                                                                                                                                                                                                                   | **环境检查**<br>• 特性验证：确认当前版本是否支持所需功能<br>• 故障排查：检查工具链版本兼容性<br>• 文档记录：记录生成文件系统的工具版本                                                                                               |
| `设备名`                                                                                                                                                                               | 目标存储设备路径（必选参数）                                                                                                                                                                                                                                                             | **所有操作基础**<br>• 本地磁盘：`/dev/sdX`或`/dev/nvmeXn1`<br>• 逻辑卷：`/dev/mapper/vg0-lv1`<br>• RAID 设备：`/dev/md0`<br>• **⚠️ 确认**：通过`lsblk`确认设备未挂载且路径正确                                                        |

*在 XFS 的选项参数中，`0` 通常表示​​禁用功能​​，`1` 表示​​启用功能​​。*

> [!TIP]
> 对于大多数非专业用户的日常场景（如数据存储盘或系统分区），直接使用 `mkfs.xfs` 的默认选项是最佳选择。XFS 的默认配置（自适应块组、CRC 校验、写时复制支持等）已经过深度优化，在性能、数据完整性和空间效率方面达到了理想平衡，完全能够满足 90% 以上的常规使用场景。

#### 创建 xfs 文件系统

同样，首先要确认目标分区，避免误操作：

```bash
lsblk -o NAME,FSTYPE
```

```console
NAME        FSTYPE
sr0         iso9660
nvme0n1     
├─nvme0n1p1 
├─nvme0n1p2 xfs
└─nvme0n1p3 LVM2_member
  ├─rl-root xfs
  └─rl-swap swap
nvme0n3     
├─nvme0n3p1 
└─nvme0n3p2 
nvme0n2     
├─nvme0n2p1 ext4
└─nvme0n2p2 ext4
nvme0n4     
├─nvme0n4p1 
└─nvme0n4p2 
```

确认好硬盘，就可以直接对 `nvme0n3` 执行格式化操作：

```bash
mkfs.xfs /dev/nvme0n3p1
```

```console
meta-data=/dev/nvme0n3p1         isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
         =                       exchange=0  
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

这段输出是 `mkfs.xfs /dev/nvme0n3p1` 执行后，XFS 文件系统创建过程的配置日志，是清晰记录了文件系统的核心结构、默认参数和资源分配情况。每个模块对应文件系统的一个核心功能部分：

1. meta-data（元数据配置）

    ```shell
    meta-data=/dev/nvme0n3p1         isize=512    agcount=4, agsize=32768000 blks
            =                       sectsz=512   attr=2, projid32bit=1
            =                       crc=1        finobt=1, sparse=1, rmapbt=1
            =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
            =                       exchange=0  
    ```

    这部分记录文件系统的基础规则，对应 XFS 的超级块 + 分配组描述：

    | 关键字段            | 作用                                                                                                                                                 |
    | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `/dev/nvme0n3p1`    | 基础信息，确保操作对象正确。                                                                                                                         |
    | `isize=512`         | 默认 512 字节足够存大多数文件的元信息，还能兼容扩展属性（如文件 ACL 权限）                                                                           |
    | `agcount=4`         | 4 个 AG 可支持多任务并行读写（比如同时存 4 个文件，分别用 4 个 AG 的资源），提升效率                                                                 |
    | `agsize=65536 blks` | 每个 AG 大小 = 65536 × 4KB = 256MB，4 个 AG 总大小 = 4×256MB = 1GB（即 `nvme0n3p1` 分区是 1GB）                                                      |
    | `sectsz=512`        | 磁盘扇区大小为 512 字节（匹配底层硬件的物理扇区），确保文件系统和硬件对齐，避免读写性能损耗                                                          |
    | `crc=1`             | 默认开校验，防止突然断电、磁盘错误导致数据混乱，提升可靠性                                                                                           |
    | `reflink=1`         | 启用重写功能（复制文件时不复制内容，只建指向，改一个不影响另一个），适合频繁复制大文件的场景（如虚拟机镜像），省空间、复制快，默认开启不影响普通使用 |

2. data（数据区配置）

   ```shell
   data     =                       bsize=4096   blocks=262144, imaxpct=25
            =                       sunit=0      swidth=0 blks
   ```

   这部分是文件系统的核心存储区，对应 XFS 的数据块区（实际存文件内容的地方）：

   | 关键字段            | 作用                                                                                                                                                                       |
   | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | `bsize=4096`        | 数据块大小为 4KB（1 个数据块是 XFS 存内容的最小单位），默认 4KB 是平衡最优解：既不会因块太小（如 1KB）导致小文件多时空闲浪费，也不会因块太大（如 8KB）导致大文件读写效率低 |
   | `blocks=262144`     | 总数据块数量为 262144 个，总存储容量 = 262144 × 4KB = 1024MB = 1GB（再次确认分区大小是 1GB，和 meta-data 一致）                                                            |
   | `imaxpct=25`        | inode 最多占用 25% 的分区空间（防止 inode 太多占满空间），默认留 25% 足够应对存大量小文件的场景（如日志），普通场景用不到这么多，不会浪费                                  |
   | `sunit=0, swidth=0` | 未适配 RAID 条带（sunit=RAID 条带单元，swidth = 条带宽度），因为是普通单盘分区，不是 RAID 阵列，所以默认 0；如果是 RAID，才需要手动配置这两个参数                          |

3. naming（目录配置）

    ```shell
    aming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
    ```

    这部分控制目录如何存储文件名，对应 XFS 的目录项结构：

    | 关键字段     | 作用                                                                                                                                                              |
    | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `version 2`  | 目录格式用第 2 版（XFS 的主流目录格式），兼容新功能（如长文件名、文件类型记录），稳定性高                                                                         |
    | `bsize=4096` | 目录块大小为 4KB（目录本身也是文件，用 4KB 块存文件名→inode 的映射），4KB 块能存更多文件名映射（比如一个块能存几十上百个文件名），提升 `ls`/`find` 等目录操作速度 |
    | `ftype=1`    | 记录文件类型（是普通文件、目录还是链接），执行 `ls -l` 时，系统不用额外查 inode 就能知道文件类型，加快命令执行速度                                                |
    | `ascii-ci=0` | 文件名区分大小写（如 File.txt 和 file.txt 是两个不同文件），符合 Linux 系统的默认习惯，避免大小写混乱                                                             |

4. log（日志区配置）

    ```shell
    log      =internal log           bsize=4096   blocks=16384, version=2
            =                       sectsz=512   sunit=1 blks, lazy-count=1
    ```

    这部分是 XFS 的崩溃恢复保障，对应日志区（记录所有磁盘操作，突然断电后能恢复数据）：

    | 关键字段       | 作用                                                                                                                                |
    | -------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
    | `internal log` | 日志区在当前分区内部（不是独立磁盘），普通场景不用独立日志盘，内部日志足够保障安全，还省硬件成本                                    |
    | `bsize=4096`   | 日志块大小为 4KB（和数据块大小一致，减少读写切换损耗），日志和数据块大小统一，提升写日志→写数据的连贯效率                           |
    | `blocks=16384` | 日志区共 16384 个块，总大小 = 16384 × 4KB = 64MB。64MB 日志区足够应对普通读写负载（如日常存文件、办公数据），不会因日志太小频繁刷盘 |
    | `lazy-count=1` | 延迟更新日志计数（减少磁盘 IO 次数），默认开延迟，在不影响安全性的前提下，降低磁盘读写压力，提升整体性能                            |

5. realtime（实时区配置）：专门存大文件的 “快速通道”

    ```shell
    realtime =none                   extsz=4096   blocks=0, rtextents=0
    ```

    这部分是 XFS 针对连续写大文件的优化区（如视频录制、大数据采集），但默认不启用：

    | 关键字段         | 作用                                                                                               |
    | ---------------- | -------------------------------------------------------------------------------------------------- |
    | `realtime =none` | 不启用实时区，普通场景（存文档、图片、小视频）用不到实时区，默认关闭避免浪费空间；需要时再手动配置 |
    | `extsz=4096`     | 若启用实时区，实时块大小为 4KB（和数据块一致），预留配置，确保启用时和现有结构兼容                 |

如果只是存日常数据、办公文件、普通备份，完全不用管这些参数；只有特殊需求（如 RAID 适配、存百万级小文件），才需要在 `mkfs.xfs` 后加额外选项调整。

在格式化第二个分区 `/dev/nvme0n3p2` 时，指定 `-L` 选项为分区设置标签，否则默认标签为空：

```bash
mkfs.xfs -L "data" /dev/nvme0n3p2
```

```console
meta-data=/dev/nvme0n3p2         isize=512    agcount=4, agsize=130944 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
         =                       exchange=0  
data     =                       bsize=4096   blocks=523776, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

再使用 `blkid` 命令确认分区已成功格式化为 XFS：

```bash
blkid /dev/nvme0n3p1 /dev/nvme0n3p2
```

```console
/dev/nvme0n3p1: UUID="55a73882-71bb-47d7-b027-3ade38d71035" BLOCK_SIZE="512" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="de9976b7-f594-4c95-8752-b4ee9d4a497a"
/dev/nvme0n3p2: LABEL="data" UUID="8da350d2-19b9-41dd-bcb9-dfb9d13c71a0" BLOCK_SIZE="512" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="83bdd6bd-a34d-4f23-8145-dd75edab877a"
```

## 挂载

Linux 的核心设计理念是「一切皆文件」。无论是硬盘分区、U 盘、光盘，还是键盘、鼠标等硬件设备，最终在系统中都会被抽象为一个设备文件。例如，之前看到的 `/dev/nvme0n3p2` 就是一个代表 NVMe 固态硬盘上某个分区的设备文件。

然而，这些设备文件本身只是一个访问入口或标识符，并不直接包含可以浏览的文件和文件夹。设备内部的实际内容（如 ext4 或 XFS 文件系统）必须与 Linux 的目录树（即由 `/`, `/home`, `/mnt` 等构成的层级结构）关联起来，操作系统和用户才能访问其中的数据。这个关联的过程，就称为​​挂载​​。

简单来说：

- ​​挂载​​就是将存储设备（如分区 `/dev/nvme0n3p2`）链接到目录树中的某个空文件夹（称为​​挂载点​​，例如 `/mnt/data`）
- 挂载后，访问这个挂载点文件夹，就相当于访问该存储设备的内容
- 能够进行挂载的前提是设备必须包含一个操作系统可识别的文件系统（如 XFS, ext4, NTFS 等），文件系统是存储设备和目录树之间的「翻译官」

如果想在家目录下访问另一个分区的文件，不能直接操作 `/dev/nvme0n3p2` 这个设备文件。正确的做法是，先将该分区挂载到一个目录（例如 `/home/yourname/data`），之后通过访问 `/home/yourname/data` 这个文件夹，就能像操作普通文件夹一样使用该分区中的文件了。如果没有挂载，`/dev/nvme0n3p2` 仅仅是一个没有内容的设备标识符，其中的文件系统对用户是不可见的。

### mount

`mount` 命令是 Linux 中用于挂载存储设备的核心工具，通过它可以将设备（如分区、U 盘、光盘）与系统目录树中的文件夹（挂载点）绑定，让设备内容可访问。

```shell
 mount [options] <source> <directory>
```

| 常用           | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `a`            | 挂载 `/etc/fstab` 文件里记录的所有文件系统（后续永久挂载的核心）                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `-l`           | 在列出已挂载设备时，额外显示文件系统的卷标 (Label)                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `-t <type>`    | 指定文件系统类型​​。如 xfs, ext4, ntfs, vfat, iso9660 等。默认会尝试自动识别 (auto)，识别失败时需手动指定                                                                                                                                                                                                                                                                                                                                                                                            |
| `-v`           | 详细模式​​。显示更详细的挂载过程信息，包括尝试的文件系统类型、使用的选项等                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `-o <options>` | ​​挂载选项​​。提供对挂载行为的精细控制，多个选项用逗号分隔。这是最灵活强大的选项。常用选项包括：<br>· `ro`/`rw`: 只读 / 读写挂载 （默认通常是 rw） <br>· `noexec`: 禁止执行挂载点上的二进制程序<br>· `nosuid`: 忽略 setuid 和 setgid 权限位<br>· `nodev`: 不解释挂载点上的设备文件<br>· `remount`: 重新挂载一个已挂载的文件系统，常用于更改选项 （如 `mount -o remount,ro /mountpoint`）<br>· `defaults`: 使用默认选项 (`rw`, `suid`, `dev`, `exec`, `auto`, `nouser`, `async`)<br>· `async`/`sync`: 异步 / 同步写入<br>· `user`/`nouser`: 允许 / 禁止普通用户挂载|
| `-w`           | 默认模式，允许写入挂载点（默认是只读挂载）                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `-r`           | 等价于 `-o ro`，只读挂载（简化写法）                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-n`           | 不将挂载信息写入 `/etc/mtab` 文件（默认行为），用于临时挂载或脚本中（避免污染配置）                                                                                                                                                                                                                                                                                                                                                                                                                  |

参数 `Source` 指要挂载的设备：

| 指定挂载源                                | 描述                                                     |
| ----------------------------------------- | -------------------------------------------------------- |
| `-L <卷标> / LABEL=<卷标>`                | 用文件系统卷标定位                                       |
| `-U <UUID> / UUID=<UUID>`                 | 用文件系统 UUID 定位，每个分区的 UUID 唯一，比卷标更可靠 |
| `/dev/<设备名>`                           | 用设备名定位，最直接但可能变动                           |
| `PARTLABEL=<分区标>/PARTUUID=<分区 UUID>` | 用分区标签或 UUID 定位，不是文件系统的，少用             |

`Operations` 是特殊挂载需求，日常最常用 3 个：

|操作语法|描述|实际场景举例|
|-|-|-|
|`--bind <源目录> <目标目录>`|「绑定挂载」把一个目录的内容复制到另一个目录（不是真复制，是关联）|想让普通用户在 `/home/user/data` 访问 `/mnt/data` 的内容，不用复制文件：`mount --bind /mnt/data /home/user/data`，此时两个目录内容完全同步|
|`--move <旧挂载点> <新挂载点>`|「移动挂载点」把已挂载的设备，从旧目录移到新目录（不用卸载再挂载）|已挂载 `/dev/nvme0n3p2` 到 `/mnt/data`，想移到 `/data：mount --move /mnt/data /data`，移完后访问 `/data` 就是原分区内容|
|`--rbind <源目录> <目标目录>`|「递归绑定挂载」和` --bind` 类似，但会关联源目录下的子挂载点（如源目录里还有挂载的 U 盘）|若 `/mnt/data` 里还挂载了 `/dev/sdb1`（U 盘），用 `mount --rbind /mnt/data /home/user/data`，用户访问 `/home/user/data` 时，也能看到 U 盘内容|

如果直接执行 `mount` 命令（不带任何参数）的作用是列出系统中所有已挂载的文件系统及其详细信息，包括设备来源、挂载点、文件系统类型和挂载选项等。这是查看系统挂载状态最全面的方式之一，输出内容虽长，但遵循固定格式，理解后能快速定位关键信息：

```bash
mount
```

```console
/dev/mapper/rl-root on / type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=209701,mode=755,inode64)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
……
```

每一行对应一个已挂载的文件系统，格式为：

```shell
<源设备/虚拟文件系统> on <挂载点> type <文件系统类型> (<挂载选项>)
```

输出中包含多种类型的挂载（物理设备、虚拟文件系统、临时文件系统等），按常用性分类解析：

1. 物理设备分区（实际存储设备的挂载，最受关注）

    这类条目对应硬盘 分区、U 盘等物理设备，格式以 `/dev/` 开头：

    ```shell
    # 系统根分区（核心分区，所有文件的起点）
    /dev/mapper/rl-root on / type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)

    # 系统引导分区（存放开机启动文件）
    /dev/nvme0n1p2 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
    ```

    - 关键信息：`/dev/xxx` 是设备路径，`/` 和 `/boot` 是挂载点（系统必须的核心目录），`type xfs` 说明文件系统类型，`(rw,...)` 表示读写权限。

2. 虚拟文件系统（内核与用户空间的接口，不对应实际存储）

    这类条目是 Linux 内核提供的伪文件系统，用于暴露系统状态（如内存、进程、硬件信息），不占用磁盘空间：

    ```shell
    # 进程信息文件系统（通过 /proc 可查看进程、CPU等信息）
    proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)

    # 内核设备信息（/dev 下的设备文件，如 /dev/nvme0n1 对应磁盘）
    devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,...)

    # 系统内核参数（/sys 下可查看/修改内核配置，如硬件驱动状态）
    sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
    ```

    - 这些是 Linux「一切皆文件」理念的体现，通过文件操作即可与内核交互（如 `cat /proc/cpuinfo` 查看 CPU 信息）

3. 临时文件系统（基于内存的临时存储，重启后数据消失）

    以 `tmpfs` 或 `devpts` 等类型存在，用于存放临时数据，速度远快于磁盘：

    ```shell
    # 临时共享内存（/dev/shm 可用于程序间快速交换数据，基于内存）
    tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)

    # 临时运行目录（/run 存放系统启动时的临时文件，如进程PID）
    tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=342384k,...)

    # 用户临时目录（/run/user/0 是 root 用户的临时空间，普通用户为 /run/user/1000）
    tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,...)
    ```

    - 数据存于内存，读写速度快，但重启后清空，适合临时缓存、会话数据等

4. 特殊功能文件系统（用于特定内核功能）

    这类文件系统服务于内核高级功能（如调试、安全、进程控制等）：

    ```shell
    # 安全模块文件系统（SELinux 相关配置，控制文件访问权限）
    selinuxfs on /sys/fs/selinux type selinuxfs (rw,nosuid,noexec,relatime)

    # 内核调试文件系统（用于调试内核，开发人员常用）
    debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime,seclabel)

    # 跟踪文件系统（记录内核函数调用，用于性能分析）
    tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime,seclabel)
    ```

    - 普通用户很少直接操作，主要供系统管理员或开发人员调试、配置系统

### 临时挂载

临时挂载是指通过 `mount` 命令手动执行的挂载操作，不依赖系统配置文件（如 `/etc/fstab`）。在当前系统运行周期内，将存储设备（如分区、U 盘）与挂载点文件夹**临时**绑定，让设备可访问；但一旦系统重启、关机，或执行 `umount` 卸载命令，这个绑定关系会自动消失，下次使用需重新执行 `mount` 命令。

1. 确认设备

    先通过命令确认要挂载的设备是否存在、未挂载，防止格式化错设备：

    ```bash
    lsblk /dev/nvme0n2 -o NAME,FSTYPE,SIZE,MOUNTPOINT
    ```

    ```console
    NAME        FSTYPE SIZE MOUNTPOINT
    nvme0n2              5G 
    ├─nvme0n2p1 ext4     1G 
    └─nvme0n2p2 ext4     4G 
    ```

    确保设备的 MOUNTPOINT 列为空（未挂载），且 FSTYPE 是目标文件系统（如 xfs/ext4）。

    查看设备 UUID 和卷标，后续挂载需要使用：

    ```bash
    blkid /dev/nvme0n2p1 /dev/nvme0n2p2
    ```

    ```console
    /dev/nvme0n2p1: UUID="e7632ba2-a3b6-460d-b932-8b5620639cc1" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-01"
    /dev/nvme0n2p2: UUID="c4055cd5-31fd-4e50-bfa5-0114fbc0d08b" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-02"
    ```

2. 建挂载点

    挂载点是设备内容的访问入口，建议放在 `/mnt`（临时挂载）或 `/data`（永久存储）目录下，且必须是空文件夹。

    分别创建两个挂载点 `/mnt/data1` 和 `/mnt/data2`，用于挂载 `/dev/nvme0n2p1` 和 `/dev/nvme0n2p2` 分区：

    ```bash
    mkdir -p /mnt/data1 /mnt/data2
    ```

    ```bash
    ls -la /mnt/data1 /mnt/data2
    ```

    ```console
    /mnt/data1:
    total 0
    drwxr-xr-x. 2 root root  6 Sep 29 11:30 .
    drwxr-xr-x. 4 root root 32 Sep 29 11:30 ..

    /mnt/data2:
    total 0
    drwxr-xr-x. 2 root root  6 Sep 29 11:30 .
    drwxr-xr-x. 4 root root 32 Sep 29 11:30 ..
    ```

    > [!TIP] 挂载点
    > 在 `/` 盘下执行 `mkdir /mnt/data1` 创建挂载点时，这个 `/mnt/data1` 本质是 `/` 目录下的一个空目录项，不是存储文件的空间。Linux 中目录的本质是「文件名→inode 的映射表」，空目录的映射表只有 1 条（记录自身），仅占用几十字节的元数据（存在 `/` 盘的 inode 表中），完全可以忽略，不会消耗 `/` 盘的实际存储。
    >
    > 当执行 `mount /dev/nvme0n2p1 /mnt/data1` 后，这个 `/mnt/data1` 的空间属性会被替换成被挂载设备（`/dev/ nvme0n2p1`）的空间，和 `/` 盘再无关系。

3. 执行挂载

    优先用卷标或 UUID 挂载，设备路径可能因插新盘变化，卷标 / UUID 永久不变。

    > [!NOTE] 格式化后设置卷标
    > 如果在格式化的时候没有设置卷标，可以使用 `e2label` 和 `xfs_admin` 命令为已格式化的分区设置卷标：
    >
    > - 对于 ext4 文件系统（用 `e2label` 工具）：`e2label /dev/nvme0n2p1 mydata`
    >
    > - 对于 XFS 文件系统（用 `xfs_admin` 工具）：`xfs_admin -L mydata /dev/nvme0n2p1`
    >
    > `e2label` 和 `xfs_admin` 是 Linux 系统中专门管理文件系统元数据的工具，核心功能是查看 / 设置文件系统的卷标（Label）。

    使用 `/dev/nvme0n2p1` 的 UUID 进行挂载到 `/mnt/data1`：

    ```bash
    mount UUID=e7632ba2-a3b6-460d-b932-8b5620639cc1 /mnt/data1
    ```

    使用 `/dev/nvme0n2p2` 的 UUID 进行挂载到 `/mnt/data2`：

    ```bash
    mount UUID=c4055cd5-31fd-4e50-bfa5-0114fbc0d08b /mnt/data2
    ```

4. 验证挂载

挂载后通过`df -h` 或 `mount` 命令查看挂载信息，确认是否生效：

```bash
df -h
```

```console {10,11}
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/rl-root   17G  2.5G   15G  15% /
devtmpfs             4.0M     0  4.0M   0% /dev
tmpfs                836M     0  836M   0% /dev/shm
tmpfs                335M  6.3M  329M   2% /run
tmpfs                1.0M     0  1.0M   0% /run/credentials/systemd-journald.service
/dev/nvme0n1p2       960M  247M  714M  26% /boot
tmpfs                1.0M     0  1.0M   0% /run/credentials/getty@tty1.service
tmpfs                168M  4.0K  168M   1% /run/user/0
/dev/nvme0n2p1       974M   24K  907M   1% /mnt/data1
/dev/nvme0n2p2       3.9G   24K  3.7G   1% /mnt/data2
```

输出中明确显示 `/dev/nvme0n2p1` 关联 `/mnt/data1`（容量 974M）、`/dev/nvme0n2p2` 关联 `/mnt/data2`（容量 3.9G），说明两个分区已成功挂载。

```bash
mount | grep /mnt/data
```

```console
/dev/nvme0n2p1 on /mnt/data1 type ext4 (rw,relatime,seclabel)
/dev/nvme0n2p2 on /mnt/data2 type ext4 (rw,relatime,seclabel)
```

- `type ext4`：确认两个分区的文件系统均为 ext4（与格式化时的配置一致）
- `(rw, ...)`：rw 表示 “读写模式”，说明分区可正常创建、修改、删除文件（若为 `ro` 则为只读，需调整挂载选项）

可以实际测试，在 `/mnt/data1` 和 `/mnt/data2` 分别创建文件，验证是否能正常读写：

```bash
echo "hello world" | tee /mnt/data1/test.txt /mnt/data2/test.txt
```

```bash
cat /mnt/data1/test.txt /mnt/data2/test.txt
```

```console
hello world
hello world
```

读写功能可正常创建文件并写入内容，读取时无异常，确认分区可投入实际使用。

临时挂载需要注意，重启后文件不会丢，但是挂载关系会断开，需要重新挂载。若每天都需要访问 `/dev/nvme0n2p1`，临时挂载会很麻烦（每天重启后都要手动 `mount`），此时必须配置永久挂载。

### 永久挂载

临时挂载重启后会失效，若需要 `/dev/nvme0n2p1`、`/dev/nvme0n2p2` 这类固定分区每次开机自动挂载，就需要配置永久挂载。核心是通过系统配置文件 `/etc/fstab` 实现，系统启动时会自动读取该文件的挂载规则，无需手动执行 `mount` 命令。

`/etc/fstab`（filesystem table，文件系统表）是 Linux 系统用于存储 “永久挂载规则” 的配置文件，所有需要开机自动挂载的设备，都需在该文件中添加一条规则：

:::code-group
```shell [/etc/fstab]
#
# /etc/fstab
# Created by anaconda on Fri Jul  4 02:09:33 2025
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=832de919-24b7-4cc3-937e-27eb203ceb8e /                       xfs     defaults        0 0
UUID=8a23603e-7674-4fd5-8515-a757bd9a2fc1 /boot                   xfs     defaults        0 0
UUID=10226468-de0a-42a6-a380-9c3b5e1f04a4 none                    swap    defaults        0 0
```
:::

配置文件中每行对应一个文件系统的永久挂载规则，严格遵循 6 个字段的固定格式，字段之间用空格或制表符分隔，顺序不可颠倒。完整格式模板及各字段详解如下：

```shell
<设备标识>  <挂载点>  <文件系统类型>  <挂载选项>  <dump>  <pass>
```

- 设备标识：精准定位要挂载的设备（告诉系统挂载哪个设备）可以是设备路径、卷标、UUID 等
- 挂载点：指定要挂载到的目录（挂载到哪个目录下），必须是已存在的目录
- 文件系统类型：指定要挂载的文件系统类型（如 ext4、xfs、swap 等）
- 挂载选项：指定挂载时的额外选项（如 `defaults`、`ro`、`rw` 等）
- `dump`：是否在 `dump` 备份时包含该文件系统（`0` 表示不包含，`1` 表示包含）
- `pass`：是否在 `fsck` 检查文件系统时包含该文件系统（`0` 表示不包含，`1` 表示包含）

> [!WARNING]
> 配置`/etc/fstab` 的「挂载选项、`dump`、`pass`」字段时，需重点注意以下风险点，避免因配置错误导致挂载失败、系统开机卡住或数据访问异常：
>
> 挂载选项：`defaults` 是多数场景的安全选择（包含读写、自动挂载等基础规则），若手动指定选项需注意格式（多个选项用逗号分隔，无空格，如 `defaults,ro`）；避免误设 `ro`（只读）却需写入数据（会提示 `Permission denied`），或误加 `noexec`（禁止执行程序）却需运行分区内脚本（会提示 `Permission denied`）。
>
> `dump`：现代 Linux 系统几乎不再使用 `dump` 工具备份，此字段建议固定填 `0`（不包含在 `dump` 备份中）；若填 `1`，不仅无实际备份意义，还可能因 `dump` 工具扫描占用系统资源，影响分区正常使用。
>
> `pass`：此字段控制 `fsck` 磁盘检查顺序，需严格区分分区类型根分区（`/`）可填 `1`（优先检查），其他普通分区（如 `/mnt/data1`）填 `2`（次优先检查）或 `0`（不检查），交换分区（`swap`）必须填 `0`（无需检查）；若给非根分区填 `1`，会导致开机时 `fsck` 检查顺序冲突，系统可能卡在检查阶段无法启动。

首先，使用 `umount` 先卸载之前临时的挂载（虽不影响，但无法验证 `fstab` 规则是否真的能独立生效（比如 UUID 是否填对、文件系统类型是否正确，所以先卸载再添加）：

```bash
umount /mnt/data1 /mnt/data2
```

然后再编辑 `/etc/fstab` 添加永久挂载规则：

```bash
vim /etc/fstab
```

```console:line-numbers=13 {2,3}
……
UUID=e7632ba2-a3b6-460d-b932-8b5620639cc1 /mnt/data1                       xfs     defaults        0 0
UUID=c4055cd5-31fd-4e50-bfa5-0114fbc0d08b /mnt/data2                       xfs     defaults        0 0
```

最后，执行挂载测试：

```bash
mount -a
```

让系统加载 `/etc/fstab` 中的新规则，无输出即无错误。

> [!NOTE] umount
> `umount` 是 Linux 中用于卸载已挂载文件系统的命令，作用与 `mount` 相反：它会解除存储设备（如分区、U 盘）与挂载点目录之间的关联，让设备可以安全移除（如拔 U 盘）或重新配置（如修改挂载选项）。若设备因被程序占用而无法卸载（提示 `device is busy`），`umount` 也会报错，需先关闭占用程序再重试。
>
> 即使是通过 `/etc/fstab` 配置的永久挂载分区，也可以用 `umount` 命令手动卸载。

此时，即使再次重启，`/mnt/data1` 和 `/mnt/data2` 也会自动挂载，永久挂载配置完成：

```bash
df -h /mnt/data1 /mnt/data2
```