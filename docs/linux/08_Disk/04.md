# 分区

分区是在物理硬盘上划分多个逻辑区域的操作。它的核心作用是隔离数据（例如将系统文件和用户数据分开存储），同时便于管理不同用途的存储空间。分区需要依赖分区表（如 MBR 或 GPT）来记录分区的位置、大小等信息，操作系统通过分区表识别和访问各个分区。

> [!NOTE] 分区、格式化和挂载
> 这是将物理硬盘转化为 Linux 系统可直接使用的存储资源的核心流程。简单来说：
>
> - 分区是给硬盘划分独立区域
> - 格式化是为每个区域建立数据管理规则
> - 挂载则是将这些区域接入系统的目录树，让用户能通过目录访问其中的文件
>
> 三者环环相扣，共同完成从硬盘到可用存储空间的转化。

## 分区表类型

在 Linux 中，硬盘分区的核心差异体现在分区表类型上，主流的两种分区方式对应两种分区表：

- **MBR**（Master Boot Record，主引导记录）
- **GPT**（GUID Partition Table，全局唯一标识分区表）

这两种方式决定了硬盘如何记录分区信息（位置、大小、类型等），也直接影响分区的功能和限制：

| 对比维度     | MBR 分区表（传统分区方式）                                                        | GPT 分区表（现代分区方式）                                                          |
| ------------ | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| 核心特点     | 最早的分区表标准，位于硬盘 0 扇区，包含主引导程序、64 字节分区表和结束标志。      | 属于 UEFI 规范，用 GUID 标识分区，分区表在硬盘首尾备份，自带 CRC 校验，安全性更高。 |
| 分区数量限制 | 最多 4 个主分区；如需更多分区，需 1 个扩展分区 + 逻辑分区（逻辑分区通常≤15 个）。 | 原生支持 128 个主分区，无需扩展分区和逻辑分区。                                     |
| 最大容量支持 | 单盘最大 2TB（32 位扇区地址限制）。                                               | 单盘最大 18EB（1EB=1024PB），满足大容量硬盘需求。                                   |
| 启动兼容性   | 仅支持传统 BIOS 启动，不支持 UEFI。                                               | 原生支持 UEFI 启动，兼容 64 位系统，对 NVMe SSD 等新型硬件支持更好。                |
| 元数据记录   | 仅记录基础分区信息（位置、大小）。                                                | 可记录分区名称、类型描述等更多元数据，管理更灵活。                                  |
| 安全性       | 无分区表备份和校验，损坏后易丢失数据。                                            | 分区表首尾备份，支持错误检测与恢复，安全性更高。                                    |
| 适用场景     | 老旧设备、容量≤2TB 的硬盘、需兼容传统 BIOS 的系统。                               | 新设备、容量＞2TB 的硬盘、使用 UEFI 启动的系统、多分区管理场景（如服务器）。        |

> [!TIP] 分区表类型建议
> 在新部署的服务器 / 存储中，无论硬盘大小，优先选择 GPT，尤其是 2TB 以上硬盘必须用 GPT，避免容量浪费和后期扩展问题。若服务器支持 UEFI，务必用 GPT（配合 EFI 系统分区），提升启动安全性和兼容性；若仅支持 BIOS，可用 MBR。
>
> 大容量数据盘（如存储服务器的硬盘）强制用 GPT；小容量数据盘若需兼容旧设备，可考虑 MBR，但建议统一用 GPT 减少管理复杂度。

## fdisk

`fdisk` 是 Linux 系统中最经典、最常用的命令行分区工具，主要用于管理 MBR（Master Boot Record）分区表，也支持对 GPT（GUID Partition Table）分区表进行基础操作（高级 GPT 操作更推荐 `gdisk`）。它轻量、无依赖，是系统管理员初始化硬盘、划分分区的核心工具。

fdisk 的核心作用是对硬盘的分区表和分区进行创建、查看、修改、删除，具体包括：

- 查看硬盘当前的分区表类型（MBR/GPT）、分区数量、分区大小、分区类型（如 Linux、swap、EFI 等）
- 为空白硬盘创建 MBR 分区表（GPT 也支持，但功能有限）
- 划分新分区（指定分区大小、类型、起始扇区等）
- 删除无用分区、调整分区状态（如设置活动分区，仅 MBR 有效）
- 查并修复分区表的基础错误

```shell
fdisk [选项] <设备名>
```

| 常见选项    | 作用                                                                                 |
| ----------- | ------------------------------------------------------------------------------------ |
| `-l`        | 列出所有硬盘及分区信息（最常用），不加设备名则显示所有硬盘，加设备名则只显示指定硬盘 |
| `-u`        | 以扇区为单位显示分区大小（默认以柱面显示，扇区更精确）                               |
| `-s <分区>` | 显示指定分区的大小（单位：块，1 块 = 1024 字节），用于快速查询分区容量               |

*`fdisk` 的选项较少，主要用于非交互模式下的查询或特殊操作。*

最常用的就是 `fdisk -l` 来查看分区信息和 `fdisk <设备名>` 来进入交互模式对特定磁盘进行操作。​

其中 `fdisk -l` 输出的每一项信息都对应硬盘的关键属性：

```shell
Disk /dev/nvme0n2: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 641174E2-7FE8-48DD-B683-4196913BBF6C
```

第一部分：物理磁盘 `/dev/nvme0n2` 的整体信息：

| 输出内容                                                | 解释                                                                                                                                                            |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Disk /dev/nvme0n2`                                     | 磁盘设备文件名。NVMe 协议的磁盘命名规则与普通 SATA 硬盘（`sda`, `sdb`）不同，格式为 `nvme{控制器编号}n{命名空间编号}`。这里是第 0 个控制器上的第 2 个命名空间。 |
| `20 GiB, 21474836480 bytes`                             | 磁盘的​​总容量​​。以人类易读的单位（GiB）和精确的字节数两种方式显示。                                                                                           |
| `41943040 sectors`                                      | 磁盘总共有多少个​​扇区​​。容量 = 扇区数 * 扇区大小（512 字节）。                                                                                                |
| `Disk model: VMware Virtual NVMe Disk`                  | 磁盘的型号。这里显示它是一个 VMware 虚拟机中的虚拟 NVMe 磁盘。                                                                                                  |
| `Units: sectors of 1 * 512 = 512 bytes`                 | 说明下面分区列表中的数字单位是​​扇区​​，且每个扇区大小为 ​​512 字节​​。                                                                                         |
| `Sector size (logical/physical): 512 bytes / 512 bytes` | 逻辑扇区​​和​​物理扇区​​的大小。高级格式磁盘（4K 扇区）可能会在这里显示为 512 bytes / 4096 bytes。                                                              |
| `I/O size (minimum/optimal): 512 bytes / 512 bytes`     | 进行 I/O 操作时最小和最优的块大小。                                                                                                                             |
| `Disklabel type: gpt`                                   | ​​极其重要！​​这表示该磁盘使用的分区表类型是 ​​GPT​​，而不是传统的 ​​dos​​（即 MBR）。                                                                          |
| `Disk identifier: 641174E2-...`                         | 磁盘的​​唯一标识符​​。对于 GPT，这是一个全局唯一的 GUID；对于 MBR，则是一个随机的十六进制数。                                                                   |

```shell
Device           Start      End  Sectors Size Type
/dev/nvme0n2p1    2048     4095     2048   1M BIOS boot
/dev/nvme0n2p2    4096  2101247  2097152   1G Linux extended boot
/dev/nvme0n2p3 2101248 41940991 39839744  19G Linux LVM
```

第二部分：磁盘 `/dev/nvme0n2` 上的分区列表：

| 列名      | 解释                                                                                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `Device`  | 分区​​的设备文件名。NVMe 分区的命名规则是在磁盘名后加 `p{分区编号}`，例如 `nvme0n2p1`。对于 SATA 硬盘，则是 `sda1`, `sda2`。 |
| `Start`   | 该分区的​​起始扇区​​。分区总是从 2048 扇区（即 1MiB 的位置）开始，这是为了对齐 4K 扇区以获得最佳性能。                       |
| `End`     | 该分区的​​结束扇区​​。                                                                                                       |
| `Sectors` | 该分区总共包含的扇区数量。`End - Start + 1 = Sectors`。                                                                      |
| `Size`    | 该分区的​​容量​​，以人类易读的单位显示（K, M, G, T）。                                                                       |
| `Type`    | 分区的​​类型​​。这是在分区表中设置的一个标识，用于说明分区的用途。                                                           |

```shell
Disk /dev/mapper/rl-root: 17 GiB, 18249416704 bytes, 35643392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/mapper/rl-swap: 2 GiB, 2147483648 bytes, 4194304 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

第三部分：LVM 逻辑卷信息，`fdisk -l` 会尝试列出系统中已知的​​逻辑卷​​，它们看起来像独立的磁盘设备：

| 输出内容                | 解释                                                                                                                                  |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `/dev/mapper/rl-root`   | ​​这是一个 LVM ​​逻辑卷​​的设备文件。rl 是卷组（Volume Group, VG）的名字，root 是逻辑卷（LV）的名字。它通常被挂载到系统的根目录 `/`。 |
| `​​/dev/mapper/rl-swap` | 这是另一个 LVM 逻辑卷，名为 swap。                                                                                                    |

通过解读 `fdisk -l` 的输出，可以清晰地看到这台机器的存储结构：

1. ​​物理磁盘​​：一块 20GB 的虚拟 NVMe 磁盘 (`/dev/nvme0n2`)，使用 ​​GPT​​ 分区表
2. ​​分区布局​​：
   1. p1: 1MB 的 BIOS 启动分区
   2. p2: 1GB 的 `/boot` 分区（ext4 文件系统）
   3. p3: 19GB 的 LVM 物理卷
3. ​​逻辑卷布局​​（建立在 p3 之上）：
   1. root: 17GB，用于根文件系统
   2. swap: 2GB，用于交换空间

> [!TIP] LVM 和 逻辑卷
> 逻辑卷（Logical Volume, LV）是 LVM（Logical Volume Manager，逻辑卷管理）架构中的核心组件之一。LVM 是 Linux 系统中用于灵活管理磁盘分区和存储空间的工具，它通过抽象物理存储设备、整合资源并动态分配空间，解决了传统分区（如 MBR/GPT 分区）大小固定、调整困难的问题，而逻辑卷正是 LVM 实现动态存储管理的关键载体。

### 交互模式

`fdisk` 是一个用于创建和操作磁盘分区表的命令行工具。输入的 `fdisk /dev/nvme0n2` 表示要对名为 `nvme0n2` 的 NVMe 固态硬盘进行分区操作。进入交互模式后，所有输入的命令（如 `m`, `n`, `d` 等）都​​只是存储在内存中​​，并不会立即对磁盘做出实际改变。只有在最后输入 `w`(write) 命令后，所有的修改才会被一次性写入磁盘并生效。如果输入 `q`(quit)，则会退出程序且​​所有修改都会被丢弃​​。

```bash
fdisk /dev/nvme0n2
```

```console
Welcome to fdisk (util-linux 2.40.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

This disk is currently in use - repartitioning is probably a bad idea.
It's recommended to umount all file systems, and swapoff all swap
partitions on this disk.
```

其中 `This disk is currently……` 告警是 `fdisk` 工具发出的重要风险提示（非致命错误，但需高度重视），核心目的是警告：当前操作的硬盘（此处为 `/dev/nvme0n2`）正处于被使用状态，直接对其重新分区（repartitioning）可能导致数据损坏或系统异常。

`fdisk` 交互模式下输入 `m` 后显示的帮助菜单，包含了所有可用指令的分类说明：

```shell
Command (m for help): m

Help:

  GPT
   M   enter protective/hybrid MBR

  Generic
   d   delete a partition
   F   list free unpartitioned space
   l   list known partition types
   n   add a new partition
   p   print the partition table
   t   change a partition type
   v   verify the partition table
   i   print information about a partition
   e   resize a partition

  Misc
   m   print this menu
   x   extra functionality (experts only)

  Script
   I   load disk layout from sfdisk script file
   O   dump disk layout to sfdisk script file

  Save & Exit
   w   write table to disk and exit
   q   quit without saving changes

  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty MBR (DOS) partition table
   s   create a new empty Sun partition table

Command (m for help): 
```

GPT 相关指令：

| 指令 | 解释                                                                                          | 作用                                                                                                                                                                                                                                                           |
| ---- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `M`  | 进入「保护性 / 混合 MBR」模式（仅 GPT 分区表可用）。属于 GPT 专属指令，MBR 分区表下无此功能。 | 在 GPT 格式的硬盘上，创建一个兼容传统 MBR 规范的分区表（即混合 MBR），实现对 UEFI 和传统 BIOS 两种启动模式的兼容；仅用于老旧设备与新设备混合的特殊场景（如同一硬盘需在 UEFI 电脑和传统 BIOS 电脑间切换使用），日常分区（如服务器、个人电脑常规部署）极少用到。 |

通用指令：

| 指令 | 解释                                             | 作用与使用场景                                                                                                                                                                                                                                                     |
| ---- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `d`  | 删除一个分区，属于核心操作指令。                 | 输入后需指定要删除的分区编号（如 `d 1` 表示删除第 1 个分区）。注意：删除操作会直接清除分区数据且无法恢复，执行前务必确认分区编号和数据备份状态，避免误删系统分区或重要数据分区。                                                                                   |
| `F`  | 列出未分区的空闲空间，单位为扇区。               | 用于查看硬盘上剩余的可分配空间（如总空闲扇区数、起始 / 结束位置），帮助判断是否有足够空间创建新分区。例如，新增分区前执行 `F`，可确认剩余容量是否满足需求。                                                                                                        |
| `l`  | 列出已知的分区类型代码，包含各类系统的分区标识。 | 显示所有支持的分区类型及对应代码（如 `83` 对应 Linux 基本分区、`82` 对应 Linux swap 分区、`EF` 对应 EFI 系统分区）。修改分区类型（`t` 指令）时，需参考此列表中的代码指定类型。                                                                                     |
| `n`  | 添加一个新分区，是初始化硬盘的核心指令。         | 输入后按提示依次选择：分区类型（主分区 `p` 或扩展分区 `e`，仅 MBR 分区表需要）、分区编号（默认按顺序分配）、起始扇区（默认从第一个可用扇区开始，直接回车即可）、结束扇区（可指定大小如 `+10G` 或直接回车用满剩余空间）。适用于新硬盘首次分区或为已有硬盘新增分区。 |
| `p`  | 打印分区表，最常用的信息查询指令。               | 显示当前硬盘的完整分区信息，包括：分区编号、启动标志（Boot）、起始扇区（Start）、结束扇区（End）、总扇区数（Sectors）、容量（Size）、类型标识（Id）、分区类型（Type）。操作前后必用，用于确认分区状态（如新建分区是否成功、删除分区后是否生效）。                  |
| `t`  | 更改分区类型，需配合分区类型代码使用。           | 输入后先指定分区编号（如 `t 2` 表示修改第 2 个分区），再输入目标类型代码（参考 `l` 指令的列表）。例如：将分区改为 swap 类型时，输入代码 `82`；改为 EFI 系统分区时，输入代码 `EF`。适用于调整分区用途（如将普通分区转为 swap 分区）。                               |
| `v`  | 验证分区表，检查分区表的合法性。                 | 扫描分区表并检测潜在错误（如分区重叠、起始 / 结束扇区越界、容量计算异常等），输出验证结果（如 No errors found. 或具体错误提示）。操作完成后执行 `v`，可确认分区表是否规范，降低后续使用风险。                                                                      |
| `i`  | 打印指定分区的详细信息。                         | 输入后指定分区编号（如 `i 3` 表示查看第 3 个分区），显示该分区的详细参数：包括分区类型名称、UUID、起始 / 结束扇区（十进制和十六进制）、总扇区数、容量、是否激活等。适用于深入了解单个分区的属性。                                                                  |
| `e`  | 调整分区大小，支持扩展或缩小分区。               | 输入后指定分区编号，可修改分区的起始 / 结束扇区以调整容量。注意：此操作风险极高，可能导致文件系统损坏和数据丢失，且 `fdisk` 对分区调整的支持有限（不支持在线调整、不自动同步文件系统），建议优先使用 `parted` 或专门的分区调整工具（如 `resize2fs` 配合使用）。    |

杂项指令：

| 指令 | 解释                                                                   | 作用与使用场景                                                                                                                                                                                                             |
| ---- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `m`  | 打印帮助菜单，即当前显示的指令列表。                                   | 忘记指令功能时，输入 `m` 可随时调出所有指令的分类说明，适合新手查阅。例如，不确定 `n` 指令的用法时，输入 `m` 可快速查看其功能。                                                                                            |
| `x`  | 进入高级功能模式（Extra functionality for experts only），即专家模式。 | 提供扇区级别的低级操作（如修改分区起始扇区、调整柱面大小、编辑分区表校验值等），这些操作直接作用于硬盘底层数据结构，错误使用会导致分区表损坏、数据丢失甚至硬盘无法识别。新手严禁使用，仅适用于专业人员修复特殊分区表问题。 |

脚本指令：

| 指令 | 解释                                                                             | 作用与使用场景                                                                                                                                                                                 |
| ---- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `I`  | 从 `sfdisk` 脚本文件加载分区布局（Load disk layout from sfdisk script file）。   | 读取预先编写的 `sfdisk` 脚本（包含分区表定义），批量创建分区，无需手动交互。适用于自动化部署场景（如批量初始化多块硬盘，确保分区结构一致）。例如，通过脚本快速为 10 块硬盘创建相同的分区方案。 |
| `O`  | 将当前分区表导出为 `sfdisk` 脚本文件（Dump disk layout to sfdisk script file）。 | 将当前硬盘的分区表信息保存为 `sfdisk` 脚本（文本格式），用于备份分区布局或复制到其他硬盘。例如：将服务器的硬盘分区表导出为脚本，作为部署标准模板复用。                                         |

> [!TIP] sfdisk
> sfdisk 脚本文件（通常以 `.sfdisk` 为后缀，也可无后缀）是一种 文本格式的分区表配置文件，本质是把硬盘的分区布局（如分区表类型、分区数量、每个分区的大小、类型、起始 / 结束扇区等）用标准化的文本语法记录下来，用于 批量创建分区、备份 / 恢复分区表 或 自动化部署（避免手动重复操作）。

保存与退出指令：

| 指令 | 解释                                             | 作用与使用场景                                                                                                                                                                       |
| ---- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `w`  | 将分区表写入磁盘并退出，所有操作的最终确认步骤。 | 执行 `w` 后，之前在交互模式中进行的所有操作（创建 / 删除分区、修改分区类型等）会被永久写入硬盘分区表，系统同步后生效。注意，一旦执行 `w`，操作无法撤销，需在确认所有设置正确后使用。 |
| `q`  | 不保存更改并退出，操作的安全出口。               | 放弃所有未保存的操作（如误创建分区、选错硬盘），退出 fdisk 交互模式，硬盘分区表保持原样。适用于操作失误、不确定是否正确或临时查看分区信息的场景，是新手避免误操作的关键指令。        |

创建新分区表指令：

| 指令 | 解释                               | 作用与使用场景                                                                                                                                                                                                             |
| ---- | ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `g`  | 创建一个新的空 GPT 分区表。        | 初始化硬盘为 GPT 分区表格式（会清空原有分区表和所有数据），支持大容量硬盘（＞2TB）、最多 128 个主分区，原生兼容 UEFI 启动模式。适用于新购大容量硬盘（如 4TB 数据盘）、需要 UEFI 启动的系统盘或需划分多个分区的场景。       |
| `G`  | 创建一个新的空 SGI（IRIX）分区表。 | 初始化硬盘为 SGI 系统专用的分区表格式，仅用于旧版 IRIX 操作系统（SGI 工作站专用），现代 Linux 系统几乎不用，日常操作可忽略。                                                                                               |
| `o`  | 创建一个新的空 MBR（DOS）分区表。  | 初始化硬盘为 MBR 分区表格式（会清空原有分区表和所有数据），支持最大 2TB 硬盘、最多 4 个主分区（或 3 主 + 1 扩展分区），兼容传统 BIOS 启动模式。适用于小容量硬盘（≤2TB）、老旧设备或仅需少量分区的场景（如 500GB 系统盘）。 |
| `s`  | 创建一个新的空 Sun 分区表。        | 初始化硬盘为 Sun 操作系统专用的分区表格式，仅用于 Sun Solaris 系统，现代 Linux 环境中极少使用，日常操作可忽略。                                                                                                            |

### 分区步骤

1. 确认目标硬盘设备名

   首先通过 `lsblk` 或 `fdisk -l` 查看硬盘设备名，避免误操作其他硬盘（使用 VMware 可以关机状态下添加新硬盘）：

   ```bash
   lsblk
   ```

   ```console
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   sr0          11:0    1  1.6G  0 rom  
   nvme0n1     259:0    0    5G  0 disk 
   nvme0n2     259:1    0   20G  0 disk 
   ├─nvme0n2p1 259:2    0    1M  0 part 
   ├─nvme0n2p2 259:3    0    1G  0 part /boot
   └─nvme0n2p3 259:4    0   19G  0 part 
   ├─rl-root 253:0    0   17G  0 lvm  /
   └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
   ```

   ```bash
   fdisk -l
   ```

   ```console
   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   ……
   ```

   可以从 `lsblk` 和 `fdisk -l` 的输出中能清晰识别到新添加的硬盘是 `/dev/nvme0n1`（容量 5G，无任何分区，状态为 `disk`，无挂载点和子分区），而原有系统盘是 `nvme0n2`（已分区并挂载了 `/boot`、`/` 和 `swap`），接下来就可以针对 `nvme0n1` 进行分区操作了。

2. 进入 `fdisk` 交互模式

   执行命令时务必指定新硬盘 `nvme0n1`，避免误操作系统盘 `nvme0n2`：

   ```bash
   fdisk /dev/nvme0n1
   ```

   进入后会看到提示符 `Command (m for help):`，表示已进入交互模式。先输入 `p` 打印分区表，确认 `nvme0n1` 是空白硬盘（无任何分区列表）：

   ```bash
   fdisk /dev/nvme0n1
   ```

   ```console
   Welcome to fdisk (util-linux 2.40.2).
   Changes will remain in memory only, until you decide to write them.
   Be careful before using the write command.

   Device does not contain a recognized partition table.
   Created a new DOS (MBR) disklabel with disk identifier 0x7d6e7fc8.

   Command (m for help): p
   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: dos
   Disk identifier: 0x7d6e7fc8
   ```

3. 创建 MBR 分区表（若硬盘无分区表）

   硬盘要使用，必须先有分区表，它相当于硬盘的目录索引，记录了硬盘上有多少个分区、每个分区的位置（起始 / 结束扇区）、分区类型等关键信息。而分区（用 `n` 创建）是在分区表这个容器里划分的子空间，没有分区表，就没有地方记录分区的信息，自然无法创建分区。

   但是在之前 `fdisk` 输出中：

   ```shell
   Device does not contain a recognized partition table.
   Created a new DOS (MBR) disklabel with disk identifier 0x7d6e7fc8.
   ```

   这里的 `DOS (MBR) disklabel` 就是 MBR 分区表。`fdisk` 的默认规则是：如果检测到硬盘没有可识别的分区表，会自动创建一个 MBR 分区表（这是传统且兼容性广的分区表类型）。所以对于这个场景来说，不需要再手动输 `o` 创建分区表，直接输 `n` 新建分区即可。

   如果硬盘之前用过，有 MBR/GPT 分区表（甚至残留分区记录），但现在需要彻底格式化重新分区，此时就可以输入 `o` 强制覆盖旧的分区表，创建一个全新的空 MBR 分区表，避免旧分区表干扰新操作（比如旧分区记录导致新分区无法创建）。

4. 新建分区

   输入 `n` 开始新建分区，首先会看到分区类型选择界面：

   ```shell{1}
   Command (m for help): n
   Partition type
      p   primary (0 primary, 0 extended, 4 free)
      e   extended (container for logical partitions)
   ```

   这是 MBR 分区表特有的规则，核心限制是，MBR 分区表最多支持 4 个主分区，或 3 个主分区 + 1 个扩展分区（扩展分区内可创建多个逻辑分区，突破 4 个分区的限制）。

   | 分区类型        | 含义与特点                                                                                                                            | 适用场景                                                                          |
   | --------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
   | `p`（主分区）   | 可直接格式化并挂载使用；MBR 表中最多创建 4 个；可设置为活动分区（用于引导系统）。                                                     | 分区数量 ≤4 时；需要作为系统引导分区（如 `/boot` 分区）。                         |
   | `e`（扩展分区） | 本身不能直接使用（需在内部创建逻辑分区）；MBR 表中最多创建 1 个；相当于「容器」，可容纳多个逻辑分区（无数量限制，仅受硬盘容量影响）。 | 分区数量 ＞4 时，如需要 5 个及以上分区，先建 1 个扩展分区，再在里面分逻辑分区）。 |

   MBR 表当前 0 主分区、0 扩展分区、4 个空闲名额（`0 primary, 0 extended, 4 free`），因此直接选择 `p`（主分区） 即可，无需创建扩展分区：

   ```shell{1,2,3,4}
   Select (default p): p
   Partition number (1-4, default 1): 1
   First sector (2048-10485759, default 2048): 
   Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G

   Created a new partition 1 of type 'Linux' and of size 1 GiB.
   ```

   选择 p 后，`fdisk` 会继续提示以下 3 个关键参数配置：

   - 选择分区编号（Partition number）：MBR 主分区编号范围是 `1-4`，`default 1` 表示默认创建第 1 个主分区，首次创建分区时，通常按默认即可
   - 选择起始扇区（First sector）：硬盘的最小存储单位是扇区，默认从 `2048` 开始（跳过前 2047 扇区，避免覆盖分区表信息），直接回车即可
   - 选择结束扇区（Last sector）：决定分区大小（分区容量 = 结束扇区 - 起始扇区 + 1 ，再乘以每扇区字节数），可直接输入容量（如 `+1G` 表示 1GB，`+500M` 表示 500MB，`+2K` 表示 2KB），如果直接回车，会使用 `default 10485759`，即把硬盘剩余的所有空间（5GB）都分配给当前分区。

5. 查看分区

   再次输入 `p` 查看分区表，确认新分区 `nvme0n1p1` 已创建：

   ```shell{1}
   Command (m for help): p

   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: dos
   Disk identifier: 0x7d6e7fc8

   Device         Boot Start     End Sectors Size Id Type
   /dev/nvme0n1p1       2048 2099199 2097152   1G 83 Linux
   ```

   输出会新增以下分区记录，说明分区成功：

   ```shell
   Device         Boot Start     End Sectors Size Id Type
   /dev/nvme0n1p1       2048 2099199 2097152   1G 83 Linux
   ```

6. 保存分区

   最后输入 `w` 保存所有操作，这一步才会真正将分区表写入硬盘，未执行 `w` 前所有操作都是临时的：

   ```shell{1}
   Command (m for help): w
   The partition table has been altered.
   Calling ioctl() to re-read partition table.
   Syncing disks.
   ```

   - `The partition table has been altered.`：确认分区表已被成功修改（内存中的配置已写入硬盘）
   - `Calling ioctl() to re-read partition table.`：系统自动调用 `ioctl` 接口，通知内核重新读取硬盘分区表，使新分区立即被系统识别（无需重启）。极少数情况下，内核可能无法实时刷新分区表，此时需执行 `partprobe /dev/nvme0n1` 手动刷新，或重启系统
   - `Syncing disks.`：执行磁盘同步操作，将缓存中的数据强制写入硬盘物理介质，避免因意外断电导致分区表写入不完整

7. 查看新分区是否被系统识别

   退出 `fdisk` 后，用 `lsblk` 查看新分区是否被系统识别：

   ```bash
   lsblk
   ```

   ```console{3,4}
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   sr0          11:0    1  1.6G  0 rom  
   nvme0n1     259:0    0    5G  0 disk 
   └─nvme0n1p1 259:5    0    1G  0 part
   nvme0n2     259:1    0   20G  0 disk 
   ├─nvme0n2p1 259:2    0    1M  0 part 
   ├─nvme0n2p2 259:3    0    1G  0 part /boot
   └─nvme0n2p3 259:4    0   19G  0 part 
   ├─rl-root 253:0    0   17G  0 lvm  /
   └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
   ```

   输出会显示新分区 `nvme0n1p1`，说明系统已识别。到这里，新硬盘的分区步骤就完成了。

剩余的 4G 空间继续分区的步骤和第一次完全相同，因为 MBR 分区表支持最多 4 个主分区，当前只创建了 1 个（`nvme0n1p1`），还有 3 个主分区的名额可以使用。

```bash
fdisk /dev/nvme0n1
```

```console{5,9-12,16,29}
Welcome to fdisk (util-linux 2.40.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 2
First sector (2099200-10485759, default 2099200): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-10485759, default 10485759): 

Created a new partition 2 of type 'Linux' and of size 4 GiB.

Command (m for help): p
Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x7d6e7fc8

Device         Boot   Start      End Sectors Size Id Type
/dev/nvme0n1p1         2048  2099199 2097152   1G 83 Linux
/dev/nvme0n1p2      2099200 10485759 8386560   4G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

```bash
lsblk | grep "nvme0n1"
```

```console
nvme0n1     259:0    0    5G  0 disk 
├─nvme0n1p1 259:5    0    1G  0 part 
└─nvme0n1p2 259:8    0    4G  0 part 
```

接下来需要对 `nvme0n1p1`、`nvme0n1p2` 进行格式化（创建文件系统）和挂载，才能真正用于存储数据。

## gdisk

`gdisk` 是一个功能强大的命令行工具，主要用于在 Linux 系统上创建和管理 ​​GPT (GUID Partition Table)​​ 分区表。它是传统 `fdisk` 工具的现代替代品，特别适用于处理大容量硬盘（超过 2TB）和需要更多分区（超过 4 个主分区）的场景。

​​核心功能与特点：​​

- ​GPT 分区表管理：​​ 这是 `gdisk` 最主要的目的。GPT 是 UEFI 固件标准的一部分，取代了老旧的 MBR 分区方案。支持创建、删除、修改分区、更改分区类型 GUID、调整分区大小（需结合文件系统工具）、设置分区名称、检查分区表完整性等。支持超过 2TB 的磁盘，理论上分区数量几乎没有限制（标准是 128 个），具有更健壮的冗余和校验机制，分区表存储在磁盘的头部和尾部以提高安全性
- ​​MBR 兼容性处理：​​可以在 MBR 磁盘上安全地运行 `gdisk` 来查看信息。可以将 MBR 磁盘转换为 GPT 磁盘（使用 `gdisk` 并输入 `w` 写入时会自动进行转换，需谨慎，可能导致数据丢失）
- ​修复与恢复：​​ 提供命令尝试修复损坏的 GPT 分区表（利用备份头）。

> [!NOTE]
> 在 ​​Rocky Linux 10​​ 中，默认仓库通常不包含 `gdisk`（属于 `gptfdisk` 包）。需要先启用 ​​EPEL 仓库​​，然后安装 `gdisk`。

```shell
gdisk [选项] <设备名>
```

| 常见选项    | 作用                             |
| ----------- | -------------------------------- |
| `-l`        | 查看指定磁盘的分区表信息（只读） |
| `-b <文件>` | 备份分区表到文件                 |
| `-r <文件>` | 从备份文件恢复分区表             |

### 交互模式

与 `fdisk` 类似，运行 `gdisk` 也会进入一个交互式命令行环境，用户输入单字母命令进行操作。运行 `gdisk` 进入交互模式后，可通过以下菜单命令操作分区表，分为主菜单、恢复与转换菜单、专家菜单三类。

主菜单（常用基础功能）：

| 指令 | 解释                                        | 作用与使用场景                                                                                                                                                                                                        |
| ---- | ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `o`  | 创建新的空白 GPT 分区表，属于初始化核心指令 | 输入后需确认（Y/N），执行后会清除磁盘上所有现有分区数据，适用于新磁盘首次分区、彻底重新规划磁盘分区的场景，操作前务必提前备份数据                                                                                     |
| `n`  | 新建分区，属于分区创建核心指令              | 输入后需依次指定分区号（默认按顺序递增）、起始扇区（默认 2048，推荐保持默认以确保扇区对齐）、结束扇区（可直接输入大小，如 +100G，也可输入具体扇区数）、分区类型代码（默认 8300，即 Linux 文件系统），完成后生成新分区 |
| `d`  | 删除已有分区，属于分区删除核心指令          | 输入后需指定要删除的分区编号（如输入 1 即删除第 1 个分区），删除操作不可逆，会直接清除对应分区的数据，执行前需反复确认分区编号无误，且已备份分区内重要数据                                                            |
| `p’` | 打印当前分区表信息，属于查询类指令          | 执行后会显示磁盘的所有分区详情，包括分区编号、起始扇区、结束扇区、分区大小、分区类型代码、分区名称等，可用于确认分区配置结果、查看现有分区布局                                                                        |
| `t`  | 修改分区类型代码，属于分区配置类指令        | 输入后需先指定目标分区编号，再输入目标分区类型代码（如 EF00 对应 EFI 系统分区、8200 对应 Linux 交换分区），完成后更新分区的用途标识，匹配不同系统或功能需求                                                           |
| `c`  | 修改分区名称，属于分区标识配置指令          | 输入后需指定目标分区编号，再输入自定义的分区名称（如 `root-partition`，`data-partition`），GPT 分区表支持该功能，可通过名称快速区分不同分区的用途，方便管理                                                           |
| `w`  | 保存所有修改并写入磁盘，属于确认生效指令    | 输入后需确认（Y/N），执行后所有未保存的操作（如新建、删除、修改分区等）将实际写入磁盘，操作不可逆，需确保所有配置无误后再执行，避免错误修改生效                                                                       |
| `q`  | 放弃所有修改并退出，属于取消操作指令        | 执行后直接退出 gdisk 工具，所有未通过 w 指令保存的操作（如新建的分区、删除的分区记录）将被完全丢弃，适用于操作失误、临时取消分区计划的场景                                                                            |
| `r`  | 切换至恢复与转换菜单，属于菜单切换指令      | 输入后从主菜单进入恢复与转换子菜单，可使用分区表备份、恢复、格式转换等专项功能，需根据具体需求在子菜单中选择对应指令                                                                                                  |
| `x`  | 切换至专家菜单，属于高级功能菜单切换指令    | 输入后从主菜单进入专家子菜单，可使用扇区对齐调整、分区类型列表查看、分区表销毁等高级功能，仅推荐高级用户在明确需求时使用，避免误操作影响磁盘数据                                                                      |

恢复与转换菜单指令表（需先输入 `r` 进入）：

| 指令 | 解释                                                   | 作用与使用场景                                                                                                                                                                                                      |
| ---- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `b`  | 备份分区表到文件，属于分区表安全备份指令               | 输入后需指定备份文件名（如 `gpt-backup.bin`），工具会将当前磁盘的分区表信息完整保存到指定文件中，可用于灾难恢复（如后续分区表损坏时，可通过该备份文件恢复），建议在分区表配置完成后执行该操作                       |
| `l`  | 从备份文件恢复分区表，属于分区表恢复指令               | 输入后需指定备份文件路径（如 `./gpt-backup.bin`），工具会读取备份文件中的分区表信息，并覆盖当前磁盘的分区表，操作前需确认备份文件来源可靠、与目标磁盘匹配，且已备份当前磁盘的重要数据                               |
| `g`  | 将 MBR 分区表转换为 GPT 分区表，属于分区表格式转换指令 | 输入后工具会尝试保留原有 MBR 磁盘的分区数据，将分区表格式转换为 GPT（支持超过 4 个主分区、大容量磁盘），转换前需备份所有分区数据，避免因兼容问题导致数据丢失，适用于老旧 MBR 磁盘需支持 UEFI 启动或大容量分区的场景 |
| `m`  | 将 GPT 分区表转换为 MBR 分区表，属于分区表格式转换指令 | 输入后工具会尝试保留原有 GPT 磁盘的分区数据，转换为 MBR 格式（仅支持最多 4 个主分区），转换过程中若 GPT 分区数量超过 4 个，多余分区会丢失，需提前整理分区结构并备份数据，适用于需兼容传统 BIOS 启动的场景           |
| `o`  | 验证分区表完整性，属于分区表检测指令                   | 执行后工具会检查当前分区表是否存在错误（如分区重叠、扇区范围异常、类型代码不合法等），并输出检测结果，可用于排查分区表异常导致的磁盘识别问题                                                                        |
| `p`  | 返回主菜单，属于菜单切换指令                           | 输入后从恢复与转换菜单回到主菜单，可继续执行主菜单的常规分区操作（如新建、删除分区）                                                                                                                                |

专家菜单指令表（需先输入 `x` 进入）:

| 指令 | 解释                                       | 作用与使用场景                                                                                                                                                                                          |
| ---- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `z`  | 彻底销毁分区表并退出，属于危险操作指令     | 输入后需多次确认，执行后会清除磁盘的所有分区信息、擦除 GPT 签名，且不可逆，会导致磁盘变为未初始化状态，仅适用于彻底销毁磁盘分区痕迹的场景（如丢弃磁盘前清除数据标识），操作前需确保磁盘内无任何重要数据 |
| `e`  | 调整分区表的扇区对齐方式，属于高级优化指令 | 输入后可手动指定分区的起始扇区对齐值，默认对齐值已适配多数存储设备（如 SSD、HDD），一般无需修改；仅当存储设备有特殊对齐要求（如老旧设备、特殊硬件环境）时，由高级用户根据设备参数调整，优化磁盘读写性能 |
| `l`  | 列出所有支持的分区类型代码，属于查询类指令 | 执行后会显示 `gdisk` 支持的所有分区类型及其对应的十六进制代码（如 `EF00=EFI` 系统分区、`8300=Linux` 文件系统、`fd00=Linux RAID` 分区），可用于查询罕见分区类型代码，辅助正确配置分区用途                |
| `m`  | 显示专家菜单帮助信息，属于辅助查询指令     | 执行后会列出专家菜单的所有指令及简要说明，帮助用户了解各指令功能，适用于首次使用专家菜单、忘记指令作用时                                                                                                |
| `p`  | 返回主菜单，属于菜单切换指令               | 输入后从专家菜单回到主菜单，可切换至常规分区操作，避免在专家菜单中误执行高级指令                                                                                                                        |
| `v`  | 验证分区数据完整性，属于深度检测指令       | 执行后会比恢复菜单的 o 指令更细致地检查分区表（如分区与文件系统的兼容性、扇区分配合理性），输出详细检测报告，可用于排查复杂的分区表异常问题（如分区无法挂载、数据读写错误）                             |

### 分区步骤

同样，在分区时候首先要使用 `lsblk` 或 `fdisk -l` 找到新硬盘的设备标识，避免误操作现有磁盘：

```bash
lsblk
```

```console
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0          11:0    1  1.6G  0 rom  
nvme0n1     259:0    0   20G  0 disk 
├─nvme0n1p1 259:4    0    1M  0 part 
├─nvme0n1p2 259:5    0    1G  0 part /boot
└─nvme0n1p3 259:6    0   19G  0 part 
  ├─rl-root 253:0    0   17G  0 lvm  /
  └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
nvme0n2     259:1    0    5G  0 disk 
├─nvme0n2p1 259:2    0    1G  0 part 
└─nvme0n2p2 259:3    0    4G  0 part 
nvme0n3     259:7    0    3G  0 disk 
```

> [!NOTE]
> 在虚拟机中添加硬盘后设备名变化是正常现象，当新增硬盘时，新硬盘可能被识别为控制器的第一个命名空间，原有硬盘因控制器或命名空间顺序调整，编号被挤到后续位置。

1. 进入交互模式

   ```bash
   gdisk /dev/nvme0n3
   ```

   ```console
   GPT fdisk (gdisk) version 1.0.10

   Partition table scan:
   MBR: not present
   BSD: not present
   APM: not present
   GPT: not present

   Creating new GPT entries in memory.

   Command (? for help): 
   ```

   这段信息表示 `gdisk` 在扫描 `/dev/nvme0n3` 磁盘时，没有检测到任何类型的分区表：

   - `MBR: not present`：未检测到 MBR 分区表（传统的主引导记录分区表，支持最大 2TB 磁盘，最多 4 个主分区）。
   - `BSD: not present`：未检测到 BSD 分区表（伯克利软件分发系统的分区格式，主要用于类 Unix 系统）。
   - `APM: not present`：未检测到 APM 分区表（苹果分区图，早期苹果设备使用的分区格式）。
   - `GPT: not present`：未检测到 GPT 分区表（GUID 分区表，现代主流格式，支持大容量磁盘和超过 4 个主分区）。

   表明 `/dev/nvme0n3` 磁盘目前是未初始化状态，没有任何分区表结构，既然没有分区表，那么下一步需要先创建 GPT 分区表，再新建分区，具体步骤。

2. 创建 GPT 分区表

   ```shell{1,3}
   Command (? for help): o
   This option deletes all partitions and creates a new protective MBR.
   Proceed? (Y/N): y
   ```

   这个提示的意思是 `o` 命令会删除当前磁盘上所有已有的分区，由于 `/dev/nvme0n3` 原本就没有分区表，实际操作是创建全新的空白 GPT 分区表，并自动生成一个保护性 MBR（防止不支持 GPT 的旧系统误识别磁盘）。

3. 创建分区

   按提示指定分区号、起始扇区、分区大小和分区类型：

   ```shell{1,2,3,4,6}
   Command (? for help): n
   Partition number (1-128, default 1): 1
   First sector (34-6291422, default = 2048) or {+-}size{KMGTP}: 
   Last sector (2048-6291422, default = 6289407) or {+-}size{KMGTP}: +1G
   Current type is 8300 (Linux filesystem)
   Hex code or GUID (L to show codes, Enter = 8300): 
   Changed type of partition to 'Linux filesystem'
   ```

4. 查看分区表

   ```shell{1}
   Command (? for help): p
   Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB
   Model: VMware Virtual NVMe Disk
   Sector size (logical/physical): 512/512 bytes
   Disk identifier (GUID): 92258B1B-BF41-4914-8681-E8288E0EC0DC
   Partition table holds up to 128 entries
   Main partition table begins at sector 2 and ends at sector 33
   First usable sector is 34, last usable sector is 6291422
   Partitions will be aligned on 2048-sector boundaries
   Total free space is 4194237 sectors (2.0 GiB)

   Number  Start (sector)    End (sector)  Size       Code  Name
      1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   ```

   从 `p` 命令的输出结果来看，已经成功创建了一个分区，当前分区表状态清晰且正确，各个字段含义如下。

   磁盘基本信息：

   - `Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB`：目标磁盘是 `/dev/nvme0n3`，总扇区数 6291456，总容量 3.0 GiB
   - `Model: VMware Virtual NVMe Disk`：磁盘类型为 VMware 虚拟 NVMe 磁盘
   - `Sector size (logical/physical): 512/512 bytes`：逻辑 / 物理扇区大小均为 512 字节（标准配置）
   - `Disk identifier (GUID): ...`：GPT 分区表的唯一标识符（自动生成，无需关注）

   分区表配置信息：

   - `Partition table holds up to 128 entries`：GPT 分区表最多支持 128 个分区
   - `Main partition table begins at sector 2 and ends at sector 33`：GPT 主分区表存储在扇区 2-33（系统预留，不影响用户分区）
   - `First usable sector is 34, last usable sector is 6291422`：用户可用扇区范围（34 到 6291422），分区必须在这个范围内创建
   - `Partitions will be aligned on 2048-sector boundaries`：分区已按 2048 扇区对齐（即 1MB 对齐，符合 SSD/NVMe 性能优化要求）
   - `Total free space is 4194237 sectors (2.0 GiB)`：磁盘剩余可用空间为 2.0 GiB（可继续创建新分区）

   已创建的分区信息：

   | 编号（Number） | 起始扇区（Start） | 结束扇区（End） | 大小（Size） | 类型代码（Code） | 名称（Name）     |
   | -------------- | ----------------- | --------------- | ------------ | ---------------- | ---------------- |
   | 1              | 2048              | 2099199         | 1024.0 MiB   | 8300             | Linux filesystem |

5. 保存分区

   同样输入 `w` 保存所有操作：

   ```shell
   Command (? for help): w

   Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
   PARTITIONS!!

   Do you want to proceed? (Y/N): 
   ```

   这个提示是 `gdisk` 在执行 最终写入操作前的最后确认，核心含义是：一旦确认，当前在内存中配置的分区表将被 永久写入 `/dev/nvme0n3` 磁盘，覆盖磁盘上原有的所有分区信息。

   ```shell
   Do you want to proceed? (Y/N): y
   OK; writing new GUID partition table (GPT) to /dev/nvme0n3.
   The operation has completed successfully.
   ```

6. 确认分区是否生效

保存后可以通过 `lsblk`、`fdisk` 和 `gdisk` 命令查看分区是否生效：

```bash
lsblk | grep nvme0n3
```

```console
nvme0n3     259:7    0    3G  0 disk 
└─nvme0n3p1 259:9    0    1G  0 part 
```

```bash
fdisk -l /dev/nvme0n3
```

```console
Disk /dev/nvme0n3: 3 GiB, 3221225472 bytes, 6291456 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 92258B1B-BF41-4914-8681-E8288E0EC0DC

Device         Start     End Sectors Size Type
/dev/nvme0n3p1  2048 2099199 2097152   1G Linux filesystem
```

```bash
gdisk /dev/nvme0n3
```

```console{11}
GPT fdisk (gdisk) version 1.0.10

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): p
Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB
Model: VMware Virtual NVMe Disk
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): 92258B1B-BF41-4914-8681-E8288E0EC0DC
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 6291422
Partitions will be aligned on 2048-sector boundaries
Total free space is 4194237 sectors (2.0 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
```

## parted

parted 是一款功能强大的磁盘分区管理工具，支持 MBR 和 GPT 分区表，可处理大容量磁盘（超过 2TB），并提供分区创建、调整、删除等完整功能。与 `gdisk` 专注于 GPT 不同，`parted` 更灵活，支持交互式操作和非交互式命令行操作，适合快速分区和高级调整。

```shell
parted [OPTION]... [DEVICE [COMMAND [PARAMETERS]...]...]
```

`parted` 有两种使用模式，语法略有差异：

- **交互模式**：进入交互式界面，逐条输入命令，适合分步操作。若不指定 COMMAND，则进入交互模式（逐条输入命令）
- **非交互模式**：直接在命令行一次性指定所有操作。若指定 DEVICE（如 `/dev/nvme0n3`）和 COMMAND（如 `mkpart`），则直接执行对应操作

### 交互模式

和 `fdisk`、`gdisk` 磁盘分区管理工具一样，`parted` 也支持交互式操作，即在终端中输入命令，然后按下回车键执行。

```bash
parted
```

```console
GNU Parted 3.6
Using /dev/nvme0n1
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted)  
```

> [!WARNING]
> 直接运行 `parted` 命令而不指定设备时，它会​​自动选择系统中第一个可用的块设备​​作为默认操作对象。所以在使用 `parted` 时明确指定目标设备​​，避免误操作其他磁盘。

指定新的硬盘进入交互模式下，在 `parted` 交互模式下输入 `h` 或 `help` 会显示所有命令的简要帮助：

```bash
parted /dev/nvme0n4
```

```console{4}
GNU Parted 3.6
Using /dev/nvme0n4
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) h                                                                
  align-check TYPE N                       check partition N for
        TYPE(min|opt) alignment
  help [COMMAND]                           print general help, or help on
        COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel
        (partition table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all]            display the partition table, or
        available devices, or free space, or all found partitions
  quit                                     exit program
  rescue START END                         rescue a lost partition near
        START and END
  resizepart NUMBER END                    resize partition NUMBER
  rm NUMBER                                delete partition NUMBER
  select DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected
        device
  disk_toggle [FLAG]                       toggle the state of FLAG on
        selected device
  set NUMBER FLAG STATE                    change the FLAG on partition
        NUMBER
  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on
        partition NUMBER
  type NUMBER TYPE-ID or TYPE-UUID         type set TYPE-ID or TYPE-UUID of
        partition NUMBER
  unit UNIT                                set the default unit to UNIT
  version                                  display the version number and
        copyright information of GNU Parted
```

在 `parted` 交互模式下（即进入 `(parted)` 提示符后），所有命令均直接输入执行，无需额外格式。

基础帮助与退出命令：

|命令语法|功能说明|
|-|-|
|`help`,`h`|显示所有命令的简要帮助|
|`help [命令]` 或 `h [命令]`|显示指定命令的详细用法（如 `mkpart`、`rm` 等）|
|`quit`,`q`|退出交互模式，注意 `parted` 所有操作已即时生效，无需保存|
|version|显示 `parted` 版本及版权信息|

设备选择与切换命令：

|命令语法|功能说明|
|-|-|
|`select [设备路径]`|切换当前操作的磁盘，若启动 `parted` 时未指定设备，需先用此命令选择|

分区表操作命令：

|命令语法|功能说明|
|-|-|
|`mklabel [分区表类型]`,`mktable [分区表类型]`|创建新分区表，会彻底清除磁盘所有现有分区。支持类型：gpt，msdos|

分区创建与修改命令（核心功能）：

|命令语法|功能说明|
|-|-|
|`mkpart [分区类型] [文件系统标识] [起始位置] [结束位置]`|创建新分区/分区类型：primary（主分区）、logical（逻辑分区，仅 MBR 支持），GPT 可省略；文件系统标识：如 ext4、xfs（仅标记用途，不实际格式化）；起始/结束位置：必须带单位（MB/GB 等，如 1MB、1024MB）|
|`resizepart [分区编号] [新结束位置]`|调整已有分区的大小，需先卸载分区，仅扩展 / 缩小分区容器，需后续同步文件系统|
|`rm [分区编号]`|删除指定编号的分区，即时生效，数据不可恢复，务必确认编号正确|
|`rescue [起始位置] [结束位置]`|尝试恢复位于起始位置和结束位置之间的丢失分区，用于找回误删分区|

分区信息查询与验证命令：

|命令语法|功能说明|
|-|-|
|print|显示当前磁盘的分区表信息，分区编号、大小、类型等|
|`print [设备路径]`|显示指定磁盘的分区信息，无需切换设备|
|`print free`|显示磁盘的空闲空间，未分配的区域，便于规划分区|
|`print devices`|列出系统中所有可用的磁盘设备，如 `/dev/nvme0n1`、`/dev/sdb` 等|
|`align-check [对齐类型] [分区编号]`|检查分区的对齐状态：`min` 最小对齐，兼容旧设备；`opt` 最优对齐，SSD/NVMe 推荐|
|`unit [单位]`|设置后续输出的默认单位，如 `MB/GB/s`|

分区属性与标识设置命令：

|命令语法|功能说明|
|-|-|
|`name [分区编号] [名称]`|为分区设置名称，仅 GPT 分区表支持，方便识别用途|
|`set [分区编号] [标志] [on/off]`|为分区设置 / 取消特殊标志，控制分区功能，常用标志：`boot` 启动分区；`esp：EFI` 系统分区，UEFI 启动必需；`lvm` LVM 物理卷分区；`swap` 交换分区|
|`type [分区编号] [类型ID/UUID]`|设置分区的类型，GPT 特有，通过类型 ID 或 UUID 标识。常用类型 ID：`8300` Linux 文件系统；`8200` Linux 交换分区；`EF00` EFI 系统分区|
|`toggle [分区编号] [标志]`|切换分区标志的状态，`on` 变 `off`，`off` 变 `on`，等价于 `set` 命令的反向操作|

磁盘级属性设置命令：

|命令语法|功能说明|
|-|-|
|`disk_set [标志] [on/off]`|设置当前磁盘的全局标志，如 GPT 兼容 MBR 的 `pmbr_boot` 标志|
|`disk_toggle [标志]`|切换磁盘标志的状态，`on` 变 `off`，`off` 变 `on`|

### 分区步骤

进入交互模式下创建分区：

```bash
parted /dev/nvme0n4
```

```console {4}
GNU Parted 3.6
Using /dev/nvme0n4
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) p                                                                
Error: /dev/nvme0n4: unrecognised disk label
Model: VMware Virtual NVMe Disk (nvme)                                    
Disk /dev/nvme0n4: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags: 
(parted)   
```

提示 `Error: /dev/nvme0n4: unrecognised disk label` 表示 `/dev/nvme0n4` 磁盘尚未创建任何分区表（分区表类型为 unknown），这是新磁盘或被清除过分区表的典型状态。此时需要先创建分区表，才能继续分区操作。

1. 创建 GPT 分区表（初始化磁盘）

   ```shell{1,2}
   (parted) mklabel gpt
   (parted) p                                                            
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End  Size  File system  Name  Flags
   ```

   可以看到分区表类型(Partition Table)变为 `gpt`。

2. 创建分区

   创建分区需要指定名称、文件系统标识、起始位置和结束位置：

   ```shell
   (parted) mkpart
   Partition name?  []?
   File system type?  [ext2]? xfs
   Start? 2048s
   End? 1G
   ```

   名称留空，使用默认即可；文件系统标识可以选择 xfs。

   > [!NOTE] 文件系统标识
   > 文件系统标识只是**标识 / 标记**，​​不会实际格式化分区。在分区表中记录类型不会执行任何格式化操作​，后续需要使用专门的格式化命令。

   起始位置选择直接用 **扇区(s)** 作为单位，指定起始扇区为 `2048s`；结束位置使用 `1G`。

   > [!WARNING]
   > 如果出现告警 `Warning: The resulting partition is not properly aligned for bestperformance: 1953s % 2048s != 0s`，这个警告提示 **分区起始位置未按最优方式对齐**，可能影响磁盘性能（尤其是 SSD/NVMe）。
   >
   > 这可能是指定的起始位置 `1M` 被转换为扇区后是 1953 扇区。`parted` 默认用十进制容量（1M = 1000×1000 字节）换算扇区，而非二进制容量（1M = 1024×1024 字节），两者的换算结果差异直接导致起始扇区不对齐。导致 1953 不是 2048（最优对齐扇区数）的整数倍，导致对齐失败。
   >
   > 部分场景下 `1M` 看似对齐（如结束位置为 `1026M` 时），是 `parted` 因容量冗余自动将起始修正为 `2048s`，但该修正不稳定（若结束位置卡紧如 `1025M`，会恢复为 `1953s`），属于碰运气，不推荐依赖。
   >
   > 推荐用 MiB 或 GiB（二进制单位）换算扇区最可靠：1MiB=2048 扇区（正好是对齐单位的整数倍），能确保起始 / 结束扇区天然对齐，后续分区也能无缝衔接，彻底避开十进制单位（M/G）的换算偏差。

   创建后，用 `align-check` 命令确认对齐：

   ```shell
   (parted) align-check opt 1                                                
   1 aligned
   ```

   - `align-check`：核心命令，功能是检查分区的对齐方式
   - `opt`：参数，是 optimal 的缩写，表示检查是否满足最优对齐，针对 SSD/NVMe 等现代存储设备，最优对齐通常指起始扇区是 2048 的整数倍
   - `1`：参数，指定要检查的分区编号

   执行后返回的 `1 aligned` 表示：编号为 1 的分区（即 `nvme0n3p1`）满足最优对齐要求，无需调整，不会因对齐问题影响磁盘性能（尤其是随机读写速度）。

   ::: details 扩展方案：用百分比（%）设置分区（适合快速分配）

   若无需精确控制容量（如分一半磁盘给第一个分区），可直接用百分比指定起始 / 结束位置，`parted` 会自动计算对齐扇区，无需手动换算：

   ```shell
   (parted) mkpart
   Partition name?  []?                                                      
   File system type?  [ext2]? xfs                                            
   Start? 0%                                                                 
   End? 50%
   (parted) unit s
   (parted) p                                                                
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n3: 4194304s
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End       Size      File system  Name  Flags
   1      2048s  2097151s  2095104s  xfs
   ```

   适配任意磁盘容量，无需关注总扇区数，适合快速分区或脚本化操作；若需多分区连续衔接，确保前一个分区的结束比例与后一个分区的起始比例一致（如前一个结束 `50%`，后一个起始 `50%`）。
   :::

3. 查看分区

   输入 `p` 或则 `print` 查看分区表：

   ```shell{1}
   (parted) p                                                                
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size   File system  Name  Flags
   1      1049kB  1000MB  999MB  xfs
   ```

   ```shell
   (parted) q    
   ```

   退出交互模式，可以通过 `lsblk` 命令进行查看：

   ```bash
   lsblk /dev/nvme0n4
   ```

   ```console
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   nvme0n4     259:5    0    2G  0 disk 
   └─nvme0n4p1 259:12   0  953M  0 part 
   ```

### 非交互模式下分区

`parted` 的非交互模式与交互模式的 核心命令（如 `mkpart`、`rm`、`print` 等）功能完全一致，但语法上有两点关键差异：

1. 非交互模式需通过 `-s` 参数 启用静默模式（不输出交互提示）
2. 多个命令需通过 分号 `;` 分隔（或通过管道传递多行命令），一次性传递给 `parted`，而非逐行手动输入

注意，非交互模式中，`mkpart`、`rm` 等命令的参数顺序和交互模式相同（如 `mkpart` 仍遵循「名称→文件系统类型→起始→结束」）。交互模式中直接回车留空的参数（如分区名称），非交互模式需用空字符串 `''` 表示（否则会导致参数错位）。

1. 查看剩余空间

   ```bash
   parted -s /dev/nvme0n4 "print free"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
         17.4kB  1049kB  1031kB  Free Space
   1      1049kB  1000MB  999MB
         1000MB  2147MB  1147MB  Free Space
   ```

   从 `print free` 输出可知：

   - 第一个分区结束于 1000MB
   - 剩余空间从 1000MB 到 2147MB（磁盘总容量），共 1147MB

2. 创建第二个分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "mkpart '' xfs 1000MB 2147MB"
   ```

   - `-a optimal`：强制最优对齐
   - `-s`：静默模式，不弹出任何交互提示
   - `mkpart '' xfs`：是分区创建核心子命令，内部参数按「名称→文件系统标识→起始位置→结束位置」 顺序排列。`''`：分区名称留空；

3. 查看分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "p"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
   1      1049kB  1000MB  999MB
   2      1000MB  2147MB  1147MB
   ```

还可以使用百分比进行分区，先确定第一个分区在磁盘中的实际占比，再让分区 2 的起始百分比与之匹配，就能实现两个分区无缝衔接（中间无空闲空间），且 `parted` 会自动处理对齐问题，非常适合快速分配。

1. 删除分区 2

   ```bash
   parted -s /dev/nvme0n4 "rm 2"
   ```

2. 查看分区 1 占比

   ```bash
   parted /dev/nvme0n4 "unit % print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 100%
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End    Size   File system  Name  Flags
   1      0.05%  46.6%  46.5%
   ```

3. 使用百分比创建第二个分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "mkpart '' xfs 47% 100%"
   ```

   `parted` 对百分比中的小数点格式敏感（部分版本不支持带小数点的百分比，或受系统语言环境影响，把小数点解析为无效符号）。分区 1 结束于 `46.6%`，直接向上取整为 `47%`，`parted` 会自动衔接实际结束位置，不会浪费空间。

   ```bash
   parted /dev/nvme0n4 "unit % print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 100%
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End    Size   File system  Name  Flags
   1      0.05%  46.6%  46.5%
   2      46.6%  100%   53.4%
   ```

   ```bash
   parted /dev/nvme0n4 "print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
   1      1049kB  1000MB  999MB
   2      1000MB  2146MB  1146MB
   ```
