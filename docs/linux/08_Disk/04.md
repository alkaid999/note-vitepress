# 分区、格式化和挂载

这是将物理硬盘转化为 Linux 系统可直接使用的存储资源的核心流程。简单来说：

- 分区是给硬盘划分独立区域
- 格式化是为每个区域建立数据管理规则
- 挂载则是将这些区域接入系统的目录树，让用户能通过目录访问其中的文件

三者环环相扣，共同完成从硬盘到可用存储空间的转化。

## 分区
分区是在物理硬盘上划分多个逻辑区域的操作。它的核心作用是隔离数据（例如将系统文件和用户数据分开存储），同时便于管理不同用途的存储空间。分区需要依赖分区表（如 MBR 或 GPT）来记录分区的位置、大小等信息，操作系统通过分区表识别和访问各个分区。

### 分区表类型

在 Linux 中，硬盘分区的核心差异体现在分区表类型上，主流的两种分区方式对应两种分区表：

- **MBR**（Master Boot Record，主引导记录）
- **GPT**（GUID Partition Table，全局唯一标识分区表）

这两种方式决定了硬盘如何记录分区信息（位置、大小、类型等），也直接影响分区的功能和限制：

| 对比维度     | MBR 分区表（传统分区方式）                                                        | GPT 分区表（现代分区方式）                                                          |
| ------------ | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| 核心特点     | 最早的分区表标准，位于硬盘 0 扇区，包含主引导程序、64 字节分区表和结束标志      | 属于 UEFI 规范，用 GUID 标识分区，分区表在硬盘首尾备份，自带 CRC 校验，安全性更高 |
| 分区数量限制 | 最多 4 个主分区；如需更多分区，需 1 个扩展分区 + 逻辑分区（逻辑分区通常≤15 个） | 原生支持 128 个主分区，无需扩展分区和逻辑分区                                     |
| 最大容量支持 | 单盘最大 2TB（32 位扇区地址限制）                                               | 单盘最大 18EB（1EB=1024PB），满足大容量硬盘需求                                   |
| 启动兼容性   | 仅支持传统 BIOS 启动，不支持 UEFI                                               | 原生支持 UEFI 启动，兼容 64 位系统，对 NVMe SSD 等新型硬件支持更好                |
| 元数据记录   | 仅记录基础分区信息（位置、大小）                                                | 可记录分区名称、类型描述等更多元数据，管理更灵活                                  |
| 安全性       | 无分区表备份和校验，损坏后易丢失数据                                            | 分区表首尾备份，支持错误检测与恢复，安全性更高                                    |
| 适用场景     | 老旧设备、容量≤2TB 的硬盘、需兼容传统 BIOS 的系统                               | 新设备、容量＞2TB 的硬盘、使用 UEFI 启动的系统、多分区管理场景（如服务器）        |

> [!NOTE] 分区表类型建议
> 在新部署的服务器 / 存储中，无论硬盘大小，优先选择 GPT，尤其是 2TB 以上硬盘必须用 GPT，避免容量浪费和后期扩展问题。若服务器支持 UEFI，务必用 GPT（配合 EFI 系统分区），提升启动安全性和兼容性；若仅支持 BIOS，可用 MBR。
>
> 大容量数据盘（如存储服务器的硬盘）强制用 GPT；小容量数据盘若需兼容旧设备，可考虑 MBR，但建议统一用 GPT 减少管理复杂度。

### fdisk

`fdisk` 是 Linux 系统中最经典、最常用的命令行分区工具，主要用于管理 MBR（Master Boot Record）分区表，也支持对 GPT（GUID Partition Table）分区表进行基础操作（高级 GPT 操作更推荐 `gdisk`）。它轻量、无依赖，是系统管理员初始化硬盘、划分分区的核心工具。

fdisk 的核心作用是对硬盘的分区表和分区进行创建、查看、修改、删除，具体包括：

- 查看硬盘当前的分区表类型（MBR/GPT）、分区数量、分区大小、分区类型（如 Linux、swap、EFI 等）
- 为空白硬盘创建 MBR 分区表（GPT 也支持，但功能有限）
- 划分新分区（指定分区大小、类型、起始扇区等）
- 删除无用分区、调整分区状态（如设置活动分区，仅 MBR 有效）
- 查并修复分区表的基础错误

```shell
fdisk [选项] <设备名>
```

| 常见选项    | 作用                                                                                 |
| ----------- | ------------------------------------------------------------------------------------ |
| `-l`        | 列出所有硬盘及分区信息（最常用），不加设备名则显示所有硬盘，加设备名则只显示指定硬盘 |
| `-u`        | 以扇区为单位显示分区大小（默认以柱面显示，扇区更精确）                               |
| `-s <分区>` | 显示指定分区的大小（单位：块，1 块 = 1024 字节），用于快速查询分区容量               |

*`fdisk` 的选项较少，主要用于非交互模式下的查询或特殊操作。*

最常用的就是 `fdisk -l` 来查看分区信息和 `fdisk <设备名>` 来进入交互模式对特定磁盘进行操作。​

其中 `fdisk -l` 输出的每一项信息都对应硬盘的关键属性：

```shell
Disk /dev/nvme0n2: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 641174E2-7FE8-48DD-B683-4196913BBF6C
```

第一部分：物理磁盘 `/dev/nvme0n2` 的整体信息：

| 输出内容                                                | 解释                                                                                                                                                            |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Disk /dev/nvme0n2`                                     | 磁盘设备文件名。NVMe 协议的磁盘命名规则与普通 SATA 硬盘（`sda`, `sdb`）不同，格式为 `nvme{控制器编号}n{命名空间编号}`。这里是第 0 个控制器上的第 2 个命名空间。 |
| `20 GiB, 21474836480 bytes`                             | 磁盘的​​总容量​​。以人类易读的单位（GiB）和精确的字节数两种方式显示。                                                                                           |
| `41943040 sectors`                                      | 磁盘总共有多少个​​扇区​​。容量 = 扇区数 * 扇区大小（512 字节）。                                                                                                |
| `Disk model: VMware Virtual NVMe Disk`                  | 磁盘的型号。这里显示它是一个 VMware 虚拟机中的虚拟 NVMe 磁盘。                                                                                                  |
| `Units: sectors of 1 * 512 = 512 bytes`                 | 说明下面分区列表中的数字单位是​​扇区​​，且每个扇区大小为 ​​512 字节​​。                                                                                         |
| `Sector size (logical/physical): 512 bytes / 512 bytes` | 逻辑扇区​​和​​物理扇区​​的大小。高级格式磁盘（4K 扇区）可能会在这里显示为 512 bytes / 4096 bytes。                                                              |
| `I/O size (minimum/optimal): 512 bytes / 512 bytes`     | 进行 I/O 操作时最小和最优的块大小。                                                                                                                             |
| `Disklabel type: gpt`                                   | ​​极其重要！​​这表示该磁盘使用的分区表类型是 ​​GPT​​，而不是传统的 ​​dos​​（即 MBR）。                                                                          |
| `Disk identifier: 641174E2-...`                         | 磁盘的​​唯一标识符​​。对于 GPT，这是一个全局唯一的 GUID；对于 MBR，则是一个随机的十六进制数。                                                                   |

```shell
Device           Start      End  Sectors Size Type
/dev/nvme0n2p1    2048     4095     2048   1M BIOS boot
/dev/nvme0n2p2    4096  2101247  2097152   1G Linux extended boot
/dev/nvme0n2p3 2101248 41940991 39839744  19G Linux LVM
```

第二部分：磁盘 `/dev/nvme0n2` 上的分区列表：

| 列名      | 解释                                                                                                                         |
| --------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `Device`  | 分区​​的设备文件名。NVMe 分区的命名规则是在磁盘名后加 `p{分区编号}`，例如 `nvme0n2p1`。对于 SATA 硬盘，则是 `sda1`, `sda2`。 |
| `Start`   | 该分区的​​起始扇区​​。分区总是从 2048 扇区（即 1MiB 的位置）开始，这是为了对齐 4K 扇区以获得最佳性能。                       |
| `End`     | 该分区的​​结束扇区​​。                                                                                                       |
| `Sectors` | 该分区总共包含的扇区数量。`End - Start + 1 = Sectors`。                                                                      |
| `Size`    | 该分区的​​容量​​，以人类易读的单位显示（K, M, G, T）。                                                                       |
| `Type`    | 分区的​​类型​​。这是在分区表中设置的一个标识，用于说明分区的用途。                                                           |

```shell
Disk /dev/mapper/rl-root: 17 GiB, 18249416704 bytes, 35643392 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/mapper/rl-swap: 2 GiB, 2147483648 bytes, 4194304 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
```

第三部分：LVM 逻辑卷信息，`fdisk -l` 会尝试列出系统中已知的​​逻辑卷​​，它们看起来像独立的磁盘设备：

| 输出内容                | 解释                                                                                                                                  |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `/dev/mapper/rl-root`   | ​​这是一个 LVM ​​逻辑卷​​的设备文件。rl 是卷组（Volume Group, VG）的名字，root 是逻辑卷（LV）的名字。它通常被挂载到系统的根目录 `/`。 |
| `​​/dev/mapper/rl-swap` | 这是另一个 LVM 逻辑卷，名为 swap。                                                                                                    |

通过解读 `fdisk -l` 的输出，可以清晰地看到这台机器的存储结构：

1. ​​物理磁盘​​：一块 20GB 的虚拟 NVMe 磁盘 (`/dev/nvme0n2`)，使用 ​​GPT​​ 分区表
2. ​​分区布局​​：
   1. p1: 1MB 的 BIOS 启动分区
   2. p2: 1GB 的 `/boot` 分区（ext4 文件系统）
   3. p3: 19GB 的 LVM 物理卷
3. ​​逻辑卷布局​​（建立在 p3 之上）：
   1. root: 17GB，用于根文件系统
   2. swap: 2GB，用于交换空间

> [!TIP] LVM 和 逻辑卷
> 逻辑卷（Logical Volume, LV）是 LVM（Logical Volume Manager，逻辑卷管理）架构中的核心组件之一。LVM 是 Linux 系统中用于灵活管理磁盘分区和存储空间的工具，它通过抽象物理存储设备、整合资源并动态分配空间，解决了传统分区（如 MBR/GPT 分区）大小固定、调整困难的问题，而逻辑卷正是 LVM 实现动态存储管理的关键载体。

**交互模式：**

`fdisk` 是一个用于创建和操作磁盘分区表的命令行工具。输入的 `fdisk /dev/nvme0n2` 表示要对名为 `nvme0n2` 的 NVMe 固态硬盘进行分区操作。进入交互模式后，所有输入的命令（如 `m`, `n`, `d` 等）都​​只是存储在内存中​​，并不会立即对磁盘做出实际改变。只有在最后输入 `w`(write) 命令后，所有的修改才会被一次性写入磁盘并生效。如果输入 `q`(quit)，则会退出程序且​​所有修改都会被丢弃​​。

```bash
fdisk /dev/nvme0n2
```

```console
Welcome to fdisk (util-linux 2.40.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

This disk is currently in use - repartitioning is probably a bad idea.
It's recommended to umount all file systems, and swapoff all swap
partitions on this disk.
```

其中 `This disk is currently……` 告警是 `fdisk` 工具发出的重要风险提示（非致命错误，但需高度重视），核心目的是警告：当前操作的硬盘（此处为 `/dev/nvme0n2`）正处于被使用状态，直接对其重新分区（repartitioning）可能导致数据损坏或系统异常。

`fdisk` 交互模式下输入 `m` 后显示的帮助菜单，包含了所有可用指令的分类说明：

```shell
Command (m for help): m

Help:

  GPT
   M   enter protective/hybrid MBR

  Generic
   d   delete a partition
   F   list free unpartitioned space
   l   list known partition types
   n   add a new partition
   p   print the partition table
   t   change a partition type
   v   verify the partition table
   i   print information about a partition
   e   resize a partition

  Misc
   m   print this menu
   x   extra functionality (experts only)

  Script
   I   load disk layout from sfdisk script file
   O   dump disk layout to sfdisk script file

  Save & Exit
   w   write table to disk and exit
   q   quit without saving changes

  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty MBR (DOS) partition table
   s   create a new empty Sun partition table

Command (m for help): 
```

GPT 相关指令：

| 指令 | 解释                                                                                          | 作用                                                                                                                                                                                                                                                           |
| ---- | --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `M`  | 进入「保护性 / 混合 MBR」模式（仅 GPT 分区表可用）。属于 GPT 专属指令，MBR 分区表下无此功能。 | 在 GPT 格式的硬盘上，创建一个兼容传统 MBR 规范的分区表（即混合 MBR），实现对 UEFI 和传统 BIOS 两种启动模式的兼容；仅用于老旧设备与新设备混合的特殊场景（如同一硬盘需在 UEFI 电脑和传统 BIOS 电脑间切换使用），日常分区（如服务器、个人电脑常规部署）极少用到。 |

通用指令：

| 指令 | 解释                                             | 作用与使用场景                                                                                                                                                                                                                                                     |
| ---- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `d`  | 删除一个分区，属于核心操作指令。                 | 输入后需指定要删除的分区编号（如 `d 1` 表示删除第 1 个分区）。注意：删除操作会直接清除分区数据且无法恢复，执行前务必确认分区编号和数据备份状态，避免误删系统分区或重要数据分区。                                                                                   |
| `F`  | 列出未分区的空闲空间，单位为扇区。               | 用于查看硬盘上剩余的可分配空间（如总空闲扇区数、起始 / 结束位置），帮助判断是否有足够空间创建新分区。例如，新增分区前执行 `F`，可确认剩余容量是否满足需求。                                                                                                        |
| `l`  | 列出已知的分区类型代码，包含各类系统的分区标识。 | 显示所有支持的分区类型及对应代码（如 `83` 对应 Linux 基本分区、`82` 对应 Linux swap 分区、`EF` 对应 EFI 系统分区）。修改分区类型（`t` 指令）时，需参考此列表中的代码指定类型。                                                                                     |
| `n`  | 添加一个新分区，是初始化硬盘的核心指令。         | 输入后按提示依次选择：分区类型（主分区 `p` 或扩展分区 `e`，仅 MBR 分区表需要）、分区编号（默认按顺序分配）、起始扇区（默认从第一个可用扇区开始，直接回车即可）、结束扇区（可指定大小如 `+10G` 或直接回车用满剩余空间）。适用于新硬盘首次分区或为已有硬盘新增分区。 |
| `p`  | 打印分区表，最常用的信息查询指令。               | 显示当前硬盘的完整分区信息，包括：分区编号、启动标志（Boot）、起始扇区（Start）、结束扇区（End）、总扇区数（Sectors）、容量（Size）、类型标识（Id）、分区类型（Type）。操作前后必用，用于确认分区状态（如新建分区是否成功、删除分区后是否生效）。                  |
| `t`  | 更改分区类型，需配合分区类型代码使用。           | 输入后先指定分区编号（如 `t 2` 表示修改第 2 个分区），再输入目标类型代码（参考 `l` 指令的列表）。例如：将分区改为 swap 类型时，输入代码 `82`；改为 EFI 系统分区时，输入代码 `EF`。适用于调整分区用途（如将普通分区转为 swap 分区）。                               |
| `v`  | 验证分区表，检查分区表的合法性。                 | 扫描分区表并检测潜在错误（如分区重叠、起始 / 结束扇区越界、容量计算异常等），输出验证结果（如 No errors found. 或具体错误提示）。操作完成后执行 `v`，可确认分区表是否规范，降低后续使用风险。                                                                      |
| `i`  | 打印指定分区的详细信息。                         | 输入后指定分区编号（如 `i 3` 表示查看第 3 个分区），显示该分区的详细参数：包括分区类型名称、UUID、起始 / 结束扇区（十进制和十六进制）、总扇区数、容量、是否激活等。适用于深入了解单个分区的属性。                                                                  |
| `e`  | 调整分区大小，支持扩展或缩小分区。               | 输入后指定分区编号，可修改分区的起始 / 结束扇区以调整容量。注意：此操作风险极高，可能导致文件系统损坏和数据丢失，且 `fdisk` 对分区调整的支持有限（不支持在线调整、不自动同步文件系统），建议优先使用 `parted` 或专门的分区调整工具（如 `resize2fs` 配合使用）。    |

杂项指令：

| 指令 | 解释                                                                   | 作用与使用场景                                                                                                                                                                                                             |
| ---- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `m`  | 打印帮助菜单，即当前显示的指令列表。                                   | 忘记指令功能时，输入 `m` 可随时调出所有指令的分类说明，适合新手查阅。例如，不确定 `n` 指令的用法时，输入 `m` 可快速查看其功能。                                                                                            |
| `x`  | 进入高级功能模式（Extra functionality for experts only），即专家模式。 | 提供扇区级别的低级操作（如修改分区起始扇区、调整柱面大小、编辑分区表校验值等），这些操作直接作用于硬盘底层数据结构，错误使用会导致分区表损坏、数据丢失甚至硬盘无法识别。新手严禁使用，仅适用于专业人员修复特殊分区表问题。 |

脚本指令：

| 指令 | 解释                                                                             | 作用与使用场景                                                                                                                                                                                 |
| ---- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `I`  | 从 `sfdisk` 脚本文件加载分区布局（Load disk layout from sfdisk script file）。   | 读取预先编写的 `sfdisk` 脚本（包含分区表定义），批量创建分区，无需手动交互。适用于自动化部署场景（如批量初始化多块硬盘，确保分区结构一致）。例如，通过脚本快速为 10 块硬盘创建相同的分区方案。 |
| `O`  | 将当前分区表导出为 `sfdisk` 脚本文件（Dump disk layout to sfdisk script file）。 | 将当前硬盘的分区表信息保存为 `sfdisk` 脚本（文本格式），用于备份分区布局或复制到其他硬盘。例如：将服务器的硬盘分区表导出为脚本，作为部署标准模板复用。                                         |

> [!TIP] sfdisk
> sfdisk 脚本文件（通常以 `.sfdisk` 为后缀，也可无后缀）是一种 文本格式的分区表配置文件，本质是把硬盘的分区布局（如分区表类型、分区数量、每个分区的大小、类型、起始 / 结束扇区等）用标准化的文本语法记录下来，用于 批量创建分区、备份 / 恢复分区表 或 自动化部署（避免手动重复操作）。

保存与退出指令：

| 指令 | 解释                                             | 作用与使用场景                                                                                                                                                                       |
| ---- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `w`  | 将分区表写入磁盘并退出，所有操作的最终确认步骤。 | 执行 `w` 后，之前在交互模式中进行的所有操作（创建 / 删除分区、修改分区类型等）会被永久写入硬盘分区表，系统同步后生效。注意，一旦执行 `w`，操作无法撤销，需在确认所有设置正确后使用。 |
| `q`  | 不保存更改并退出，操作的安全出口。               | 放弃所有未保存的操作（如误创建分区、选错硬盘），退出 fdisk 交互模式，硬盘分区表保持原样。适用于操作失误、不确定是否正确或临时查看分区信息的场景，是新手避免误操作的关键指令。        |

创建新分区表指令：

| 指令 | 解释                               | 作用与使用场景                                                                                                                                                                                                             |
| ---- | ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `g`  | 创建一个新的空 GPT 分区表。        | 初始化硬盘为 GPT 分区表格式（会清空原有分区表和所有数据），支持大容量硬盘（＞2TB）、最多 128 个主分区，原生兼容 UEFI 启动模式。适用于新购大容量硬盘（如 4TB 数据盘）、需要 UEFI 启动的系统盘或需划分多个分区的场景。       |
| `G`  | 创建一个新的空 SGI（IRIX）分区表。 | 初始化硬盘为 SGI 系统专用的分区表格式，仅用于旧版 IRIX 操作系统（SGI 工作站专用），现代 Linux 系统几乎不用，日常操作可忽略。                                                                                               |
| `o`  | 创建一个新的空 MBR（DOS）分区表。  | 初始化硬盘为 MBR 分区表格式（会清空原有分区表和所有数据），支持最大 2TB 硬盘、最多 4 个主分区（或 3 主 + 1 扩展分区），兼容传统 BIOS 启动模式。适用于小容量硬盘（≤2TB）、老旧设备或仅需少量分区的场景（如 500GB 系统盘）。 |
| `s`  | 创建一个新的空 Sun 分区表。        | 初始化硬盘为 Sun 操作系统专用的分区表格式，仅用于 Sun Solaris 系统，现代 Linux 环境中极少使用，日常操作可忽略。                                                                                                            |

**分区步骤：**

1. 确认目标硬盘设备名

   首先通过 `lsblk` 或 `fdisk -l` 查看硬盘设备名，避免误操作其他硬盘（使用 VMware 可以关机状态下添加新硬盘）：

   ```bash
   lsblk
   ```

   ```console
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   sr0          11:0    1  1.6G  0 rom  
   nvme0n1     259:0    0    5G  0 disk 
   nvme0n2     259:1    0   20G  0 disk 
   ├─nvme0n2p1 259:2    0    1M  0 part 
   ├─nvme0n2p2 259:3    0    1G  0 part /boot
   └─nvme0n2p3 259:4    0   19G  0 part 
   ├─rl-root 253:0    0   17G  0 lvm  /
   └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
   ```

   ```bash
   fdisk -l
   ```

   ```console
   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   ……
   ```

   可以从 `lsblk` 和 `fdisk -l` 的输出中能清晰识别到新添加的硬盘是 `/dev/nvme0n1`（容量 5G，无任何分区，状态为 `disk`，无挂载点和子分区），而原有系统盘是 `nvme0n2`（已分区并挂载了 `/boot`、`/` 和 `swap`），接下来就可以针对 `nvme0n1` 进行分区操作了。

2. 进入 `fdisk` 交互模式

   执行命令时务必指定新硬盘 `nvme0n1`，避免误操作系统盘 `nvme0n2`：

   ```bash
   fdisk /dev/nvme0n1
   ```

   进入后会看到提示符 `Command (m for help):`，表示已进入交互模式。先输入 `p` 打印分区表，确认 `nvme0n1` 是空白硬盘（无任何分区列表）：

   ```bash
   fdisk /dev/nvme0n1
   ```

   ```console
   Welcome to fdisk (util-linux 2.40.2).
   Changes will remain in memory only, until you decide to write them.
   Be careful before using the write command.

   Device does not contain a recognized partition table.
   Created a new DOS (MBR) disklabel with disk identifier 0x7d6e7fc8.

   Command (m for help): p
   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: dos
   Disk identifier: 0x7d6e7fc8
   ```

3. 创建 MBR 分区表（若硬盘无分区表）

   硬盘要使用，必须先有分区表，它相当于硬盘的目录索引，记录了硬盘上有多少个分区、每个分区的位置（起始 / 结束扇区）、分区类型等关键信息。而分区（用 `n` 创建）是在分区表这个容器里划分的子空间，没有分区表，就没有地方记录分区的信息，自然无法创建分区。

   但是在之前 `fdisk` 输出中：

   ```shell
   Device does not contain a recognized partition table.
   Created a new DOS (MBR) disklabel with disk identifier 0x7d6e7fc8.
   ```

   这里的 `DOS (MBR) disklabel` 就是 MBR 分区表。`fdisk` 的默认规则是：如果检测到硬盘没有可识别的分区表，会自动创建一个 MBR 分区表（这是传统且兼容性广的分区表类型）。所以对于这个场景来说，不需要再手动输 `o` 创建分区表，直接输 `n` 新建分区即可。

   如果硬盘之前用过，有 MBR/GPT 分区表（甚至残留分区记录），但现在需要彻底格式化重新分区，此时就可以输入 `o` 强制覆盖旧的分区表，创建一个全新的空 MBR 分区表，避免旧分区表干扰新操作（比如旧分区记录导致新分区无法创建）。

4. 新建分区

   输入 `n` 开始新建分区，首先会看到分区类型选择界面：

   ```shell{1}
   Command (m for help): n
   Partition type
      p   primary (0 primary, 0 extended, 4 free)
      e   extended (container for logical partitions)
   ```

   这是 MBR 分区表特有的规则，核心限制是，MBR 分区表最多支持 4 个主分区，或 3 个主分区 + 1 个扩展分区（扩展分区内可创建多个逻辑分区，突破 4 个分区的限制）。

   | 分区类型        | 含义与特点                                                                                                                            | 适用场景                                                                          |
   | --------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
   | `p`（主分区）   | 可直接格式化并挂载使用；MBR 表中最多创建 4 个；可设置为活动分区（用于引导系统）。                                                     | 分区数量 ≤4 时；需要作为系统引导分区（如 `/boot` 分区）。                         |
   | `e`（扩展分区） | 本身不能直接使用（需在内部创建逻辑分区）；MBR 表中最多创建 1 个；相当于「容器」，可容纳多个逻辑分区（无数量限制，仅受硬盘容量影响）。 | 分区数量 ＞4 时，如需要 5 个及以上分区，先建 1 个扩展分区，再在里面分逻辑分区）。 |

   MBR 表当前 0 主分区、0 扩展分区、4 个空闲名额（`0 primary, 0 extended, 4 free`），因此直接选择 `p`（主分区） 即可，无需创建扩展分区：

   ```shell{1,2,3,4}
   Select (default p): p
   Partition number (1-4, default 1): 1
   First sector (2048-10485759, default 2048): 
   Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-10485759, default 10485759): +1G

   Created a new partition 1 of type 'Linux' and of size 1 GiB.
   ```

   选择 p 后，`fdisk` 会继续提示以下 3 个关键参数配置：

   - 选择分区编号（Partition number）：MBR 主分区编号范围是 `1-4`，`default 1` 表示默认创建第 1 个主分区，首次创建分区时，通常按默认即可
   - 选择起始扇区（First sector）：硬盘的最小存储单位是扇区，默认从 `2048` 开始（跳过前 2047 扇区，避免覆盖分区表信息），直接回车即可
   - 选择结束扇区（Last sector）：决定分区大小（分区容量 = 结束扇区 - 起始扇区 + 1 ，再乘以每扇区字节数），可直接输入容量（如 `+1G` 表示 1GB，`+500M` 表示 500MB，`+2K` 表示 2KB），如果直接回车，会使用 `default 10485759`，即把硬盘剩余的所有空间（5GB）都分配给当前分区。

5. 查看分区

   再次输入 `p` 查看分区表，确认新分区 `nvme0n1p1` 已创建：

   ```shell{1}
   Command (m for help): p

   Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: dos
   Disk identifier: 0x7d6e7fc8

   Device         Boot Start     End Sectors Size Id Type
   /dev/nvme0n1p1       2048 2099199 2097152   1G 83 Linux
   ```

   输出会新增以下分区记录，说明分区成功：

   ```shell
   Device         Boot Start     End Sectors Size Id Type
   /dev/nvme0n1p1       2048 2099199 2097152   1G 83 Linux
   ```

6. 保存分区

   最后输入 `w` 保存所有操作，这一步才会真正将分区表写入硬盘，未执行 `w` 前所有操作都是临时的：

   ```shell{1}
   Command (m for help): w
   The partition table has been altered.
   Calling ioctl() to re-read partition table.
   Syncing disks.
   ```

   - `The partition table has been altered.`：确认分区表已被成功修改（内存中的配置已写入硬盘）
   - `Calling ioctl() to re-read partition table.`：系统自动调用 `ioctl` 接口，通知内核重新读取硬盘分区表，使新分区立即被系统识别（无需重启）。极少数情况下，内核可能无法实时刷新分区表，此时需执行 `partprobe /dev/nvme0n1` 手动刷新，或重启系统
   - `Syncing disks.`：执行磁盘同步操作，将缓存中的数据强制写入硬盘物理介质，避免因意外断电导致分区表写入不完整

7. 查看新分区是否被系统识别

   退出 `fdisk` 后，用 `lsblk` 查看新分区是否被系统识别：

   ```bash
   lsblk
   ```

   ```console{3,4}
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   sr0          11:0    1  1.6G  0 rom  
   nvme0n1     259:0    0    5G  0 disk 
   └─nvme0n1p1 259:5    0    1G  0 part
   nvme0n2     259:1    0   20G  0 disk 
   ├─nvme0n2p1 259:2    0    1M  0 part 
   ├─nvme0n2p2 259:3    0    1G  0 part /boot
   └─nvme0n2p3 259:4    0   19G  0 part 
   ├─rl-root 253:0    0   17G  0 lvm  /
   └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
   ```

   输出会显示新分区 `nvme0n1p1`，说明系统已识别。到这里，新硬盘的分区步骤就完成了。

剩余的 4G 空间继续分区的步骤和第一次完全相同，因为 MBR 分区表支持最多 4 个主分区，当前只创建了 1 个（`nvme0n1p1`），还有 3 个主分区的名额可以使用。

```bash
fdisk /dev/nvme0n1
```

```console{5,9-12,16,29}
Welcome to fdisk (util-linux 2.40.2).
Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type
   p   primary (1 primary, 0 extended, 3 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2-4, default 2): 2
First sector (2099200-10485759, default 2099200): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2099200-10485759, default 10485759): 

Created a new partition 2 of type 'Linux' and of size 4 GiB.

Command (m for help): p
Disk /dev/nvme0n1: 5 GiB, 5368709120 bytes, 10485760 sectors
Disk model: VMware Virtual NVMe Disk
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x7d6e7fc8

Device         Boot   Start      End Sectors Size Id Type
/dev/nvme0n1p1         2048  2099199 2097152   1G 83 Linux
/dev/nvme0n1p2      2099200 10485759 8386560   4G 83 Linux

Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

```bash
lsblk | grep "nvme0n1"
```

```console
nvme0n1     259:0    0    5G  0 disk 
├─nvme0n1p1 259:5    0    1G  0 part 
└─nvme0n1p2 259:8    0    4G  0 part 
```

接下来需要对 `nvme0n1p1`、`nvme0n1p2` 进行格式化（创建文件系统）和挂载，才能真正用于存储数据。

### gdisk

`gdisk` 是一个功能强大的命令行工具，主要用于在 Linux 系统上创建和管理 ​​GPT (GUID Partition Table)​​ 分区表。它是传统 `fdisk` 工具的现代替代品，特别适用于处理大容量硬盘（超过 2TB）和需要更多分区（超过 4 个主分区）的场景。

​​核心功能与特点：​​

- ​GPT 分区表管理：​​ 这是 `gdisk` 最主要的目的。GPT 是 UEFI 固件标准的一部分，取代了老旧的 MBR 分区方案。支持创建、删除、修改分区、更改分区类型 GUID、调整分区大小（需结合文件系统工具）、设置分区名称、检查分区表完整性等。支持超过 2TB 的磁盘，理论上分区数量几乎没有限制（标准是 128 个），具有更健壮的冗余和校验机制，分区表存储在磁盘的头部和尾部以提高安全性
- ​​MBR 兼容性处理：​​可以在 MBR 磁盘上安全地运行 `gdisk` 来查看信息。可以将 MBR 磁盘转换为 GPT 磁盘（使用 `gdisk` 并输入 `w` 写入时会自动进行转换，需谨慎，可能导致数据丢失）
- ​修复与恢复：​​ 提供命令尝试修复损坏的 GPT 分区表（利用备份头）。

> [!NOTE]
> 在 ​​Rocky Linux 10​​ 中，默认仓库通常不包含 `gdisk`（属于 `gptfdisk` 包）。需要先启用 ​​EPEL 仓库​​，然后安装 `gdisk`。

```shell
gdisk [选项] <设备名>
```

| 常见选项    | 作用                             |
| ----------- | -------------------------------- |
| `-l`        | 查看指定磁盘的分区表信息（只读） |
| `-b <文件>` | 备份分区表到文件                 |
| `-r <文件>` | 从备份文件恢复分区表             |

**交互模式：**

与 `fdisk` 类似，运行 `gdisk` 也会进入一个交互式命令行环境，用户输入单字母命令进行操作。运行 `gdisk` 进入交互模式后，可通过以下菜单命令操作分区表，分为主菜单、恢复与转换菜单、专家菜单三类。

主菜单（常用基础功能）：

| 指令 | 解释                                        | 作用与使用场景                                                                                                                                                                                                        |
| ---- | ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `o`  | 创建新的空白 GPT 分区表，属于初始化核心指令 | 输入后需确认（Y/N），执行后会清除磁盘上所有现有分区数据，适用于新磁盘首次分区、彻底重新规划磁盘分区的场景，操作前务必提前备份数据                                                                                     |
| `n`  | 新建分区，属于分区创建核心指令              | 输入后需依次指定分区号（默认按顺序递增）、起始扇区（默认 2048，推荐保持默认以确保扇区对齐）、结束扇区（可直接输入大小，如 +100G，也可输入具体扇区数）、分区类型代码（默认 8300，即 Linux 文件系统），完成后生成新分区 |
| `d`  | 删除已有分区，属于分区删除核心指令          | 输入后需指定要删除的分区编号（如输入 1 即删除第 1 个分区），删除操作不可逆，会直接清除对应分区的数据，执行前需反复确认分区编号无误，且已备份分区内重要数据                                                            |
| `p’` | 打印当前分区表信息，属于查询类指令          | 执行后会显示磁盘的所有分区详情，包括分区编号、起始扇区、结束扇区、分区大小、分区类型代码、分区名称等，可用于确认分区配置结果、查看现有分区布局                                                                        |
| `t`  | 修改分区类型代码，属于分区配置类指令        | 输入后需先指定目标分区编号，再输入目标分区类型代码（如 EF00 对应 EFI 系统分区、8200 对应 Linux 交换分区），完成后更新分区的用途标识，匹配不同系统或功能需求                                                           |
| `c`  | 修改分区名称，属于分区标识配置指令          | 输入后需指定目标分区编号，再输入自定义的分区名称（如 `root-partition`，`data-partition`），GPT 分区表支持该功能，可通过名称快速区分不同分区的用途，方便管理                                                           |
| `w`  | 保存所有修改并写入磁盘，属于确认生效指令    | 输入后需确认（Y/N），执行后所有未保存的操作（如新建、删除、修改分区等）将实际写入磁盘，操作不可逆，需确保所有配置无误后再执行，避免错误修改生效                                                                       |
| `q`  | 放弃所有修改并退出，属于取消操作指令        | 执行后直接退出 gdisk 工具，所有未通过 w 指令保存的操作（如新建的分区、删除的分区记录）将被完全丢弃，适用于操作失误、临时取消分区计划的场景                                                                            |
| `r`  | 切换至恢复与转换菜单，属于菜单切换指令      | 输入后从主菜单进入恢复与转换子菜单，可使用分区表备份、恢复、格式转换等专项功能，需根据具体需求在子菜单中选择对应指令                                                                                                  |
| `x`  | 切换至专家菜单，属于高级功能菜单切换指令    | 输入后从主菜单进入专家子菜单，可使用扇区对齐调整、分区类型列表查看、分区表销毁等高级功能，仅推荐高级用户在明确需求时使用，避免误操作影响磁盘数据                                                                      |

恢复与转换菜单指令表（需先输入 `r` 进入）：

| 指令 | 解释                                                   | 作用与使用场景                                                                                                                                                                                                      |
| ---- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `b`  | 备份分区表到文件，属于分区表安全备份指令               | 输入后需指定备份文件名（如 `gpt-backup.bin`），工具会将当前磁盘的分区表信息完整保存到指定文件中，可用于灾难恢复（如后续分区表损坏时，可通过该备份文件恢复），建议在分区表配置完成后执行该操作                       |
| `l`  | 从备份文件恢复分区表，属于分区表恢复指令               | 输入后需指定备份文件路径（如 `./gpt-backup.bin`），工具会读取备份文件中的分区表信息，并覆盖当前磁盘的分区表，操作前需确认备份文件来源可靠、与目标磁盘匹配，且已备份当前磁盘的重要数据                               |
| `g`  | 将 MBR 分区表转换为 GPT 分区表，属于分区表格式转换指令 | 输入后工具会尝试保留原有 MBR 磁盘的分区数据，将分区表格式转换为 GPT（支持超过 4 个主分区、大容量磁盘），转换前需备份所有分区数据，避免因兼容问题导致数据丢失，适用于老旧 MBR 磁盘需支持 UEFI 启动或大容量分区的场景 |
| `m`  | 将 GPT 分区表转换为 MBR 分区表，属于分区表格式转换指令 | 输入后工具会尝试保留原有 GPT 磁盘的分区数据，转换为 MBR 格式（仅支持最多 4 个主分区），转换过程中若 GPT 分区数量超过 4 个，多余分区会丢失，需提前整理分区结构并备份数据，适用于需兼容传统 BIOS 启动的场景           |
| `o`  | 验证分区表完整性，属于分区表检测指令                   | 执行后工具会检查当前分区表是否存在错误（如分区重叠、扇区范围异常、类型代码不合法等），并输出检测结果，可用于排查分区表异常导致的磁盘识别问题                                                                        |
| `p`  | 返回主菜单，属于菜单切换指令                           | 输入后从恢复与转换菜单回到主菜单，可继续执行主菜单的常规分区操作（如新建、删除分区）                                                                                                                                |

专家菜单指令表（需先输入 `x` 进入）:

| 指令 | 解释                                       | 作用与使用场景                                                                                                                                                                                          |
| ---- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `z`  | 彻底销毁分区表并退出，属于危险操作指令     | 输入后需多次确认，执行后会清除磁盘的所有分区信息、擦除 GPT 签名，且不可逆，会导致磁盘变为未初始化状态，仅适用于彻底销毁磁盘分区痕迹的场景（如丢弃磁盘前清除数据标识），操作前需确保磁盘内无任何重要数据 |
| `e`  | 调整分区表的扇区对齐方式，属于高级优化指令 | 输入后可手动指定分区的起始扇区对齐值，默认对齐值已适配多数存储设备（如 SSD、HDD），一般无需修改；仅当存储设备有特殊对齐要求（如老旧设备、特殊硬件环境）时，由高级用户根据设备参数调整，优化磁盘读写性能 |
| `l`  | 列出所有支持的分区类型代码，属于查询类指令 | 执行后会显示 `gdisk` 支持的所有分区类型及其对应的十六进制代码（如 `EF00=EFI` 系统分区、`8300=Linux` 文件系统、`fd00=Linux RAID` 分区），可用于查询罕见分区类型代码，辅助正确配置分区用途                |
| `m`  | 显示专家菜单帮助信息，属于辅助查询指令     | 执行后会列出专家菜单的所有指令及简要说明，帮助用户了解各指令功能，适用于首次使用专家菜单、忘记指令作用时                                                                                                |
| `p`  | 返回主菜单，属于菜单切换指令               | 输入后从专家菜单回到主菜单，可切换至常规分区操作，避免在专家菜单中误执行高级指令                                                                                                                        |
| `v`  | 验证分区数据完整性，属于深度检测指令       | 执行后会比恢复菜单的 o 指令更细致地检查分区表（如分区与文件系统的兼容性、扇区分配合理性），输出详细检测报告，可用于排查复杂的分区表异常问题（如分区无法挂载、数据读写错误）                             |

**分区步骤：**

同样，在分区时候首先要使用 `lsblk` 或 `fdisk -l` 找到新硬盘的设备标识，避免误操作现有磁盘：

```bash
lsblk
```

```console
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0          11:0    1  1.6G  0 rom  
nvme0n1     259:0    0   20G  0 disk 
├─nvme0n1p1 259:4    0    1M  0 part 
├─nvme0n1p2 259:5    0    1G  0 part /boot
└─nvme0n1p3 259:6    0   19G  0 part 
  ├─rl-root 253:0    0   17G  0 lvm  /
  └─rl-swap 253:1    0    2G  0 lvm  [SWAP]
nvme0n2     259:1    0    5G  0 disk 
├─nvme0n2p1 259:2    0    1G  0 part 
└─nvme0n2p2 259:3    0    4G  0 part 
nvme0n3     259:7    0    3G  0 disk 
```

> [!NOTE]
> 在虚拟机中添加硬盘后设备名变化是正常现象，当新增硬盘时，新硬盘可能被识别为控制器的第一个命名空间，原有硬盘因控制器或命名空间顺序调整，编号被挤到后续位置。

1. 进入交互模式

   ```bash
   gdisk /dev/nvme0n3
   ```

   ```console
   GPT fdisk (gdisk) version 1.0.10

   Partition table scan:
   MBR: not present
   BSD: not present
   APM: not present
   GPT: not present

   Creating new GPT entries in memory.

   Command (? for help): 
   ```

   这段信息表示 `gdisk` 在扫描 `/dev/nvme0n3` 磁盘时，没有检测到任何类型的分区表：

   - `MBR: not present`：未检测到 MBR 分区表（传统的主引导记录分区表，支持最大 2TB 磁盘，最多 4 个主分区）。
   - `BSD: not present`：未检测到 BSD 分区表（伯克利软件分发系统的分区格式，主要用于类 Unix 系统）。
   - `APM: not present`：未检测到 APM 分区表（苹果分区图，早期苹果设备使用的分区格式）。
   - `GPT: not present`：未检测到 GPT 分区表（GUID 分区表，现代主流格式，支持大容量磁盘和超过 4 个主分区）。

   表明 `/dev/nvme0n3` 磁盘目前是未初始化状态，没有任何分区表结构，既然没有分区表，那么下一步需要先创建 GPT 分区表，再新建分区，具体步骤。

2. 创建 GPT 分区表

   ```shell{1,3}
   Command (? for help): o
   This option deletes all partitions and creates a new protective MBR.
   Proceed? (Y/N): y
   ```

   这个提示的意思是 `o` 命令会删除当前磁盘上所有已有的分区，由于 `/dev/nvme0n3` 原本就没有分区表，实际操作是创建全新的空白 GPT 分区表，并自动生成一个保护性 MBR（防止不支持 GPT 的旧系统误识别磁盘）。

3. 创建分区

   按提示指定分区号、起始扇区、分区大小和分区类型：

   ```shell{1,2,3,4,6}
   Command (? for help): n
   Partition number (1-128, default 1): 1
   First sector (34-6291422, default = 2048) or {+-}size{KMGTP}: 
   Last sector (2048-6291422, default = 6289407) or {+-}size{KMGTP}: +1G
   Current type is 8300 (Linux filesystem)
   Hex code or GUID (L to show codes, Enter = 8300): 
   Changed type of partition to 'Linux filesystem'
   ```

4. 查看分区表

   ```shell{1}
   Command (? for help): p
   Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB
   Model: VMware Virtual NVMe Disk
   Sector size (logical/physical): 512/512 bytes
   Disk identifier (GUID): 92258B1B-BF41-4914-8681-E8288E0EC0DC
   Partition table holds up to 128 entries
   Main partition table begins at sector 2 and ends at sector 33
   First usable sector is 34, last usable sector is 6291422
   Partitions will be aligned on 2048-sector boundaries
   Total free space is 4194237 sectors (2.0 GiB)

   Number  Start (sector)    End (sector)  Size       Code  Name
      1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   ```

   从 `p` 命令的输出结果来看，已经成功创建了一个分区，当前分区表状态清晰且正确，各个字段含义如下。

   磁盘基本信息：

   - `Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB`：目标磁盘是 `/dev/nvme0n3`，总扇区数 6291456，总容量 3.0 GiB
   - `Model: VMware Virtual NVMe Disk`：磁盘类型为 VMware 虚拟 NVMe 磁盘
   - `Sector size (logical/physical): 512/512 bytes`：逻辑 / 物理扇区大小均为 512 字节（标准配置）
   - `Disk identifier (GUID): ...`：GPT 分区表的唯一标识符（自动生成，无需关注）

   分区表配置信息：

   - `Partition table holds up to 128 entries`：GPT 分区表最多支持 128 个分区
   - `Main partition table begins at sector 2 and ends at sector 33`：GPT 主分区表存储在扇区 2-33（系统预留，不影响用户分区）
   - `First usable sector is 34, last usable sector is 6291422`：用户可用扇区范围（34 到 6291422），分区必须在这个范围内创建
   - `Partitions will be aligned on 2048-sector boundaries`：分区已按 2048 扇区对齐（即 1MB 对齐，符合 SSD/NVMe 性能优化要求）
   - `Total free space is 4194237 sectors (2.0 GiB)`：磁盘剩余可用空间为 2.0 GiB（可继续创建新分区）

   已创建的分区信息：

   | 编号（Number） | 起始扇区（Start） | 结束扇区（End） | 大小（Size） | 类型代码（Code） | 名称（Name）     |
   | -------------- | ----------------- | --------------- | ------------ | ---------------- | ---------------- |
   | 1              | 2048              | 2099199         | 1024.0 MiB   | 8300             | Linux filesystem |

5. 保存分区

   同样输入 `w` 保存所有操作：

   ```shell{1}
   Command (? for help): w

   Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
   PARTITIONS!!

   Do you want to proceed? (Y/N): 
   ```

   这个提示是 `gdisk` 在执行 最终写入操作前的最后确认，核心含义是：一旦确认，当前在内存中配置的分区表将被 永久写入 `/dev/nvme0n3` 磁盘，覆盖磁盘上原有的所有分区信息。

   ```shell{1}
   Do you want to proceed? (Y/N): y
   OK; writing new GUID partition table (GPT) to /dev/nvme0n3.
   The operation has completed successfully.
   ```

6. 确认分区是否生效

   保存后可以通过 `lsblk`、`fdisk` 和 `gdisk` 命令查看分区是否生效：

   ```bash
   lsblk | grep nvme0n3
   ```

   ```console
   nvme0n3     259:7    0    3G  0 disk 
   └─nvme0n3p1 259:9    0    1G  0 part 
   ```

   ```bash
   fdisk -l /dev/nvme0n3
   ```

   ```console
   Disk /dev/nvme0n3: 3 GiB, 3221225472 bytes, 6291456 sectors
   Disk model: VMware Virtual NVMe Disk
   Units: sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disklabel type: gpt
   Disk identifier: 92258B1B-BF41-4914-8681-E8288E0EC0DC

   Device         Start     End Sectors Size Type
   /dev/nvme0n3p1  2048 2099199 2097152   1G Linux filesystem
   ```

   ```bash
   gdisk /dev/nvme0n3
   ```

   ```console{11}
   GPT fdisk (gdisk) version 1.0.10

   Partition table scan:
   MBR: protective
   BSD: not present
   APM: not present
   GPT: present

   Found valid GPT with protective MBR; using GPT.

   Command (? for help): p
   Disk /dev/nvme0n3: 6291456 sectors, 3.0 GiB
   Model: VMware Virtual NVMe Disk
   Sector size (logical/physical): 512/512 bytes
   Disk identifier (GUID): 92258B1B-BF41-4914-8681-E8288E0EC0DC
   Partition table holds up to 128 entries
   Main partition table begins at sector 2 and ends at sector 33
   First usable sector is 34, last usable sector is 6291422
   Partitions will be aligned on 2048-sector boundaries
   Total free space is 4194237 sectors (2.0 GiB)

   Number  Start (sector)    End (sector)  Size       Code  Name
      1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   ```

### parted

parted 是一款功能强大的磁盘分区管理工具，支持 MBR 和 GPT 分区表，可处理大容量磁盘（超过 2TB），并提供分区创建、调整、删除等完整功能。与 `gdisk` 专注于 GPT 不同，`parted` 更灵活，支持交互式操作和非交互式命令行操作，适合快速分区和高级调整。

```shell
parted [OPTION]... [DEVICE [COMMAND [PARAMETERS]...]...]
```

`parted` 有两种使用模式，语法略有差异：

- **交互模式**：进入交互式界面，逐条输入命令，适合分步操作。若不指定 COMMAND，则进入交互模式（逐条输入命令）
- **非交互模式**：直接在命令行一次性指定所有操作。若指定 DEVICE（如 `/dev/nvme0n3`）和 COMMAND（如 `mkpart`），则直接执行对应操作

**交互模式：**

和 `fdisk`、`gdisk` 磁盘分区管理工具一样，`parted` 也支持交互式操作，即在终端中输入命令，然后按下回车键执行。

```bash
parted
```

```console
GNU Parted 3.6
Using /dev/nvme0n1
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted)  
```

> [!WARNING]
> 直接运行 `parted` 命令而不指定设备时，它会​​自动选择系统中第一个可用的块设备​​作为默认操作对象。所以在使用 `parted` 时明确指定目标设备​​，避免误操作其他磁盘。

指定新的硬盘进入交互模式下，在 `parted` 交互模式下输入 `h` 或 `help` 会显示所有命令的简要帮助：

```bash
parted /dev/nvme0n4
```

```console{4}
GNU Parted 3.6
Using /dev/nvme0n4
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) h                                                                
  align-check TYPE N                       check partition N for
        TYPE(min|opt) alignment
  help [COMMAND]                           print general help, or help on
        COMMAND
  mklabel,mktable LABEL-TYPE               create a new disklabel
        (partition table)
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
  name NUMBER NAME                         name partition NUMBER as NAME
  print [devices|free|list,all]            display the partition table, or
        available devices, or free space, or all found partitions
  quit                                     exit program
  rescue START END                         rescue a lost partition near
        START and END
  resizepart NUMBER END                    resize partition NUMBER
  rm NUMBER                                delete partition NUMBER
  select DEVICE                            choose the device to edit
  disk_set FLAG STATE                      change the FLAG on selected
        device
  disk_toggle [FLAG]                       toggle the state of FLAG on
        selected device
  set NUMBER FLAG STATE                    change the FLAG on partition
        NUMBER
  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on
        partition NUMBER
  type NUMBER TYPE-ID or TYPE-UUID         type set TYPE-ID or TYPE-UUID of
        partition NUMBER
  unit UNIT                                set the default unit to UNIT
  version                                  display the version number and
        copyright information of GNU Parted
```

在 `parted` 交互模式下（即进入 `(parted)` 提示符后），所有命令均直接输入执行，无需额外格式。

基础帮助与退出命令：

|命令语法|功能说明|
|-|-|
|`help`,`h`|显示所有命令的简要帮助|
|`help [命令]` 或 `h [命令]`|显示指定命令的详细用法（如 `mkpart`、`rm` 等）|
|`quit`,`q`|退出交互模式，注意 `parted` 所有操作已即时生效，无需保存|
|version|显示 `parted` 版本及版权信息|

设备选择与切换命令：

|命令语法|功能说明|
|-|-|
|`select [设备路径]`|切换当前操作的磁盘，若启动 `parted` 时未指定设备，需先用此命令选择|

分区表操作命令：

|命令语法|功能说明|
|-|-|
|`mklabel [分区表类型]`,`mktable [分区表类型]`|创建新分区表，会彻底清除磁盘所有现有分区。支持类型：gpt，msdos|

分区创建与修改命令（核心功能）：

|命令语法|功能说明|
|-|-|
|`mkpart [分区类型] [文件系统标识] [起始位置] [结束位置]`|创建新分区/分区类型：primary（主分区）、logical（逻辑分区，仅 MBR 支持），GPT 可省略；文件系统标识：如 ext4、xfs（仅标记用途，不实际格式化）；起始/结束位置：必须带单位（MB/GB 等，如 1MB、1024MB）|
|`resizepart [分区编号] [新结束位置]`|调整已有分区的大小，需先卸载分区，仅扩展 / 缩小分区容器，需后续同步文件系统|
|`rm [分区编号]`|删除指定编号的分区，即时生效，数据不可恢复，务必确认编号正确|
|`rescue [起始位置] [结束位置]`|尝试恢复位于起始位置和结束位置之间的丢失分区，用于找回误删分区|

分区信息查询与验证命令：

|命令语法|功能说明|
|-|-|
|print|显示当前磁盘的分区表信息，分区编号、大小、类型等|
|`print [设备路径]`|显示指定磁盘的分区信息，无需切换设备|
|`print free`|显示磁盘的空闲空间，未分配的区域，便于规划分区|
|`print devices`|列出系统中所有可用的磁盘设备，如 `/dev/nvme0n1`、`/dev/sdb` 等|
|`align-check [对齐类型] [分区编号]`|检查分区的对齐状态：`min` 最小对齐，兼容旧设备；`opt` 最优对齐，SSD/NVMe 推荐|
|`unit [单位]`|设置后续输出的默认单位，如 `MB/GB/s`|

分区属性与标识设置命令：

|命令语法|功能说明|
|-|-|
|`name [分区编号] [名称]`|为分区设置名称，仅 GPT 分区表支持，方便识别用途|
|`set [分区编号] [标志] [on/off]`|为分区设置 / 取消特殊标志，控制分区功能，常用标志：`boot` 启动分区；`esp：EFI` 系统分区，UEFI 启动必需；`lvm` LVM 物理卷分区；`swap` 交换分区|
|`type [分区编号] [类型ID/UUID]`|设置分区的类型，GPT 特有，通过类型 ID 或 UUID 标识。常用类型 ID：`8300` Linux 文件系统；`8200` Linux 交换分区；`EF00` EFI 系统分区|
|`toggle [分区编号] [标志]`|切换分区标志的状态，`on` 变 `off`，`off` 变 `on`，等价于 `set` 命令的反向操作|

磁盘级属性设置命令：

|命令语法|功能说明|
|-|-|
|`disk_set [标志] [on/off]`|设置当前磁盘的全局标志，如 GPT 兼容 MBR 的 `pmbr_boot` 标志|
|`disk_toggle [标志]`|切换磁盘标志的状态，`on` 变 `off`，`off` 变 `on`|

**分区步骤：**

进入交互模式下创建分区：

```bash
parted /dev/nvme0n4
```

```console {4}
GNU Parted 3.6
Using /dev/nvme0n4
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) p                                                                
Error: /dev/nvme0n4: unrecognised disk label
Model: VMware Virtual NVMe Disk (nvme)                                    
Disk /dev/nvme0n4: 2147MB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags: 
(parted)   
```

提示 `Error: /dev/nvme0n4: unrecognised disk label` 表示 `/dev/nvme0n4` 磁盘尚未创建任何分区表（分区表类型为 unknown），这是新磁盘或被清除过分区表的典型状态。此时需要先创建分区表，才能继续分区操作。

1. 创建 GPT 分区表（初始化磁盘）

   ```shell{1,2}
   (parted) mklabel gpt
   (parted) p                                                            
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End  Size  File system  Name  Flags
   ```

   可以看到分区表类型(Partition Table)变为 `gpt`。

2. 创建分区

   创建分区需要指定名称、文件系统标识、起始位置和结束位置：

   ```shell
   (parted) mkpart
   Partition name?  []?
   File system type?  [ext2]? xfs
   Start? 2048s
   End? 1G
   ```

   名称留空，使用默认即可；文件系统标识可以选择 xfs。

   > [!NOTE] 文件系统标识
   > 文件系统标识只是**标识、标记**，​​不会实际格式化分区。在分区表中记录类型不会执行任何格式化操作​，后续需要使用专门的格式化命令。

   起始位置选择直接用 **扇区(s)** 作为单位，指定起始扇区为 `2048s`；结束位置使用 `1G`。

   > [!WARNING]
   > 如果出现告警 `Warning: The resulting partition is not properly aligned for bestperformance: 1953s % 2048s != 0s`，这个警告提示 **分区起始位置未按最优方式对齐**，可能影响磁盘性能（尤其是 SSD/NVMe）。
   >
   > 这可能是指定的起始位置 `1M` 被转换为扇区后是 1953 扇区。`parted` 默认用十进制容量（1M = 1000×1000 字节）换算扇区，而非二进制容量（1M = 1024×1024 字节），两者的换算结果差异直接导致起始扇区不对齐。导致 1953 不是 2048（最优对齐扇区数）的整数倍，导致对齐失败。
   >
   > 部分场景下 `1M` 看似对齐（如结束位置为 `1026M` 时），是 `parted` 因容量冗余自动将起始修正为 `2048s`，但该修正不稳定（若结束位置卡紧如 `1025M`，会恢复为 `1953s`），属于碰运气，不推荐依赖。
   >
   > 推荐用 MiB 或 GiB（二进制单位）换算扇区最可靠：1MiB=2048 扇区（正好是对齐单位的整数倍），能确保起始 / 结束扇区天然对齐，后续分区也能无缝衔接，彻底避开十进制单位（M/G）的换算偏差。

   创建后，用 `align-check` 命令确认对齐：

   ```shell
   (parted) align-check opt 1
   ```

   ```console
   1 aligned
   ```

   - `align-check`：核心命令，功能是检查分区的对齐方式
   - `opt`：参数，是 optimal 的缩写，表示检查是否满足最优对齐，针对 SSD/NVMe 等现代存储设备，最优对齐通常指起始扇区是 2048 的整数倍
   - `1`：参数，指定要检查的分区编号

   执行后返回的 `1 aligned` 表示：编号为 1 的分区（即 `nvme0n3p1`）满足最优对齐要求，无需调整，不会因对齐问题影响磁盘性能（尤其是随机读写速度）。

   ::: details 扩展方案：用百分比（%）设置分区（适合快速分配）

   若无需精确控制容量（如分一半磁盘给第一个分区），可直接用百分比指定起始、结束位置，`parted` 会自动计算对齐扇区，无需手动换算：

   ```shell
   (parted) mkpart
   Partition name?  []?                                                      
   File system type?  [ext2]? xfs                                            
   Start? 0%                                                                 
   End? 50%
   (parted) unit s
   (parted) p                                                                
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n3: 4194304s
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End       Size      File system  Name  Flags
   1      2048s  2097151s  2095104s  xfs
   ```

   适配任意磁盘容量，无需关注总扇区数，适合快速分区或脚本化操作；若需多分区连续衔接，确保前一个分区的结束比例与后一个分区的起始比例一致（如前一个结束 `50%`，后一个起始 `50%`）。
   :::

3. 查看分区

   输入 `p` 或则 `print` 查看分区表：

   ```shell{1}
   (parted) p                                                                
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size   File system  Name  Flags
   1      1049kB  1000MB  999MB  xfs
   ```

   ```shell
   (parted) q    
   ```

   退出交互模式，可以通过 `lsblk` 命令进行查看：

   ```bash
   lsblk /dev/nvme0n4
   ```

   ```console
   NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
   nvme0n4     259:5    0    2G  0 disk 
   └─nvme0n4p1 259:12   0  953M  0 part 
   ```

**非交互模式下分区：**

`parted` 的非交互模式与交互模式的 核心命令（如 `mkpart`、`rm`、`print` 等）功能完全一致，但语法上有两点关键差异：

1. 非交互模式需通过 `-s` 参数 启用静默模式（不输出交互提示）
2. 多个命令需通过 分号 `;` 分隔（或通过管道传递多行命令），一次性传递给 `parted`，而非逐行手动输入

注意，非交互模式中，`mkpart`、`rm` 等命令的参数顺序和交互模式相同（如 `mkpart` 仍遵循「名称→文件系统类型→起始→结束」）。交互模式中直接回车留空的参数（如分区名称），非交互模式需用空字符串 `''` 表示（否则会导致参数错位）。

1. 查看剩余空间

   ```bash
   parted -s /dev/nvme0n4 "print free"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
         17.4kB  1049kB  1031kB  Free Space
   1      1049kB  1000MB  999MB
         1000MB  2147MB  1147MB  Free Space
   ```

   从 `print free` 输出可知：

   - 第一个分区结束于 1000MB
   - 剩余空间从 1000MB 到 2147MB（磁盘总容量），共 1147MB

2. 创建第二个分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "mkpart '' xfs 1000MB 2147MB"
   ```

   - `-a optimal`：强制最优对齐
   - `-s`：静默模式，不弹出任何交互提示
   - `mkpart '' xfs`：是分区创建核心子命令，内部参数按「名称→文件系统标识→起始位置→结束位置」 顺序排列。`''`：分区名称留空；

3. 查看分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "p"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
   1      1049kB  1000MB  999MB
   2      1000MB  2147MB  1147MB
   ```

还可以使用百分比进行分区，先确定第一个分区在磁盘中的实际占比，再让分区 2 的起始百分比与之匹配，就能实现两个分区无缝衔接（中间无空闲空间），且 `parted` 会自动处理对齐问题，非常适合快速分配。

1. 删除分区 2

   ```bash
   parted -s /dev/nvme0n4 "rm 2"
   ```

2. 查看分区 1 占比

   ```bash
   parted /dev/nvme0n4 "unit % print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 100%
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End    Size   File system  Name  Flags
   1      0.05%  46.6%  46.5%
   ```

3. 使用百分比创建第二个分区

   ```bash
   parted -a optimal -s /dev/nvme0n4 "mkpart '' xfs 47% 100%"
   ```

   `parted` 对百分比中的小数点格式敏感（部分版本不支持带小数点的百分比，或受系统语言环境影响，把小数点解析为无效符号）。分区 1 结束于 `46.6%`，直接向上取整为 `47%`，`parted` 会自动衔接实际结束位置，不会浪费空间。

   ```bash
   parted /dev/nvme0n4 "unit % print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 100%
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start  End    Size   File system  Name  Flags
   1      0.05%  46.6%  46.5%
   2      46.6%  100%   53.4%
   ```

   ```bash
   parted /dev/nvme0n4 "print"
   ```

   ```console
   Model: VMware Virtual NVMe Disk (nvme)
   Disk /dev/nvme0n4: 2147MB
   Sector size (logical/physical): 512B/512B
   Partition Table: gpt
   Disk Flags: 

   Number  Start   End     Size    File system  Name  Flags
   1      1049kB  1000MB  999MB
   2      1000MB  2146MB  1146MB
   ```

## 格式化

在 Linux 中，格式化是管理本地存储的核心操作，但它并非删除数据这么简单，其本质是为本地硬盘分区（或本地存储设备）创建文件系统结构的过程，将原始块设备（如 `/dev/nvme0n4`）转化为可被 VFS（虚拟文件系统层）识别的存储实体。

通过 `mkfs` 格式化工具，为本地硬盘分区或本地存储设备，写入 ext4、XFS、Btrfs 等本地文件系统的数据管理结构，让 Linux 能通过这些结构实现文件存储、读取、权限控制的操作。

> [!NOTE] 只有本地分区需要格式化
> 网络文件系统（Ceph FS、HDFS、GlusterFS 等）的核心是分布式集群架构，它们不依赖单个本地分区，而是整合多台服务器的存储资源形成「虚拟存储池」。这类文件系统的启用不是格式化某个分区，而是「搭建集群 + 创建存储卷」。
>
> 特殊虚拟文件系统则是内核自动创建，无实体分区，由内核动态生成或依赖已有文件系统。

### mkfs

`mkfs`（make filesystem）工具集是 Linux 中管理本地存储文件系统的核心工具，其设计采用主命令 + 子命令的架构：主命令 `mkfs` 作为统一入口，根据文件系统类型调用对应的子命令（如 `mkfs.ext4`、`mkfs.xfs`），最终完成格式化为指定文件系统的操作。

`mkfs` 主命令本身不直接执行格式化，而是作为调度器，根据参数调用对应的子命令。其核心价值在于提供统一的语法接口，让用户无需记忆不同子命令的启动方式。

```shell
mkfs [options] [-t <type>] [fs-options] <device> [<size>]
```

| 参数部分     | 描述                                                               | 关键说明                                                              |
| ------------ | ------------------------------------------------------------------ | --------------------------------------------------------------------- |
| `options`    | 主命令自身的选项（控制 mkfs 行为）                                 | 如 `-V`（显示过程）、`-h`（帮助），不涉及文件系统具体特性配置。       |
| `-t <type>`  | 指定目标文件系统类型（如 ext4、xfs），决定调用哪个子命令           | 默认值为 ext2（较老旧，现代系统建议显式指定 `-t ext4` 或 `-t xfs`） |
| `fs-options` | 传递给子命令的选项（定制文件系统特性，如块大小、卷标等）           | 这些选项会被直接转发给子命令（如 `mkfs.ext4` 的 `-L`、`-b` 等）     |
| `device`     | 目标本地存储路径（如 `/dev/sda1` 分区、`/dev/nvme0n4` 磁盘）       | 必须是未挂载的本地存储（网络存储或虚拟文件系统不可用）              |
| `size`       | 可选，指定使用的块数量（默认由工具自动识别设备大小，极少手动指定） | 仅在特殊场景（如限制使用部分磁盘空间）下使用                        |

`mkfs` 主命令的核心逻辑是根据` -t <type>` 调用对应子命令，例如：

```shell
# 以下两条命令完全等价
mkfs -t ext4 -L "data" /dev/nvme0n4p1  # 主命令调用方式
mkfs.ext4 -L "data" /dev/nvme0n4p1     # 直接调用子命令方式
```

- 手动操作推荐直接用子命令（如 `mkfs.ext4`），更简洁直观
- 脚本自动化推荐用主命令（如 `mkfs -t $TYPE ...`），可通过变量动态切换文件系统类型

### mkfs.ext4

`mkfs.ext4` 用于创建 ext4 文件系统，是 ext 系列的最新版本（前身为 ext2、ext3），凭借极佳的兼容性（所有 Linux 发行版默认支持）和平衡的性能，成为系统盘、日常数据盘的首选。

**核心结构创建逻辑：**

`mkfs.ext4` 的本质是在磁盘分区上按固定规则创建 ext4 的五大核心结构，这些结构共同构成文件管理框架。执行命令时，会按以下逻辑生成结构：

| 核心结构              | 存储内容                                                                                         | 作用（类比仓库）                  | mkfs.ext4 如何创建与配置                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| 超级块（Super Block） | 文件系统总大小、块大小（`-b` 指定）、inode 总数（`-i`/`-N` 控制）、卷标（`-L` 设置）、创建时间等 | 仓库说明书，记录全局配置          | 命令执行时首先在分区开头写入主超级块，并在其他块组备份（防止损坏），配置参数来自命令选项（如 `-b 4096` 会写入块大小）。  |
| 块组描述符表          | 每个块组的位置、空闲空间 /inode 数量、数据块区起始地址等                                         | 仓库分区索引，定位各区域资源      | 按分区大小拆分块组（默认每个 128MB），为每个块组创建描述符，集中存放在超级块后，记录块组资源分布。                       |
| inode 表              | 每个文件的元信息（大小、权限、修改时间、数据块位置），inode 数量由 `-i`/`-N` 决定                | 文件标签库，通过 inode 找文件内容 | 在每个块组内划分连续空间，初始化所有 inode（默认 256 字节 / 个），`-E lazy_itable_init=1` 选项会延迟初始化以加速格式化。 |
| 数据块区              | 实际存储文件内容，目录的「文件名→inode 映射」也存在这里，块大小由 `-b` 指定                      | 仓库货架，放实际货物              | 块组中最大的区域，按 `-b` 指定的大小划分块（如 4KB），标记为空闲，后续文件写入时分配。                                   |
| 日志区（Journal）     | 记录磁盘操作（如修改了 inode 123），大小可通过 `-J size` 设置                                    | 仓库操作日志本，保障数据安全      | 默认在分区内创建（大小为分区的 1%），也可通过 `-J device` 指定独立分区，`-O ^has_journal` 选项可禁用日志。               |

**语法选项：**

```shell
mkfs.ext4 [options] device [blocks-count]
```

| 选项                                                       | 描述                                                                                                          | 适用场景与配置建议                                                                                                                                                |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-b 块大小`                                                | 指定数据块尺寸（单位：字节，支持 `1k`/`4k`，默认 `4096`）                                                     | **工作负载优化**<br>• 小文件（日志/配置）：`-b 1024` 减少空间浪费<br>• 大文件（视频/备份）：`-b 4096` 或 `-b 8192` 提升吞吐量<br>• 通用场景：默认 `4096` 最佳平衡 |
| `-c`                                                       | 格式化前检测坏块（读写验证）                                                                                  | **磁盘健康检查**<br>• 新盘首用：全面检测物理坏块<br>• 旧盘复用：排查损坏区域<br>• 时间成本：检测时间与磁盘容量成正比                                              |
| `-l 文件名`                                                | 从文件读取坏块列表（跳过检测）                                                                                | **快速复用**<br>• 已知坏块：复用历史检测结果（`badblocks -o badblocks.txt`生成）<br>• 批量部署：避免重复检测节省时间                                              |
| `-C 簇大小`                                                | 为嵌入式设备指定簇大小（兼容 FAT）                                                                            | **嵌入式场景**<br>• SD 卡/U 盘：`-C 4096` 匹配闪存页大小<br>• 旧设备兼容：`-C 512` 兼容老式控制器                                                                 |
| `-i 字节/inode`                                            | 控制 inode 密度（默认 `16384`）                                                                               | **inode 优化**<br>• 海量小文件：`-i 4096`（百万级文件）<br>• 大文件为主：`-i 32768` 减少元数据开销<br>• 计算公式：`inode 数 ≈ 分区大小 / -i 值`                   |
| `-I inode 大小`                                            | 指定单个 inode 尺寸（默认 `256`）                                                                             | **扩展属性支持**<br>• 复杂 ACL 权限：`-I 512` 容纳更多属性<br>• SELinux 环境：需 `-I 512` 存储安全上下文                                                          |
| `-J 日志选项`<br>`size=大小`<br>`device=设备`              | 配置日志区：<br>• 日志大小（默认分区 1%）<br>• 独立日志设备                                                   | **日志策略**<br>• 高频写入：`-J size=128M` 提升崩溃恢复速度<br>• 关键业务：`-J device=/dev/nvme1n2` 外置日志盘<br>• 临时数据：`-O ^has_journal` 完全禁用日志      |
| `-G 弹性组大小`                                            | 设置弹性块组包含的块组数（默认 `16`）                                                                         | **超大分区优化**<br>• 1TB+分区：`-G 32` 提升大文件并发性能<br>• 默认值：每个弹性组含 `16` 个块组（约 `2GB`）                                                      |
| `-N inode 总数`                                            | 直接指定 inode 数量                                                                                           | **精确控制**<br>• 固定文件数：`-N 1000000`（百万文件）<br>• 容器镜像：避免 inode 浪费<br>• 覆盖 `-i` 参数                                                         |
| `-d 源路径`                                                | 预写入目录或压缩包内容                                                                                        | **系统预制**<br>• 嵌入式设备：`-d /path/to/rootfs` 植入固件<br>• 环境标准化：`-d config.tar.gz` 预置配置                                                          |
| `-m 预留比例`                                              | root 用户保留空间（默认 `5%`）                                                                                | **空间策略**<br>• 系统分区：`-m 5` 保障紧急恢复<br>• 数据盘：`-m 0` 最大化可用空间<br>• 1TB 硬盘：默认预留 50GB，可设 `-m 1` 保留 10GB                            |
| `-o 创建者 OS`                                             | 标记文件系统创建者（如 `-o linux`）                                                                           | **兼容性标识**<br>• 跨平台共享：`-o windows` 兼容 NTFS 工具<br>• 特殊场景：极少需要手动指定                                                                       |
| `-g 块/组`                                                 | 设置每个块组的块数量（默认 `32768`）                                                                          | **元数据优化**<br>• 默认块组大小：`128MB`（32768×4K）<br>• 超大分区：`-g 131072` 创建 `512MB` 块组减少元数据量                                                    |
| `-L 卷标`                                                  | 设置卷标（最大 `16` 字符）                                                                                    | **设备标识**<br>• 多磁盘：`-L "WEB_DATA"` 直观区分<br>• 稳定挂载：通过 `/dev/disk/by-label/` 引用                                                                 |
| `-M 最后挂载点`                                            | 记录最后挂载目录（调试用）                                                                                    | **故障排查**<br>• 异常卸载：追踪最后访问路径<br>• 默认不设置，需调试时启用                                                                                        |
| `-O 特性开关`<br>`^`前缀表示禁用                           | 启用/禁用 ext4 特性：<br>• `dir_index`：目录哈希索引<br>• `extents`：大文件支持<br>• `^has_journal`：禁用日志 | **性能调优**<br>• 大目录优化：`-O dir_index` 加速 `ls`/`find`<br>• 临时数据盘：`-O ^has_journal` 提升写入速度<br>• 默认开启：`extents,has_journal` 核心特性       |
| `-r 文件系统版本`                                          | 指定文件系统版本（兼容性）                                                                                    | **旧系统兼容**<br>• 兼容内核 2.4：`-r 0` 使用旧格式<br>• 现代系统：无需指定（默认最优）                                                                           |
| `-E 扩展选项`<br>`lazy_itable_init=1`<br>`stripe_width=值` | 高级参数：<br>• 延迟初始化：加速格式化<br>• RAID 条带对齐                                                     | **大规模部署**<br>• 1TB+分区：`-E lazy_itable_init=1` 格式化时间从 10 分钟 → 10 秒<br>• RAID10 环境：`-E stripe_width=128` 匹配条带大小                           |
| `-t 文件系统类型`                                          | 兼容性参数（实际被忽略）                                                                                      | **历史遗留**<br>• 保持 `ext4` 无需修改                                                                                                                            |
| `-T 使用类型`                                              | 预设优化配置（如 `news`/`largefile`）                                                                         | **快速配置**<br>• 新闻服务器：`-T news` 优化小文件<br>• 媒体存储：`-T largefile` 大文件优化<br>• 查看预设：`tune2fs -l` 显示 `Filesystem flags`                   |
| `-U UUID`                                                  | 手动指定 UUID                                                                                                 | **集群管理**<br>• 统一配置：`-U $(uuidgen)` 生成唯一 ID<br>• 系统迁移：保持 UUID 避免挂载失效                                                                     |
| `-e 错误处理`<br>`continue`<br>`remount-ro`<br>`panic`     | 错误响应策略：<br>• 忽略继续<br>• 只读挂载<br>• 系统崩溃                                                      | **容错分级**<br>• 生产环境：`-e remount-ro` 防止错误扩散<br>• 开发测试：`-e continue` 保持服务<br>• 关键系统：`-e panic` 强制停机保护数据                         |
| `-z 撤销文件`                                              | 创建撤销文件（实验性功能）                                                                                    | **数据安全**<br>• 误格式化恢复：通过 `e2undo` 回退操作<br>• 启用：`-z undo_file.bin`                                                                              |
| `-j`                                                       | 启用日志（等价于 `-O has_journal`）                                                                           | **兼容写法**<br>• 替代 `-O has_journal` 的简写形式                                                                                                                |
| `-q`                                                       | 安静模式（仅输出错误）                                                                                        | **脚本集成**<br>• 自动化部署：避免日志干扰<br>• 后台任务：减少输出占用资源                                                                                        |
| `-v`                                                       | 详细模式（显示更多信息）                                                                                      | **调试排错**<br>• 查看格式化细节：块组分配过程<br>• 结合 `-N` 模拟运行验证参数                                                                                    |
| `-S`                                                       | 仅写入超级块和组描述符（元数据恢复）                                                                          | **灾难恢复**<br>• 修复损坏文件系统：`-S` + `e2fsck -f`<br>• **⚠️ 危险**：可能造成数据丢失                                                                          |

> [!TIP]
> 对于绝大多数日常使用场景（如格式化普通数据盘或系统盘），非专业用户无需纠结复杂选项，直接使用 `mkfs.ext4` 默认选项即可。ext4 的默认配置（4K 块大小、5%预留空间、启用日志等）已经开发者精心优化，在兼容性、性能与安全性之间取得了最佳平衡，除非明确知道需要调优（如百万级小文件/数据库专用盘），否则默认配置即是 90% 场景的最佳选择。

**创建 ext4 文件系统：**

首先确认目标分区​，通过 `lsblk` 命令查看分区信息，`FSTYPE` 表示文件系统类型：

```bash
lsblk -o NAME,FSTYPE
```

```console
NAME        FSTYPE
sr0         iso9660
nvme0n1     
├─nvme0n1p1 
├─nvme0n1p2 xfs
└─nvme0n1p3 LVM2_member
├─rl-root xfs
└─rl-swap swap
nvme0n2     
├─nvme0n2p1 
└─nvme0n2p2 
nvme0n3     
├─nvme0n3p1 
└─nvme0n3p2 
nvme0n4     
├─nvme0n4p1 
└─nvme0n4p2 
```

`FSTYPE` 列为空的分区都是未格式化，可以进行格式化操作。

> [!WARNING]
> 虽然 `nvme0n1p1` 的 `FSTYPE` 也显示为空（和 `nvme0n2p1` 等空闲分区一样），但它本质是 UEFI 启动架构下的 ESP 分区（EFI 系统分区），是系统能正常开机的核心引导分区，绝对不能像空闲分区那样格式化或删除。

这里选择 `nvme0n2` 硬盘的两个分区进行格式化（普通数据盘，用默认选项即可）：

```bash
mkfs.ext4 /dev/nvme0n2p1
```

```console
mke2fs 1.47.1 (20-May-2024)
Creating filesystem with 262144 4k blocks and 65536 inodes
Filesystem UUID: e7632ba2-a3b6-460d-b932-8b5620639cc1
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
```

执行 `mkfs.ext4 /dev/nvme0n2p1` 后的输出，本质是 ext4 文件系统创建过程的实时日志，每一行都对应 ext4 核心结构（超级块、inode 表、日志区等）的创建步骤：

| 行号 | 控制台输出内容                                                      | 说明                                                                                                                                                                                                                                    | 关联结构              | 核心含义 / 用途                                                                                                                                    |
| ---- | ------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | `mke2fs 1.47.1 (20-May-2024)`                                       | `mkfs.ext4` 是 `mke2fs` 的软链接，此行为工具版本和编译日期                                                                                                                                                                              | -                     | 用于排查格式化兼容性问题（如旧系统无法识别新格式）                                                                                                 |
| 2    | `Creating filesystem with 262144 4k blocks and 65536 inodes`        | 按默认配置创建 ext4 结构：总共有 `262144` 个 4KB 数据块（262144 × 4KB = 1024MB = 1GB，说明 `nvme0n2p1` 分区大小是 1GB）；创建 `65536` 个 inode（ext4 默认按每 16KB 空间分配 1 个 inode 计算，1GB ÷ 16KB = 65536），足够存储数万级文件。 | 数据块区、inode 表    | 初始化文件系统的基础存储单元（块用于存内容，inode 用于存文件元信息）                                                                               |
| 3    | `Filesystem UUID: e7632ba2-a3b6-460d-b932-8b5620639cc1`             | UUID 是文件系统的唯一标识，不受设备路径变化影响                                                                                                                                                                                         | -                     | 用于永久挂载（`/etc/fstab`），比设备路径（如 `/dev/nvme0n2p1`）更可靠                                                                              |
| 4    | `Superblock backups stored on blocks: 32768, 98304, 163840, 229376` | 超级块（记录全局配置）的备份位置，一旦主超级块损坏，文件系统可能无法识别                                                                                                                                                                | 超级块（Super Block） | 工具会自动在 `32768`、`98304` 等数据块位置，创建超级块备份，后续若主超级块损坏时，可通过 `e2fsck -b 32768 /dev/nvme0n2p1` 用备份恢复，避免数据丢失 |
| 5    | `Allocating group tables: done`                                     | ext4 会把分区按「块组」拆分（1GB 分区默认拆成 8 个 128MB 块组），这行表示块组的管理表已创建完成，这个表会记录每个块组的空闲空间、空闲 inode 数量、数据块区位置等，后续文件写入时，系统靠它快速定位可用资源                              | 块组描述符表          | 记录每个块组的空闲资源（空间、inode），供系统快速定位可用存储                                                                                      |
| 6    | `Writing inode tables: done`                                        | 工具已完成 `65536` 个 inode 的初始化，每个 inode 会预留空间，用于后续存储文件的元信息（如文件大小、权限、修改时间、数据块位置）。这一步完成后，分区才能开始创建文件                                                                     | inode 表              | 为后续文件创建准备元信息存储（记录文件大小、权限、数据块位置等）                                                                                   |
| 7    | `Creating journal (8192 blocks): done`                              | 这里创建的日志区占用 `8192` 个 4KB 块，总大小 = 8192 × 4KB = 32MB（ext4 默认日志区大小，按分区比例自动分配）                                                                                                                            | 日志区（Journal）     | 记录磁盘操作日志，防止断电导致数据混乱，保障文件系统崩溃后可恢复                                                                                   |
| 8    | `Writing superblocks and filesystem accounting information: done`   | 写入最终配置到超级块，记录文件系统统计信息（总块数、空闲 inode 数等）                                                                                                                                                                   | 超级块                | 标志 ext4 核心结构创建完成，`/dev/nvme0n2p1` 成为可用分区，后续可挂载使用                                                                          |

这个输出不仅是格式化成功的证明，还包含两个关键信息供后续使用：

- UUID：用于永久挂载（/etc/fstab）
- 超级块备份地址：用于后续文件系统损坏时恢复

再格式化第二个分区：

```bash
mkfs.ext4 /dev/nvme0n2p2
```

```console
mke2fs 1.47.1 (20-May-2024)
Creating filesystem with 1048320 4k blocks and 262144 inodes
Filesystem UUID: c4055cd5-31fd-4e50-bfa5-0114fbc0d08b
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done 
```

验证格式化结果：

```bash
blkid /dev/nvme0n2p1 /dev/nvme0n2p2
```

```console
/dev/nvme0n2p1: UUID="e7632ba2-a3b6-460d-b932-8b5620639cc1" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-01"
/dev/nvme0n2p2: UUID="c4055cd5-31fd-4e50-bfa5-0114fbc0d08b" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-02"
```

可以看到格式化分区成功，接下来就可以执行挂载分区，开始使用了。

### mkfs.xfs

`mkfs.xfs` 是创建 XFS 文件系统的工具，XFS 以大文件支持好、读写吞吐高、可在线扩容为核心优势，特别适合存储视频、备份数据、数据库文件等场景，性能远超 ext4。

**核心结构创建逻辑：**

创建 XFS 文件系统结构，采用「分配组（AG）」设计，为核心的五大结构，每个 AG 都是独立的小文件系统：

| 核心结构              | 存储内容                                                                          | 作用（类比仓库）                     | mkfs.xfs 如何创建与配置                                                                                             |
| --------------------- | --------------------------------------------------------------------------------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| 超级块（Super Block） | 文件系统总大小、分配组（AG）数量（`-d agcount` 指定）、块大小（`-b size` 设置）等 | 仓库全局索引，定位各分配组           | 仅在分区开头写入 1 个主超级块（不备份），记录 AG 总数和分布，`-d agcount=8` 会在此记录 8 个 AG 的位置。             |
| 分配组（AG）          | 每个 AG 包含独立的「AG 超级块、inode 区、数据块区」，可并行读写                   | 仓库独立分区，多分区并行干活，速度快 | 按分区大小拆分 AG（默认 1GB/AG，大分区可到 16GB），`-d agcount` 可手动指定数量（如 8 个 AG 对应 8 核 CPU）。        |
| inode 区              | 动态创建 inode（按需分配，不预占空间），记录文件元信息，支持扩展属性              | 灵活的标签库，避免空间浪费           | 不在 AG 中预分配 inode 表，而是预留空间，后续创建文件时动态生成（无需像 ext4 那样担心 inode 耗尽）。                |
| 数据块区              | 用 B + 树管理数据块索引（找大文件更快），块大小由 `-b size` 指定，存储文件内容    | 高性能货架，适合大文件               | 每个 AG 内的块按 `-b size` 划分（如 8KB），B + 树索引自动维护，大文件可跨 AG 存储，提升读写效率。                   |
| 日志区（Log）         | 只记录元数据操作（如分配 inode），不记录数据内容，大小由 `-l size` 设置           | 轻量操作日志，平衡性能与安全         | 默认在分区末尾创建（大小 0.5%-2%），`-l size=128M` 可增大日志区，`-l device` 可指定独立日志分区（推荐高并发场景）。 |

**语法选项：**

```shell
mkfs.xfs [options] device [blocks-count]
```

| 选项                                                                                                                                                                                   | 描述                                                                                                                                                                                                                                                                                     | 适用场景与配置建议                                                                                                                                                                                                                   |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `-b size=块大小`                                                                                                                                                                       | 指定数据块大小（单位：字节/K/M/G，如 `1k`/`4k`，默认 `4k`）                                                                                                                                                                                                                              | **按工作负载优化**<br>• 小文件场景（日志/配置）：`-b size=1k` 减少空间浪费<br>• 大文件场景（视频/备份）：`-b size=4k` 或 `-b size=8k` 提升吞吐量<br>• 通用场景：默认 `4k` 最佳平衡                                                   |
| `-c options=配置项`                                                                                                                                                                    | 从配置文件读取参数（支持批量标准化配置）                                                                                                                                                                                                                                                 | **大规模部署**<br>• 集群环境：通过 `-c options /etc/mkfs.xfs.conf` 统一配置<br>• 自动化脚本：确保多节点参数一致性<br>• 审计需求：记录格式化参数便于追溯                                                                              |
| `-m 元数据选项`<br>`crc=0\|1`<br>`finobt=0\|1`<br>`uuid=xxx`<br>`rmapbt=0\|1`<br>`reflink=0\|1`<br>`inobtcount=0\|1`<br>`bigtime=0\|1`<br>`autofsck=xxx`                               | 配置元数据特性：<br>• CRC 校验：防止元数据损坏<br>• 空闲 inode B+ 树：优化 inode 分配<br>• 手动 UUID：固定文件系统标识<br>• 反向映射 B+树：支持高级功能<br>• 写时复制：高效文件克隆<br>• inode 计数：提升大目录性能<br>• 扩展时间戳：支持 2038 年后时间<br>• 自动 fsck：设置自动检查策略 | **数据安全与效率**<br>• 生产环境：`-m crc=1,reflink=1` 启用校验和写时复制<br>• 性能优化：`-m finobt=1,inobtcount=1` 提升大目录操作效率<br>• 长期系统：`-m bigtime=1` 支持扩展时间戳<br>• 特殊需求：`-m uuid=固定值` 保持挂载配置稳定 |
| `-d 数据区选项`<br>`agcount=数量`<br>`agsize=大小`<br>`file,name=xxx`<br>`size=大小`<br>`sunit=值，swidth=值`<br>`su=num,sw=num`<br>`noalign`<br>`sectsize=大小`<br>`concurrency=数量` | 配置数据分配组（AG）：<br>• AG 数量/大小：控制并发粒度<br>• 子卷名称：指定逻辑卷名<br>• 条带对齐：优化 RAID 性能<br>• 扇区大小：设置物理扇区对齐<br>• 并发数量：控制格式化并发度                                                                                                         | **存储优化**<br>• RAID 环境：`-d su=64k,sw=4` 匹配 RAID 条带参数<br>• 超大分区：`-d agcount=32` 增加并发（>4TB）<br>• 逻辑卷管理：`-d file,name=logical_vol` 指定卷名<br>• 高性能 SSD：`-d sectsize=4096` 对齐 4K 扇区               |
| `-f`                                                                                                                                                                                   | 强制覆盖现有文件系统（忽略安全警告）                                                                                                                                                                                                                                                     | **危险操作确认**<br>• 重新初始化：覆盖旧分区数据<br>• 自动化脚本：避免交互确认提示<br>• **⚠️ 注意**：确保数据已备份，操作不可逆                                                                                                       |
| `-i inode 选项`<br>`perblock=数量`<br>`size=大小`<br>`maxpct=百分比`<br>`attr=0\|1\|2`<br>`projid32bit=0\|1`<br>`sparse=0\|1`<br>`nrext64=0\|1`<br>`exchange=0\|1`                     | 配置 inode 特性：<br>• 每块 inode 数：控制 inode 密度<br>• inode 大小：存储扩展属性能力<br>• 空间占比：限制元数据开销<br>• 属性存储：优化 ACL 性能<br>• 32 位项目 ID：兼容性设置<br>• 稀疏 inode：节省空间<br>• 64 位扩展：大文件支持<br>• 交换支持：特殊场景优化                        | **元数据优化**<br>• 复杂权限：`-i size=512,attr=2` 容纳更多扩展属性<br>• 海量小文件：`-i perblock=4096` 增加 inode 密度<br>• 大文件为主：`-i maxpct=5` 减少 inode 开销<br>• 现代系统：`-i nrext64=1` 启用 64 位扩展支持              |
| `-K`                                                                                                                                                                                   | 跳过 TRIM 操作（不发送丢弃指令）                                                                                                                                                                                                                                                         | **特殊场景优化**<br>• 老旧设备：部分机械硬盘不支持 TRIM<br>• 数据恢复：避免立即擦除原有数据<br>• 性能测试：排除 TRIM 对格式化时间影响                                                                                                |
| `-l 日志选项`<br>`agnum=数量`<br>`internal`<br>`size=大小`<br>`logdev=设备`<br>`version=版本`<br>`sunit=值、|su=数量`<br>`sectsize=大小`<br>`lazy-count=0\|1`<br>`concurrency=数量`     | 配置日志区域：<br>• 日志位置：指定 AG 编号<br>• 内部日志：内置日志模式<br>• 日志大小：影响崩溃恢复速度<br>• 独立设备：提升性能与可靠性<br>• 日志版本：功能与兼容性<br>• 懒计数：优化元数据更新                                                                                           | **高可用配置**<br>• 数据库服务器：`-l size=2G` 增大日志缓冲区<br>• 关键业务：`-l logdev=/dev/ssdlog` 独立日志设备<br>• 性能敏感：`-l version=2,lazy-count=1` 启用优化<br>• 大容量系统：`-l size=4G` 支持更大事务                     |
| `-L 卷标名`                                                                                                                                                                            | 设置文件系统卷标（最大 12 字符）                                                                                                                                                                                                                                                         | **设备标识管理**<br>• 多磁盘环境：`-L "DATA_01"` 直观标识用途<br>• 自动化挂载：通过`/dev/disk/by-label/`稳定引用<br>• 避免设备名变更：不依赖易变的`/dev/sdX`路径                                                                     |
| `-n 目录选项`<br>`size=大小`<br>`version=2\|ci`<br>`ftype=0\|1`<br>`parent=0\|1`                                                                                                       | 配置目录结构：<br>• 目录块大小：影响目录项容量<br>• 版本控制：目录格式版本<br>• 文件类型记录：加速目录操作<br>• 父目录记录：优化目录遍历                                                                                                                                                 | **目录性能优化**<br>• 海量文件目录：`-n size=8k,ftype=1` 提升`ls`/`find`效率<br>• 现代系统：`-n version=ci` 启用大小写不敏感支持<br>• 深度目录：`-n parent=1` 优化深层目录遍历<br>• 默认配置：`-n size=4k,ftype=1` 平衡性能与空间    |
| `-N`                                                                                                                                                                                   | 模拟运行（显示参数但不执行）                                                                                                                                                                                                                                                             | **参数验证**<br>• 脚本调试：检查命令语法是否正确<br>• 风险评估：预览格式化将执行的操作<br>• 学习用途：了解各参数对文件系统的影响                                                                                                     |
| `-p 原型文件`                                                                                                                                                                          | 从原型文件复制文件系统结构                                                                                                                                                                                                                                                               | **标准化部署**<br>• 嵌入式系统：基于模板快速生成一致结构<br>• 批量创建：确保多个文件系统元数据一致<br>• 特殊配置：继承原型文件的复杂权限设置                                                                                         |
| `-q`                                                                                                                                                                                   | 安静模式（仅输出错误信息）                                                                                                                                                                                                                                                               | **自动化环境**<br>• 部署脚本：减少日志输出干扰<br>• 流水线操作：配合返回值判断执行状态<br>• 后台任务：避免控制台输出占用资源                                                                                                         |
| `-r 实时区选项`<br>`extsize=大小`<br>`size=大小`<br>`rtdev=设备`                                                                                                                       | 配置实时子卷：<br>• 扩展大小：实时文件分配单元<br>• 实时区大小：限制实时文件容量<br>• 独立设备：专用高速存储区域                                                                                                                                                                         | **高性能写入**<br>• 视频采集：`-r rtdev=/dev/nvme1n1` 专用实时存储<br>• 数据流处理：`-r extsize=64k` 优化连续写入<br>• 科学计算：隔离实时数据与普通文件 IO<br>• 大文件处理：`-r size=100g` 分配专用实时空间                          |
| `-s 扇区大小`                                                                                                                                                                          | 指定逻辑扇区大小（默认自动检测）                                                                                                                                                                                                                                                         | **存储对齐优化**<br>• 4K 高级格式硬盘：`-s size=4096` 强制 4K 对齐<br>• 传统环境：`-s size=512` 兼容旧系统<br>• 性能调优：匹配底层设备物理扇区大小                                                                                   |
| `-V`                                                                                                                                                                                   | 显示版本和功能支持信息                                                                                                                                                                                                                                                                   | **环境检查**<br>• 特性验证：确认当前版本是否支持所需功能<br>• 故障排查：检查工具链版本兼容性<br>• 文档记录：记录生成文件系统的工具版本                                                                                               |
| `设备名`                                                                                                                                                                               | 目标存储设备路径（必选参数）                                                                                                                                                                                                                                                             | **所有操作基础**<br>• 本地磁盘：`/dev/sdX`或`/dev/nvmeXn1`<br>• 逻辑卷：`/dev/mapper/vg0-lv1`<br>• RAID 设备：`/dev/md0`<br>• **⚠️ 确认**：通过`lsblk`确认设备未挂载且路径正确                                                        |

*在 XFS 的选项参数中，`0` 通常表示​​禁用功能​​，`1` 表示​​启用功能​​。*

> [!TIP]
> 对于大多数非专业用户的日常场景（如数据存储盘或系统分区），直接使用 `mkfs.xfs` 的默认选项是最佳选择。XFS 的默认配置（自适应块组、CRC 校验、写时复制支持等）已经过深度优化，在性能、数据完整性和空间效率方面达到了理想平衡，完全能够满足 90% 以上的常规使用场景。

**创建 xfs 文件系统：**

同样，首先要确认目标分区，避免误操作：

```bash
lsblk -o NAME,FSTYPE
```

```console
NAME        FSTYPE
sr0         iso9660
nvme0n1     
├─nvme0n1p1 
├─nvme0n1p2 xfs
└─nvme0n1p3 LVM2_member
  ├─rl-root xfs
  └─rl-swap swap
nvme0n3     
├─nvme0n3p1 
└─nvme0n3p2 
nvme0n2     
├─nvme0n2p1 ext4
└─nvme0n2p2 ext4
nvme0n4     
├─nvme0n4p1 
└─nvme0n4p2 
```

确认好硬盘，就可以直接对 `nvme0n3` 执行格式化操作：

```bash
mkfs.xfs /dev/nvme0n3p1
```

```console
meta-data=/dev/nvme0n3p1         isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
         =                       exchange=0  
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

这段输出是 `mkfs.xfs /dev/nvme0n3p1` 执行后，XFS 文件系统创建过程的配置日志，是清晰记录了文件系统的核心结构、默认参数和资源分配情况。每个模块对应文件系统的一个核心功能部分：

1. meta-data（元数据配置）

    ```shell
    meta-data=/dev/nvme0n3p1         isize=512    agcount=4, agsize=32768000 blks
            =                       sectsz=512   attr=2, projid32bit=1
            =                       crc=1        finobt=1, sparse=1, rmapbt=1
            =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
            =                       exchange=0  
    ```

    这部分记录文件系统的基础规则，对应 XFS 的超级块 + 分配组描述：

    | 关键字段            | 作用                                                                                                                                                 |
    | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `/dev/nvme0n3p1`    | 基础信息，确保操作对象正确。                                                                                                                         |
    | `isize=512`         | 默认 512 字节足够存大多数文件的元信息，还能兼容扩展属性（如文件 ACL 权限）                                                                           |
    | `agcount=4`         | 4 个 AG 可支持多任务并行读写（比如同时存 4 个文件，分别用 4 个 AG 的资源），提升效率                                                                 |
    | `agsize=65536 blks` | 每个 AG 大小 = 65536 × 4KB = 256MB，4 个 AG 总大小 = 4×256MB = 1GB（即 `nvme0n3p1` 分区是 1GB）                                                      |
    | `sectsz=512`        | 磁盘扇区大小为 512 字节（匹配底层硬件的物理扇区），确保文件系统和硬件对齐，避免读写性能损耗                                                          |
    | `crc=1`             | 默认开校验，防止突然断电、磁盘错误导致数据混乱，提升可靠性                                                                                           |
    | `reflink=1`         | 启用重写功能（复制文件时不复制内容，只建指向，改一个不影响另一个），适合频繁复制大文件的场景（如虚拟机镜像），省空间、复制快，默认开启不影响普通使用 |

2. data（数据区配置）

   ```shell
   data     =                       bsize=4096   blocks=262144, imaxpct=25
            =                       sunit=0      swidth=0 blks
   ```

   这部分是文件系统的核心存储区，对应 XFS 的数据块区（实际存文件内容的地方）：

   | 关键字段            | 作用                                                                                                                                                                       |
   | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | `bsize=4096`        | 数据块大小为 4KB（1 个数据块是 XFS 存内容的最小单位），默认 4KB 是平衡最优解：既不会因块太小（如 1KB）导致小文件多时空闲浪费，也不会因块太大（如 8KB）导致大文件读写效率低 |
   | `blocks=262144`     | 总数据块数量为 262144 个，总存储容量 = 262144 × 4KB = 1024MB = 1GB（再次确认分区大小是 1GB，和 meta-data 一致）                                                            |
   | `imaxpct=25`        | inode 最多占用 25% 的分区空间（防止 inode 太多占满空间），默认留 25% 足够应对存大量小文件的场景（如日志），普通场景用不到这么多，不会浪费                                  |
   | `sunit=0, swidth=0` | 未适配 RAID 条带（sunit=RAID 条带单元，swidth = 条带宽度），因为是普通单盘分区，不是 RAID 阵列，所以默认 0；如果是 RAID，才需要手动配置这两个参数                          |

3. naming（目录配置）

    ```shell
    aming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
    ```

    这部分控制目录如何存储文件名，对应 XFS 的目录项结构：

    | 关键字段     | 作用                                                                                                                                                              |
    | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `version 2`  | 目录格式用第 2 版（XFS 的主流目录格式），兼容新功能（如长文件名、文件类型记录），稳定性高                                                                         |
    | `bsize=4096` | 目录块大小为 4KB（目录本身也是文件，用 4KB 块存文件名→inode 的映射），4KB 块能存更多文件名映射（比如一个块能存几十上百个文件名），提升 `ls`/`find` 等目录操作速度 |
    | `ftype=1`    | 记录文件类型（是普通文件、目录还是链接），执行 `ls -l` 时，系统不用额外查 inode 就能知道文件类型，加快命令执行速度                                                |
    | `ascii-ci=0` | 文件名区分大小写（如 File.txt 和 file.txt 是两个不同文件），符合 Linux 系统的默认习惯，避免大小写混乱                                                             |

4. log（日志区配置）

    ```shell
    log      =internal log           bsize=4096   blocks=16384, version=2
            =                       sectsz=512   sunit=1 blks, lazy-count=1
    ```

    这部分是 XFS 的崩溃恢复保障，对应日志区（记录所有磁盘操作，突然断电后能恢复数据）：

    | 关键字段       | 作用                                                                                                                                |
    | -------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
    | `internal log` | 日志区在当前分区内部（不是独立磁盘），普通场景不用独立日志盘，内部日志足够保障安全，还省硬件成本                                    |
    | `bsize=4096`   | 日志块大小为 4KB（和数据块大小一致，减少读写切换损耗），日志和数据块大小统一，提升写日志→写数据的连贯效率                           |
    | `blocks=16384` | 日志区共 16384 个块，总大小 = 16384 × 4KB = 64MB。64MB 日志区足够应对普通读写负载（如日常存文件、办公数据），不会因日志太小频繁刷盘 |
    | `lazy-count=1` | 延迟更新日志计数（减少磁盘 IO 次数），默认开延迟，在不影响安全性的前提下，降低磁盘读写压力，提升整体性能                            |

5. realtime（实时区配置）：专门存大文件的 “快速通道”

    ```shell
    realtime =none                   extsz=4096   blocks=0, rtextents=0
    ```

    这部分是 XFS 针对连续写大文件的优化区（如视频录制、大数据采集），但默认不启用：

    | 关键字段         | 作用                                                                                               |
    | ---------------- | -------------------------------------------------------------------------------------------------- |
    | `realtime =none` | 不启用实时区，普通场景（存文档、图片、小视频）用不到实时区，默认关闭避免浪费空间；需要时再手动配置 |
    | `extsz=4096`     | 若启用实时区，实时块大小为 4KB（和数据块一致），预留配置，确保启用时和现有结构兼容                 |

如果只是存日常数据、办公文件、普通备份，完全不用管这些参数；只有特殊需求（如 RAID 适配、存百万级小文件），才需要在 `mkfs.xfs` 后加额外选项调整。

在格式化第二个分区 `/dev/nvme0n3p2` 时，指定 `-L` 选项为分区设置标签，否则默认标签为空：

```bash
mkfs.xfs -L "data" /dev/nvme0n3p2
```

```console
meta-data=/dev/nvme0n3p2         isize=512    agcount=4, agsize=130944 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=1
         =                       exchange=0  
data     =                       bsize=4096   blocks=523776, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1, parent=0
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

再使用 `blkid` 命令确认分区已成功格式化为 XFS：

```bash
blkid /dev/nvme0n3p1 /dev/nvme0n3p2
```

```console
/dev/nvme0n3p1: UUID="55a73882-71bb-47d7-b027-3ade38d71035" BLOCK_SIZE="512" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="de9976b7-f594-4c95-8752-b4ee9d4a497a"
/dev/nvme0n3p2: LABEL="data" UUID="8da350d2-19b9-41dd-bcb9-dfb9d13c71a0" BLOCK_SIZE="512" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="83bdd6bd-a34d-4f23-8145-dd75edab877a"
```

## 挂载

Linux 的核心设计理念是「一切皆文件」。无论是硬盘分区、U 盘、光盘，还是键盘、鼠标等硬件设备，最终在系统中都会被抽象为一个设备文件。例如，之前看到的 `/dev/nvme0n3p2` 就是一个代表 NVMe 固态硬盘上某个分区的设备文件。

然而，这些设备文件本身只是一个访问入口或标识符，并不直接包含可以浏览的文件和文件夹。设备内部的实际内容（如 ext4 或 XFS 文件系统）必须与 Linux 的目录树（即由 `/`, `/home`, `/mnt` 等构成的层级结构）关联起来，操作系统和用户才能访问其中的数据。这个关联的过程，就称为​​挂载​​。

简单来说：

- ​​挂载​​就是将存储设备（如分区 `/dev/nvme0n3p2`）链接到目录树中的某个空文件夹（称为​​挂载点​​，例如 `/mnt/data`）
- 挂载后，访问这个挂载点文件夹，就相当于访问该存储设备的内容
- 能够进行挂载的前提是设备必须包含一个操作系统可识别的文件系统（如 XFS, ext4, NTFS 等），文件系统是存储设备和目录树之间的「翻译官」

如果想在家目录下访问另一个分区的文件，不能直接操作 `/dev/nvme0n3p2` 这个设备文件。正确的做法是，先将该分区挂载到一个目录（例如 `/home/yourname/data`），之后通过访问 `/home/yourname/data` 这个文件夹，就能像操作普通文件夹一样使用该分区中的文件了。如果没有挂载，`/dev/nvme0n3p2` 仅仅是一个没有内容的设备标识符，其中的文件系统对用户是不可见的。

### mount

`mount` 命令是 Linux 中用于挂载存储设备的核心工具，通过它可以将设备（如分区、U 盘、光盘）与系统目录树中的文件夹（挂载点）绑定，让设备内容可访问。

```shell
 mount [options] <source> <directory>
```

| 常用           | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `a`            | 挂载 `/etc/fstab` 文件里记录的所有文件系统（后续永久挂载的核心）                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `-l`           | 在列出已挂载设备时，额外显示文件系统的卷标 (Label)                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `-t <type>`    | 指定文件系统类型​​。如 xfs, ext4, ntfs, vfat, iso9660 等。默认会尝试自动识别 (auto)，识别失败时需手动指定                                                                                                                                                                                                                                                                                                                                                                                            |
| `-v`           | 详细模式​​。显示更详细的挂载过程信息，包括尝试的文件系统类型、使用的选项等                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `-o <options>` | ​​挂载选项​​。提供对挂载行为的精细控制，多个选项用逗号分隔。这是最灵活强大的选项。常用选项包括：<br>· `ro`/`rw`: 只读 / 读写挂载 （默认通常是 rw） <br>· `noexec`: 禁止执行挂载点上的二进制程序<br>· `nosuid`: 忽略 setuid 和 setgid 权限位<br>· `nodev`: 不解释挂载点上的设备文件<br>· `remount`: 重新挂载一个已挂载的文件系统，常用于更改选项 （如 `mount -o remount,ro /mountpoint`）<br>· `defaults`: 使用默认选项 (`rw`, `suid`, `dev`, `exec`, `auto`, `nouser`, `async`)<br>· `async`/`sync`: 异步 / 同步写入<br>· `user`/`nouser`: 允许 / 禁止普通用户挂载|
| `-w`           | 默认模式，允许写入挂载点（默认是只读挂载）                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `-r`           | 等价于 `-o ro`，只读挂载（简化写法）                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-n`           | 不将挂载信息写入 `/etc/mtab` 文件（默认行为），用于临时挂载或脚本中（避免污染配置）                                                                                                                                                                                                                                                                                                                                                                                                                  |

参数 `Source` 指要挂载的设备：

| 指定挂载源                                | 描述                                                     |
| ----------------------------------------- | -------------------------------------------------------- |
| `-L <卷标> / LABEL=<卷标>`                | 用文件系统卷标定位                                       |
| `-U <UUID> / UUID=<UUID>`                 | 用文件系统 UUID 定位，每个分区的 UUID 唯一，比卷标更可靠 |
| `/dev/<设备名>`                           | 用设备名定位，最直接但可能变动                           |
| `PARTLABEL=<分区标>/PARTUUID=<分区 UUID>` | 用分区标签或 UUID 定位，不是文件系统的，少用             |

`Operations` 是特殊挂载需求，日常最常用 3 个：

|操作语法|描述|实际场景举例|
|-|-|-|
|`--bind <源目录> <目标目录>`|「绑定挂载」把一个目录的内容复制到另一个目录（不是真复制，是关联）|想让普通用户在 `/home/user/data` 访问 `/mnt/data` 的内容，不用复制文件：`mount --bind /mnt/data /home/user/data`，此时两个目录内容完全同步|
|`--move <旧挂载点> <新挂载点>`|「移动挂载点」把已挂载的设备，从旧目录移到新目录（不用卸载再挂载）|已挂载 `/dev/nvme0n3p2` 到 `/mnt/data`，想移到 `/data：mount --move /mnt/data /data`，移完后访问 `/data` 就是原分区内容|
|`--rbind <源目录> <目标目录>`|「递归绑定挂载」和` --bind` 类似，但会关联源目录下的子挂载点（如源目录里还有挂载的 U 盘）|若 `/mnt/data` 里还挂载了 `/dev/sdb1`（U 盘），用 `mount --rbind /mnt/data /home/user/data`，用户访问 `/home/user/data` 时，也能看到 U 盘内容|

如果直接执行 `mount` 命令（不带任何参数）的作用是列出系统中所有已挂载的文件系统及其详细信息，包括设备来源、挂载点、文件系统类型和挂载选项等。这是查看系统挂载状态最全面的方式之一，输出内容虽长，但遵循固定格式，理解后能快速定位关键信息：

```bash
mount
```

```console
/dev/mapper/rl-root on / type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=209701,mode=755,inode64)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
……
```

每一行对应一个已挂载的文件系统，格式为：

```shell
<源设备/虚拟文件系统> on <挂载点> type <文件系统类型> (<挂载选项>)
```

输出中包含多种类型的挂载（物理设备、虚拟文件系统、临时文件系统等），按常用性分类解析：

1. 物理设备分区（实际存储设备的挂载，最受关注）

    这类条目对应硬盘 分区、U 盘等物理设备，格式以 `/dev/` 开头：

    ```shell
    # 系统根分区（核心分区，所有文件的起点）
    /dev/mapper/rl-root on / type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)

    # 系统引导分区（存放开机启动文件）
    /dev/nvme0n1p2 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
    ```

    - 关键信息：`/dev/xxx` 是设备路径，`/` 和 `/boot` 是挂载点（系统必须的核心目录），`type xfs` 说明文件系统类型，`(rw,...)` 表示读写权限。

2. 虚拟文件系统（内核与用户空间的接口，不对应实际存储）

    这类条目是 Linux 内核提供的伪文件系统，用于暴露系统状态（如内存、进程、硬件信息），不占用磁盘空间：

    ```shell
    # 进程信息文件系统（通过 /proc 可查看进程、CPU等信息）
    proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)

    # 内核设备信息（/dev 下的设备文件，如 /dev/nvme0n1 对应磁盘）
    devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,...)

    # 系统内核参数（/sys 下可查看/修改内核配置，如硬件驱动状态）
    sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
    ```

    - 这些是 Linux「一切皆文件」理念的体现，通过文件操作即可与内核交互（如 `cat /proc/cpuinfo` 查看 CPU 信息）

3. 临时文件系统（基于内存的临时存储，重启后数据消失）

    以 `tmpfs` 或 `devpts` 等类型存在，用于存放临时数据，速度远快于磁盘：

    ```shell
    # 临时共享内存（/dev/shm 可用于程序间快速交换数据，基于内存）
    tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)

    # 临时运行目录（/run 存放系统启动时的临时文件，如进程PID）
    tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=342384k,...)

    # 用户临时目录（/run/user/0 是 root 用户的临时空间，普通用户为 /run/user/1000）
    tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,...)
    ```

    - 数据存于内存，读写速度快，但重启后清空，适合临时缓存、会话数据等

4. 特殊功能文件系统（用于特定内核功能）

    这类文件系统服务于内核高级功能（如调试、安全、进程控制等）：

    ```shell
    # 安全模块文件系统（SELinux 相关配置，控制文件访问权限）
    selinuxfs on /sys/fs/selinux type selinuxfs (rw,nosuid,noexec,relatime)

    # 内核调试文件系统（用于调试内核，开发人员常用）
    debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime,seclabel)

    # 跟踪文件系统（记录内核函数调用，用于性能分析）
    tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime,seclabel)
    ```

    - 普通用户很少直接操作，主要供系统管理员或开发人员调试、配置系统

### 临时挂载

临时挂载是指通过 `mount` 命令手动执行的挂载操作，不依赖系统配置文件（如 `/etc/fstab`）。在当前系统运行周期内，将存储设备（如分区、U 盘）与挂载点文件夹**临时**绑定，让设备可访问；但一旦系统重启、关机，或执行 `umount` 卸载命令，这个绑定关系会自动消失，下次使用需重新执行 `mount` 命令。

1. 确认设备

    先通过命令确认要挂载的设备是否存在、未挂载，防止格式化错设备：

    ```bash
    lsblk /dev/nvme0n2 -o NAME,FSTYPE,SIZE,MOUNTPOINT
    ```

    ```console
    NAME        FSTYPE SIZE MOUNTPOINT
    nvme0n2              5G 
    ├─nvme0n2p1 ext4     1G 
    └─nvme0n2p2 ext4     4G 
    ```

    确保设备的 MOUNTPOINT 列为空（未挂载），且 FSTYPE 是目标文件系统（如 xfs/ext4）。

    查看设备 UUID 和卷标，后续挂载需要使用：

    ```bash
    blkid /dev/nvme0n2p1 /dev/nvme0n2p2
    ```

    ```console
    /dev/nvme0n2p1: UUID="e7632ba2-a3b6-460d-b932-8b5620639cc1" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-01"
    /dev/nvme0n2p2: UUID="c4055cd5-31fd-4e50-bfa5-0114fbc0d08b" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="7d6e7fc8-02"
    ```

2. 建挂载点

    挂载点是设备内容的访问入口，建议放在 `/mnt`（临时挂载）或 `/data`（永久存储）目录下，且必须是空文件夹。

    分别创建两个挂载点 `/mnt/data1` 和 `/mnt/data2`，用于挂载 `/dev/nvme0n2p1` 和 `/dev/nvme0n2p2` 分区：

    ```bash
    mkdir -p /mnt/data1 /mnt/data2
    ```

    ```bash
    ls -la /mnt/data1 /mnt/data2
    ```

    ```console
    /mnt/data1:
    total 0
    drwxr-xr-x. 2 root root  6 Sep 29 11:30 .
    drwxr-xr-x. 4 root root 32 Sep 29 11:30 ..

    /mnt/data2:
    total 0
    drwxr-xr-x. 2 root root  6 Sep 29 11:30 .
    drwxr-xr-x. 4 root root 32 Sep 29 11:30 ..
    ```

    > [!TIP] 挂载点
    > 在 `/` 盘下执行 `mkdir /mnt/data1` 创建挂载点时，这个 `/mnt/data1` 本质是 `/` 目录下的一个空目录项，不是存储文件的空间。Linux 中目录的本质是「文件名→inode 的映射表」，空目录的映射表只有 1 条（记录自身），仅占用几十字节的元数据（存在 `/` 盘的 inode 表中），完全可以忽略，不会消耗 `/` 盘的实际存储。
    >
    > 当执行 `mount /dev/nvme0n2p1 /mnt/data1` 后，这个 `/mnt/data1` 的空间属性会被替换成被挂载设备（`/dev/ nvme0n2p1`）的空间，和 `/` 盘再无关系。

3. 执行挂载

    优先用卷标或 UUID 挂载，设备路径可能因插新盘变化，卷标 / UUID 永久不变。

    > [!NOTE] 格式化后设置卷标
    > 如果在格式化的时候没有设置卷标，可以使用 `e2label` 和 `xfs_admin` 命令为已格式化的分区设置卷标：
    >
    > - 对于 ext4 文件系统（用 `e2label` 工具）：`e2label /dev/nvme0n2p1 mydata`
    >
    > - 对于 XFS 文件系统（用 `xfs_admin` 工具）：`xfs_admin -L mydata /dev/nvme0n2p1`
    >
    > `e2label` 和 `xfs_admin` 是 Linux 系统中专门管理文件系统元数据的工具，核心功能是查看 / 设置文件系统的卷标（Label）。

    使用 `/dev/nvme0n2p1` 的 UUID 进行挂载到 `/mnt/data1`：

    ```bash
    mount UUID=e7632ba2-a3b6-460d-b932-8b5620639cc1 /mnt/data1
    ```

    使用 `/dev/nvme0n2p2` 的 UUID 进行挂载到 `/mnt/data2`：

    ```bash
    mount UUID=c4055cd5-31fd-4e50-bfa5-0114fbc0d08b /mnt/data2
    ```

4. 验证挂载

挂载后通过`df -h` 或 `mount` 命令查看挂载信息，确认是否生效：

```bash
df -h
```

```console {10,11}
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/rl-root   17G  2.5G   15G  15% /
devtmpfs             4.0M     0  4.0M   0% /dev
tmpfs                836M     0  836M   0% /dev/shm
tmpfs                335M  6.3M  329M   2% /run
tmpfs                1.0M     0  1.0M   0% /run/credentials/systemd-journald.service
/dev/nvme0n1p2       960M  247M  714M  26% /boot
tmpfs                1.0M     0  1.0M   0% /run/credentials/getty@tty1.service
tmpfs                168M  4.0K  168M   1% /run/user/0
/dev/nvme0n2p1       974M   24K  907M   1% /mnt/data1
/dev/nvme0n2p2       3.9G   24K  3.7G   1% /mnt/data2
```

输出中明确显示 `/dev/nvme0n2p1` 关联 `/mnt/data1`（容量 974M）、`/dev/nvme0n2p2` 关联 `/mnt/data2`（容量 3.9G），说明两个分区已成功挂载。

```bash
mount | grep /mnt/data
```

```console
/dev/nvme0n2p1 on /mnt/data1 type ext4 (rw,relatime,seclabel)
/dev/nvme0n2p2 on /mnt/data2 type ext4 (rw,relatime,seclabel)
```

- `type ext4`：确认两个分区的文件系统均为 ext4（与格式化时的配置一致）
- `(rw, ...)`：rw 表示 “读写模式”，说明分区可正常创建、修改、删除文件（若为 `ro` 则为只读，需调整挂载选项）

可以实际测试，在 `/mnt/data1` 和 `/mnt/data2` 分别创建文件，验证是否能正常读写：

```bash
echo "hello world" | tee /mnt/data1/test.txt /mnt/data2/test.txt
```

```bash
cat /mnt/data1/test.txt /mnt/data2/test.txt
```

```console
hello world
hello world
```

读写功能可正常创建文件并写入内容，读取时无异常，确认分区可投入实际使用。

临时挂载需要注意，重启后文件不会丢，但是挂载关系会断开，需要重新挂载。若每天都需要访问 `/dev/nvme0n2p1`，临时挂载会很麻烦（每天重启后都要手动 `mount`），此时必须配置永久挂载。

### 永久挂载

临时挂载重启后会失效，若需要 `/dev/nvme0n2p1`、`/dev/nvme0n2p2` 这类固定分区每次开机自动挂载，就需要配置永久挂载。核心是通过系统配置文件 `/etc/fstab` 实现，系统启动时会自动读取该文件的挂载规则，无需手动执行 `mount` 命令。

`/etc/fstab`（filesystem table，文件系统表）是 Linux 系统用于存储 “永久挂载规则” 的配置文件，所有需要开机自动挂载的设备，都需在该文件中添加一条规则：

:::code-group
```shell [/etc/fstab]
#
# /etc/fstab
# Created by anaconda on Fri Jul  4 02:09:33 2025
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
UUID=832de919-24b7-4cc3-937e-27eb203ceb8e /                       xfs     defaults        0 0
UUID=8a23603e-7674-4fd5-8515-a757bd9a2fc1 /boot                   xfs     defaults        0 0
UUID=10226468-de0a-42a6-a380-9c3b5e1f04a4 none                    swap    defaults        0 0
```
:::

配置文件中每行对应一个文件系统的永久挂载规则，严格遵循 6 个字段的固定格式，字段之间用空格或制表符分隔，顺序不可颠倒。完整格式模板及各字段详解如下：

```shell
<设备标识>  <挂载点>  <文件系统类型>  <挂载选项>  <dump>  <pass>
```

- 设备标识：精准定位要挂载的设备（告诉系统挂载哪个设备）可以是设备路径、卷标、UUID 等
- 挂载点：指定要挂载到的目录（挂载到哪个目录下），必须是已存在的目录
- 文件系统类型：指定要挂载的文件系统类型（如 ext4、xfs、swap 等）
- 挂载选项：指定挂载时的额外选项（如 `defaults`、`ro`、`rw` 等）
- `dump`：是否在 `dump` 备份时包含该文件系统（`0` 表示不包含，`1` 表示包含）
- `pass`：是否在 `fsck` 检查文件系统时包含该文件系统（`0` 表示不包含，`1` 表示包含）

> [!WARNING]
> 配置`/etc/fstab` 的「挂载选项、`dump`、`pass`」字段时，需重点注意以下风险点，避免因配置错误导致挂载失败、系统开机卡住或数据访问异常：
>
> 挂载选项：`defaults` 是多数场景的安全选择（包含读写、自动挂载等基础规则），若手动指定选项需注意格式（多个选项用逗号分隔，无空格，如 `defaults,ro`）；避免误设 `ro`（只读）却需写入数据（会提示 `Permission denied`），或误加 `noexec`（禁止执行程序）却需运行分区内脚本（会提示 `Permission denied`）。
>
> `dump`：现代 Linux 系统几乎不再使用 `dump` 工具备份，此字段建议固定填 `0`（不包含在 `dump` 备份中）；若填 `1`，不仅无实际备份意义，还可能因 `dump` 工具扫描占用系统资源，影响分区正常使用。
>
> `pass`：此字段控制 `fsck` 磁盘检查顺序，需严格区分分区类型根分区（`/`）可填 `1`（优先检查），其他普通分区（如 `/mnt/data1`）填 `2`（次优先检查）或 `0`（不检查），交换分区（`swap`）必须填 `0`（无需检查）；若给非根分区填 `1`，会导致开机时 `fsck` 检查顺序冲突，系统可能卡在检查阶段无法启动。

首先，使用 `umount` 先卸载之前临时的挂载（虽不影响，但无法验证 `fstab` 规则是否真的能独立生效（比如 UUID 是否填对、文件系统类型是否正确，所以先卸载再添加）：

```bash
umount /mnt/data1 /mnt/data2
```

然后再编辑 `/etc/fstab` 添加永久挂载规则：

```bash
vim /etc/fstab
```

```console:line-numbers=13 {2,3}
……
UUID=e7632ba2-a3b6-460d-b932-8b5620639cc1 /mnt/data1                       xfs     defaults        0 0
UUID=c4055cd5-31fd-4e50-bfa5-0114fbc0d08b /mnt/data2                       xfs     defaults        0 0
```

最后，执行挂载测试：

```bash
mount -a
```

让系统加载 `/etc/fstab` 中的新规则，无输出即无错误。

> [!NOTE] umount
> `umount` 是 Linux 中用于卸载已挂载文件系统的命令，作用与 `mount` 相反：它会解除存储设备（如分区、U 盘）与挂载点目录之间的关联，让设备可以安全移除（如拔 U 盘）或重新配置（如修改挂载选项）。若设备因被程序占用而无法卸载（提示 `device is busy`），`umount` 也会报错，需先关闭占用程序再重试。
>
> 即使是通过 `/etc/fstab` 配置的永久挂载分区，也可以用 `umount` 命令手动卸载。

此时，即使再次重启，`/mnt/data1` 和 `/mnt/data2` 也会自动挂载，永久挂载配置完成：

```bash
df -h /mnt/data1 /mnt/data2
```