# 基础文件操作命令

基础文件操作命令是 Linux 系统中用于执行日常文件和目录管理任务的一组核心命令。这些命令对于用户来说非常重要，因为它们允许用户创建、查看、移动、复制、重命名和删除文件和目录。

## cd（切换目录）

`cd` 命令是 Linux 系统中用于改变当前工作目录的命令。它是 Change Directory 的缩写。这个命令对于文件系统导航至关重要，是用户和系统管理员日常使用最频繁的命令之一。

```shell
cd [OPTION]... [DIR]...
```

| 常见选项 | 功能说明                                                                                                                                                                    |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-L`     | 逻辑模式（默认行为）。跟随软链接，将软链接视为目录。使用此选项时，`cd` 命令会进入软链接指向的路径，但保留软链接在路径中的表示。`pwd` 命令会显示包含软链接的逻辑路径         |
| `-P`     | 物理模式。解析路径中的所有软链接，使用真实的物理路径。使用此选项时，`cd` 命令会解析路径中的所有软链接，进入实际的物理目录。`pwd` 命令会显示真实的物理路径，不包含任何软链接 |
| `-e`     | 如果使用了 -P 选项，并且当前工作目录无法确定，那么 `cd` 命令将退出并返回一个非零状态。这通常用于脚本中，以便在目录切换失败时能够检测到错误                                  |
| `-@`     | 在支持的系统上，这个选项会将具有扩展属性的文件显示为一个目录，其中包含文件的扩展属性。这在处理带有特殊属性的文件时可能有用，但并不是所有系统都支持这个选项                  |

| 参数  | 功能说明                                                                                         |
| ----- | ------------------------------------------------------------------------------------------------ |
| `DIR` | 表示要切换到的目录。路径可以是绝对路径，也可以是相对路径，若省略不写则会跳转至当前使用者的家目‍录 |

除此之外，`cd` 命令后面可以跟一些特殊符号，表达固定的作用：

| 特殊符号  | 功能说明                   |
| --------- | -------------------------- |
| `~`       | 代表当前登录用户的主目录   |
| `~用户名` | 表示切换至指定用户的主目录 |
| `-`       | 代表上次所在目录           |
| `.`       | 代表当前目录               |
| `..`      | 代表上级目录               |

1. 切换指定目录

    ```shell
    [root@localhost ~]# cd /var/log/
    [root@localhost log]#
    ```

2. 返回目前的上一级目录：

    ```shell
    [root@localhost log]# cd ..
    [root@localhost var]# 
    ```

3. 返回上次所在目录：

    ```shell
    [root@localhost var]# cd -
    /var/log
    [root@localhost log]# 
    ```

4. 回到当前用户主目录

    对于 root 用户，其主目录为 `/root`，没有加上任何路径，也代表回到当前登录用户的主目录：

    ```shell
    [root@localhost log]# cd ~
    [root@localhost ~]# 
    ```

5. 切换软链接

    在 Rocky Linux 系统中，`/bin` 作为一个软链接，指向 `/usr/bin`：

    ```shell
    [root@localhost ~]# ls -l /bin
    ```

    ```console
    lrwxrwxrwx. 1 root root 7 May 16  2022 /bin -> usr/bin
    ```

    当使用 `cd -L` 命令：

    ```shell
    [root@localhost ~]# cd -L /bin/
    [root@localhost bin]# pwd
    ```

    ```console
    /bin
    ```

    `cd -L` 命令将软链接视为普通目录。它不会解析软链接，而是将其视为目标位置。这就是为什么 `pwd` 显示 `/bin`。

    使用 `cd -P` 命令：

    ```shell
    [root@localhost ~]# cd -P /bin/
    [root@localhost ~]# pwd
    ```

    ```console
    /usr/bin
    ```

    `cd -P` 命令会解析路径中的所有软链接，找到真实的物理路径。在这个例子中，它解析了 `/bin` 软链接，发现它指向 `/usr/bin`，因此切换到那个目录。这就是为什么 `pwd` 显示 `/usr/bin`。

    这在进行系统管理或脚本编写时特别有用，因为有时候可能需要知道软链接的位置，而其他时候可能需要知道实际的物理路径。

## pwd（显示当前路径）

在 Linux 文件系统的层次结构中，目录众多，当用户执行命令而未指定命令或参数所在的具体路径时，系统会默认在当前工作目录中搜索相应的命令或文件。因此，为了确保命令能够正确执行，用户在执行命令前通常需要先确认自己所在的目录。

`pwd` 命令，即 Print Working Directory（打印工作目录）的缩写，其主要用途是显示用户当前所在的工作目录的完整路径，用户可以轻松地获取当前工作目录的绝对路径，从而确保在执行后续命令时能够准确无误地指向目标文件或目录。

```shell
pwd [OPTION]...
```

| 常见选项 | 功能说明                                                   |
| -------- | ---------------------------------------------------------- |
| `-L`     | 显示逻辑路径，如果有软链接，它会显示软链接的路径。         |
| `-P`     | 显示物理路径，忽略软链接，直接显示当前工作目录的实际路径。 |

当使用 `-L` 选项时，`pwd` 命令显示了当前工作目录的逻辑路径，这可能包括软链接：

```shell
[root@localhost ~]# cd /bin
[root@localhost bin]# pwd -L
```

```console
/bin
```

虽然 `/bin` 是一个软链接，但 `-L` 选项会显示逻辑路径，而不是物理路径。

当使用 `-P` 选项时，`pwd` 命令显示了当前工作目录的实际物理路径，不包括任何软链接：

```shell
[root@localhost bin]# pwd -P
```

```console
/usr/bin
```

可以看出，显示的是 `/usr/bin`，这揭示了 `/bin` 实际上是一个指向 `/usr/bin` 的软链接。

## ls（查看目录下文件）

`ls` 命令是 Linux 系统中用于列出目录内容的常用命令。它提供了一种快速查看文件和子目录的方式。

```shell
ls [OPTION]... [FILE]...
```

| 常见选项 | 功能说明                                                                                                              |
| -------- | --------------------------------------------------------------------------------------------------------------------- |
| `-a`     | 显示所有文件，包括隐藏文件（开头为 `.` 的文件）也一起罗列出来                                                         |
| `-A`     | 显示所有文件，包括隐藏文件，但不包括 `.` 与 `..` 这两个目录                                                           |
| `-F`     | 在文件或目录名后加上文件类型的指示符号，例如，`*` 代表可运行文件，`/` 代表目录，`=` 代表 socket 文件，`@` 代表 软链接 |
| `-l`     | 使用长列表格式显示文件和目录的详细信息，包括文件权限、所有者、组、大小、修改日期和时间，以及文件名                    |
| `-h`     | 与 -l 一起使用时，以易读的格式（如 K、M、G 表示千字节、兆字节和吉字节）显示文件大小，而不是以字节为单位               |
| `-i`     | 显示文件的 inode 号。每个文件和目录在文件系统中都有一个唯一的 inode 号，这个选项可以用来查看这些编号                  |
| `-d`     | 仅列出目录本身，而不是列出目录内的文件数据                                                                            |
| `-R`     | 递归地列出所有子目录的内容。对于每个目录，ls 会进入子目录并列出其中的内容，一直深入到所有层级                         |
| `-f`     | 直接列出文件和目录，不进行任何排序。默认情况下，ls 会根据文件名的字母顺序进行排序，使用 `-f` 可以关闭这一行为         |
| `-r`     | 反向排序文件。默认情况下，文件可能会按字母顺序或时间顺序排序，使用 `-r` 可以颠倒排序结果                              |
| `-S`     | 按文件大小排序。默认情况下，ls 可能会按名称排序，使用 `-S` 可以根据文件大小进行排序                                   |
| `-t`     | 按文件修改时间排序。默认情况下，文件可能会按名称排序，使用 `-t` 可以根据文件最后修改的时间进行排序                    |
| `-v`     | 使用自然排序方式（版本号排序），例如 2, 10, 20 而不是 10, 2, 20                                                       |

| 参数   | 功能说明                                                                 |
| ------ | ------------------------------------------------------------------------ |
| `FILE` | 想要列出信息的文件或目录的名称。如果不提供任何参数，默认列出当前工作目录 |

> [!NOTE]
> 当 `ls` 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色（蓝色显示目录，白色显示一般文件）。

1. 查看目录下所有文件

    ```bash
    ls -al
    ```

    ```console
    total 36
    dr-xr-x---.  4 root root 4096 Sep 19 09:51 .
    dr-xr-xr-x. 18 root root  235 Sep 12 15:43 ..
    -rw-------.  1 root root 1388 Sep 18 17:45 .bash_history
    -rw-r--r--.  1 root root   18 May 11  2022 .bash_logout
    -rw-r--r--.  1 root root  141 May 11  2022 .bash_profile
    -rw-r--r--.  1 root root  429 May 11  2022 .bashrc
    -rw-r--r--.  1 root root  100 May 11  2022 .cshrc
    -rw-------.  1 root root   20 Sep 18 11:01 .lesshst
    drwx------.  2 root root    6 Sep 12 15:43 .ssh
    -rw-r--r--.  1 root root  129 May 11  2022 .tcshrc
    -rw-r--r--.  1 root root    0 Sep 19 09:46 10
    -rw-r--r--.  1 root root    0 Sep 19 09:46 2
    -rw-r--r--.  1 root root    0 Sep 19 09:46 20
    -rw-------.  1 root root  819 Sep 12 15:45 anaconda-ks.cfg
    drwxr-xr-x.  2 root root   21 Sep 18 11:19 shell
    -rw-r--r--.  1 root root    0 Sep 16 23:35 test.sh
    ```

    通过使用 `-a`，会看到以 `.` 为开头的几个文件，以及目录文件 （`.`）、（`..`） 等等，这些都是隐藏的目录和文件。其中，目录文件名以蓝色显示，一般文件以白色显示，可执行文件以绿色显示。

    > [!TIP] 隐藏文件
    > 在 Linux 系统中，隐藏文件（以点 `.` 开头的文件）的设计初衷并不是为了保密，而是作为一种视觉提示，告知用户这些文件通常包含重要的系统配置、状态信息或程序数据。这些文件对于系统的稳定运行和应用程序的正确执行至关重要，因此建议用户在没有充分理由的情况下不要随意修改或删除它们。

    除此之外，这里的 `ls` 命令还使用了 `-l` 选项，因此才显示出了文件的详细信息，具体包括以下七个方面的信息：

    | 位置 | 含义           | 说明                                                                                                                                                             |
    | ---- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | 1    | 文件类型和权限 | 显示文件类型和权限。它由一系列字符组成，第一个字符表示文件类型（例如，`d` 表示目录，`-` 表示普通文件），接下来的字符表示权限（例如，`rwx` 表示读、写、执行权限） |
    | 2    | 硬链接数量     | 显示文件的硬链接数量。对于文件，这个数字通常为 1，除非文件有多个硬链接。对于目录，这个数字表示目录下的子目录数量                                                 |
    | 3    | 所有者         | 显示文件所有者用户名。所有者通常是创建文件的用户                                                                                                                 |
    | 4    | 所属组         | 显示文件所属的用户组。默认情况下，文件的所属组是创建文件用户的主组                                                                                               |
    | 5    | 大小           | 显示文件的大小，以字节为单位。对于目录，这个字段通常显示为 4096 字节，这是因为目录结构本身占用的空间，而不是目录内容的大小                                       |
    | 6    | 修改时间       | 显示文件的最后修改时间。这个时间戳表示文件内容或状态最后被修改的日期和时间                                                                                       |
    | 7    | 文件名或目录名 | 最后一列显示文件或目录的名称                                                                                                                                     |

2. 查看某个目录的详细信息

    `ls` 命令会显示目录下的内容，而不会显示这个目录本身的详细信息。如果想显示目录本身的信息，就需要加上 `-d` 选项：

    ```bash
    ls -ld /root/
    ```

    ```console
    dr-xr-x---. 4 root root 4096 Sep 19 09:51 /root/
    ```

3. 显示的文件大小

    使用 `ls -l` 命令时显示的文件大小默认是字节，但是更加习惯的是千字节用 KB 显示，兆字节用 MB 显示，而 `-h` 选项就是按照人们习惯的单位显示文件大小的：

    ```bash
    ls -lh /boot/
    ```

    ```console
    total 177M
    -rw-------. 1 root root 8.3M May  2 03:23 System.map-5.14.0-427.13.1.el9_4.x86_64
    -rw-r--r--. 1 root root 218K May  2 03:23 config-5.14.0-427.13.1.el9_4.x86_64
    drwxr-xr-x. 3 root root   17 Sep 12 15:43 efi
    drwx------. 5 root root   97 Sep 12 15:45 grub2
    -rw-------. 1 root root  75M Sep 12 15:44 initramfs-0-rescue-1e0252674bc44e75af9226a8e9364ef8.img
    -rw-------. 1 root root  36M Sep 12 15:45 initramfs-5.14.0-427.13.1.el9_4.x86_64.img
    -rw-------. 1 root root  32M Sep 12 15:49 initramfs-5.14.0-427.13.1.el9_4.x86_64kdump.img
    drwxr-xr-x. 3 root root   21 Sep 12 15:43 loader
    -rwxr-xr-x. 1 root root  13M Sep 12 15:44 vmlinuz-0-rescue-1e0252674bc44e75af9226a8e9364ef8
    -rwxr-xr-x. 1 root root  13M May  2 03:23 vmlinuz-5.14.0-427.13.1.el9_4.x86_64
    ```

> [!NOTE]
> `ll` 并不是一个独立的命令，而是 `ls -l` 的别名。

## mkdir（创建目录）

`mkdir` 是一个在 Linux 系统中用来创建新目录的命令，它是 Make Directory 的缩写。这个命令非常实用，可以帮助用户组织文件和数据。

```shell
mkdir [OPTION]... DIRECTORY...
```

| 常见选项 | 功能说明                                                                                     |
| -------- | -------------------------------------------------------------------------------------------- |
| `-p`     | 递归创建所有目录。创建指定的目录路径，包括所有必需的父目录。如果父目录不存在，它们也会被创建 |
| `-m`     | 手动配置所创建目录的权限，而不再使用默认权限。相当于在创建目录后使用 `chmod` 命令            |

| 参数        | 功能说明                                                                       |
| ----------- | ------------------------------------------------------------------------------ |
| `DIRECTORY` | 想要创建的一个或多个目录的名称，可以是单个目录名，也可以是包含多个子目录的路径 |

1. 创建目录

   ```bash
    mkdir testdir
    ```

    ```bash
    ls
    ```

    ```console
    anaconda-ks.cfg  testdir
    ```

2. 创建一个包含多个子目录的路径

    ```bash
    mkdir A/B/C/D
    ```

    ```console
    mkdir: cannot create directory ‘A/B/C/D’: No such file or directory
    ```

    这个命令尝试在当前目录下创建目录 A，然后在 A 下创建目录 B，接着在 B 下创建目录 C，最后在 C 下创建目录 D。但是，由于这些父目录 A、B 和 C 都不存在，所以命令失败了，并返回了错误信息。

    ```bash
    mkdir -p A/B/C/D
    ```

    ```bash
    tree 
    ```

    ```console
    .
    ├── A
    │   └── B
    │       └── C
    │           └── D
    ├── anaconda-ks.cfg
    └── testdir
    
    6 directories, 1 file
    ```

    如果使用 `-p` 选项告诉 `mkdir` 命令如果父目录不存在，则应该创建它们。因此，`mkdir` 命令会递归地创建所有不存在的父目录，最终成功创建了完整的目录结构 `A/B/C/D`。

    `tree` 命令的输出显示了一个目录树，其中包含了新创建的 `A/B/C/D` 目录结构，以及一个已存在的 `test` 目录。这证实了 `-p` 选项成功地创建了所需的多级目录结构。

    >[!WARNING]
    >`tree` 命令不是 Linux 系统的默认安装项，需要手动安装，后续会介绍如何安装软件包，这里先不展开。

3. 创建一个目录，并设置相关权限

    ```bash
    mkdir -m 777 linux
    ls -l
    ```

    ```console
    total 4
    drwxr-xr-x. 3 root root  15 Oct 13 16:49 A
    -rw-------. 1 root root 748 Jul  4 10:11 anaconda-ks.cfg
    drwxrwxrwx. 2 root root   6 Oct 13 16:51 linux
    drwxr-xr-x. 2 root root   6 Oct 13 16:49 testdir
    ```

    这条命令创建了一个名为 linux 的新目录，并且设置了权限，使得所有用户都有对这个目录的读、写和执行权限。使用 `ls -l` 命令来列出当前目录下的文件和目录及其权限，可以看到它的权限设置为 `drwxrwxrwx`，这表明所有用户都有读、写和执行权限，这使用 `-m 777` 设置的权限相符。

## touch（创建文件及修改文件时间戳）

`touch` 命令是一个多功能工具，它不仅可以创建新的空文件，还可以更新现有文件的时间戳。

- **创建空文件**：如果指定的文件不存在，`touch` 命令会在当前目录下创建一个新的空文件
- **更新时间戳**：当文件已经存在时，`touch` 命令会更新文件的访问时间和数据修改时间

> [!TIP] 时间戳
> Linux 系统中的每个文件都有三个重要的时间参数，可以通过 `stat` 命令查看：
>
> - **访问时间** (Access Time, atime)：文件的访问时间记录了最后一次读取文件内容的时间。例如，当使用 `cat` 命令查看文件内容时，访问时间会被更新
> - **数据修改时间** (Modify Time, mtime)：数据修改时间记录了文件内容最后一次被修改的时间。每当文件内容发生变化时，这个时间戳也会相应更新
> - **状态修改时间** (Change Time, ctime)：状态修改时间记录了文件的元数据（如权限、所有权等）最后一次发生变化的时间。当您更改文件的权限或属性时，状态修改时间会更新

```shell
touch [OPTION]... FILE...
```

| 常见选项    | 功能说明                                                                                                 |
| ----------- | -------------------------------------------------------------------------------------------------------- |
| `-a`        | 仅更新文件的访问时间。如果文件不存在，则会创建文件                                                       |
| `-m`        | 仅更新文件的数据修改时间。如果文件不存在，则会创建文件                                                   |
| `-c`        | 仅更新文件时三个重要的时间参数。如果文件不存在，不执行任何操作                                           |
| `-d STRING` | 使用更自然的语言格式，而不是使用严格的时间戳格式来设置文件的访问时间和修改时间                           |
| `-t STAMP`  | 使用指定的时间格式 `[[CC]YY]MMDDhhmm[.ss]` 来设置文件的访问时间和修改时间。时间格式例如：201101011500.30 |

> [!NOTE] STRING 可以是以下形式
>
> 1. 标准日期格式：例如： `YYYY-MM-DD HH:MM:SS` 的格式，2024-09-19 17:01:05
> 2. 相对日期格式：例如 `10 minutes ago`、`2 hours ago`、`1 day ago` 等，用于指定相对于当前时间的过去时间
> 3. 使用文字描述：例如 `now`、`yesterday`、`next Friday`、`last Monday` 等，用于描述特定的日期和时间

| 参数   | 功能说明                                                                                                     |
| ------ | ------------------------------------------------------------------------------------------------------------ |
| `FILE` | 一个或多个文件名。如果文件不存在，将创建新文件，除非使用了 `-c` 选项。如果文件已存在，将根据选项更新其时间戳 |

1. 创建一个文件

    ```bash
    touch qq
    ls -l
    ```

    ```console
    total 4
    -rw-------. 1 root root 748 Jul  4 10:11 anaconda-ks.cfg
    -rw-r--r--. 1 root root   0 Oct 13 16:53 qq
    drwxr-xr-x. 2 root root  19 Oct 13 16:52 testdir
    ```

    可以看到 qq 的文件类型是 `-`，表示普通文件。

2. 创建一个文件，然后使用 `touch` 仅更新文件的访问时间

    ```bash
    touch yy
    stat yy
    ```

    ```console
      File: yy
      Size: 0               Blocks: 0          IO Block: 4096   regular empty file
    Device: 253,0   Inode: 33956338    Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Context: unconfined_u:object_r:admin_home_t:s0
    Access: 2025-10-13 16:55:27.974193495 +0800
    Modify: 2025-10-13 16:55:27.974193495 +0800
    Change: 2025-10-13 16:55:27.974193495 +0800
    Birth: 2025-10-13 16:55:27.973193479 +0800
    ```

    使用 `-a` 选项仅更新文件的访问时间：

    ```bash
    touch -a yy
    stat yy
    ```

    ```console
      File: yy
      Size: 0               Blocks: 0          IO Block: 4096   regular empty file
    Device: 253,0   Inode: 33956338    Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Context: unconfined_u:object_r:admin_home_t:s0
    Access: 2025-10-13 16:56:44.135432720 +0800
    Modify: 2025-10-13 16:55:27.974193495 +0800
    Change: 2025-10-13 16:56:44.135432720 +0800
    Birth: 2025-10-13 16:55:27.973193479 +0800
    ```

    可以看到文件 yy 的 Access(atime) 和 Change(ctime)  时间更新了，因为更改文件的任何元数据（包括访问时间）时，所以会同时更新状态改变时间。

3. 更新文件的所有时间戳

    ```bash
    touch -c yy
    stat yy
    ```

    ```console
      File: yy
      Size: 0               Blocks: 0          IO Block: 4096   regular empty file
    Device: 253,0   Inode: 33956338    Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Context: unconfined_u:object_r:admin_home_t:s0
    Access: 2025-10-13 16:58:31.595943856 +0800
    Modify: 2025-10-13 16:58:31.595943856 +0800
    Change: 2025-10-13 16:58:31.595943856 +0800
    Birth: 2025-10-13 16:55:27.973193479 +0800
    ```

    可以看到选项 `-c` 同时更新文件的三个时间戳。

4. 更新文件的指定时间

    ```shell
    touch -t 201105011200.30 yy
    stat yy
    ```

    ```console
      File: yy
      Size: 0               Blocks: 0          IO Block: 4096   regular empty file
    Device: 253,0   Inode: 33956338    Links: 1
    Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
    Context: unconfined_u:object_r:admin_home_t:s0
    Access: 2011-05-01 12:00:30.000000000 +0800
    Modify: 2011-05-01 12:00:30.000000000 +0800
    Change: 2025-10-13 16:58:56.228195430 +0800
    Birth: 2025-10-13 16:55:27.973193479 +0800
    ```

    可以看到选项 `-t` 来设置文件的访问时间和修改时间为指定的时间戳。同时，它也显示了状态改变时间（ctime）会在更新文件时间戳时被自动更新，因为更改文件的时间戳被视为对文件元数据的修改。而文件的创建时间（birthtime）在这个过程中保持不变。

## rmdir（删除空目录）

和 `mkdir` 命令（创建空目录）恰好相反，`rmdir` 命令用于删除空目录，如果目录中有任何文件或子目录，`rmdir` 将无法删除该目录。这个命令的名称来自 Remove directory。

```shell
rmdir [OPTION]... DIRECTORY...
```

| 常见选项 | 功能说明                                                                       |
| -------- | ------------------------------------------------------------------------------ |
| `-p`     | 删除指定的父目录。如果指定了多个目录，也将递归地删除每个目录以及所有空的父目录 |

| 参数        | 功能说明                                                                       |
| ----------- | ------------------------------------------------------------------------------ |
| `DIRECTORY` | 想要删除的一个或多个目录的名称，可以是单个目录名，也可以是包含多个子目录的路径 |

1. 删除空目录

    ```bash
    rmdir linux
    ls
    ```

    ```console
    A  anaconda-ks.cfg  testdir
    ```

    可以看到空目录 `linux` 已经被删除了，但是 `rmdir` 命令的作用十分有限，因为只能刪除空目录。

    假设目录中存在一个文件：

    ```bash
    touch testdir/1.txt
    tree testdir/
    ```

    ```console
    testdir/
    └── 1.txt

    1 directory, 1 file
    ```

    当删除这个目录时，由于目录中有内容，就会报错：

    ```bash
    rmdir testdir
    ```

    ```console
    rmdir: failed to remove 'testdir': Directory not empty
    ```

2. 递归删除目录及其空父目录

    同样 `rmdir` 命令可以使用 `-p` 选项递归删除目录。例如：

    ```bash
    rmdir -p A/B/C/D
    tree
    ```

    ```console
    .
    ├── anaconda-ks.cfg
    └── testdir
        └── 1.txt

    2 directories, 2 files
    ```

## rm（删除文件或目录）

`rm` 命令是 Linux 系统中用于删除文件和目录，它可以永久性地删除文件系统中指定的文件或目录。相对比较 `rmdir` 命令，`rm` 命令更加灵活，可以删除文件和目录。

```shell
rm [OPTION]... [FILE]...
```

| 常见选项 | 功能说明                                                     |
| -------- | ------------------------------------------------------------ |
| `-f`     | 强制删除，系统将不再询问，而是直接删除目标文件或目录         |
| `-i`     | 交互模式，在删除文件之前提示用户确认                         |
| `-r/R`   | 递归删除目录及其内容，将指定目录下的所有文件与子目录一并处理 |

| 参数   | 功能说明                                                                     |
| ------ | ---------------------------------------------------------------------------- |
| `FILE` | 表示可以指定一个或多个文件或目录作为命令的目标。这些是将要被删除的文件或目录 |

> [!WARNING]
> 在使用 `rm` 命令时，务必要非常小心，因为一旦文件被删除，通常就无法恢复。在执行删除操作之前，建议再次检查文件内容，以确保这是真正想要删除的文件。

1. 删除文件

    `rm` 命令默认执行的是 `rm -i` 的别名，所以每次删除文件之前用户会被提示确认，从而避免意外删除重要文件：

    ```bash
    rm lastlog
    ```

    ```console
    rm: remove regular file 'lastlog'? y
    ```

2. 删除目录

    如果需要删除目录，则需要使用 `-r` 选项。例如：

    ```bash
    rm -r test_dir/
    ```

    ```console
    rm: descend into directory 'test_dir/'? y
    rm: remove regular file 'test_dir/test_file.txt'? y
    rm: remove directory 'test_dir/'? y
    ```

    可以看到 `rm -r` 命令会分别询问是否进入子目录、是否删除子目录。

3. 强制删除

    在实际操作中，如果需要删除包含大量子目录或文件的目录，使用普通的 `rm` 命令可能会非常耗时，因为它会要求用户对每个子目录或文件进行确认。因此，为了简化操作，通常会选择使用强制删除选项。例如：

    ```bash
    rm -rf *
    ```

    `*` 是通配符，表示匹配当前目录下的所有文件。这个命令含义就是忽略用户输入，直接删除当前目录下所有的文件和目录。

    启用强制删除功能后，可以显著加快删除过程。然而，需要注意的是，一旦执行了强制删除操作，数据将无法恢复，除非借助于专业的数据恢复工具，如 extundelete 等。但即便如此，数据恢复的成功率通常不高，一般而言，能够恢复 70% 到 80% 的数据已经算是相当理想的结果。因此，与其依赖于不可靠的数据恢复手段，不如培养良好的操作习惯，以预防数据丢失的风险。

> [!CAUTION]
> `rm -rf /*` 是一个在技术社区和社交媒体中经常被调侃的命令，但实际上这是一个极其危险的操作。这个命令会尝试删除根目录 `/` 下的所有文件和目录，包括操作系统文件、用户数据和配置文件等，这可能会导致系统完全无法使用。

## ln（建立链接文件）

`ln` 命令用于创建文件和目录的链接。为了充分理解 `ln` 命令的工作原理和用途，了解文件系统中的 inode 和 block 概念是非常重要的。

---

> [!TIP] 理解 inode 要从文件存储说起
> 文件在硬盘上的存储方式是分层的，从最小的存储单位开始，称为「扇区」（Sector）。每个扇区通常存储 512 字节，或者 0.5 千字节（KB）。由于单独处理每个扇区效率较低，操作系统在读取硬盘时采用了更大的单位，即「块」（Block）。这种由多个扇区组成的「块」，是文件系统中数据存取的基本单位。
>
> 「块」的大小对于现代硬盘来说，常见的是 4KB，这意味着一个块通常由连续的 8 个扇区组成。这种块的大小可以根据不同文件系统的设计和性能需求而变化，有的文件系统可能使用更大的块大小，例如 8KB 或更大。
>
> 文件系统将硬盘上的空间划分为一个个块，并将文件存储在这些块中。当文件太大而无法完全放入一个块时，它会分散存储在多个块中。文件系统中的块可以是连续的，也可以是不连续的，这取决于文件系统的块分配策略。
>
> 为了有效管理这些块和它们所存储的文件，文件系统引入了「索引节点」（inode）的概念。每个文件或目录都对应一个唯一的 inode，它包含了文件的元数据，如权限、所有者、大小、时间戳等。inode 中还包含了指向存储文件数据的块的指针。

inode（索引节点）是文件系统中用于存储文件元数据的数据结构。每个文件和目录在文件系统中都有一个对应的 inode，它包含了文件系统所需的所有信息，以管理和识别文件，但不包括文件名本身（文件名存储在目录结构中）。

inode 的组成：

- **文件权限**：定义了文件的所有者、组和其他用户的读、写和执行权限
- **所有者和组**：文件的所有者用户 ID 和组 ID
- **文件大小**：文件的当前大小
- **时间戳**：包括访问时间（atime）、修改时间（mtime）和状态改变时间（ctime）
- **块指针**：指向文件数据所在的磁盘块的指针。这些指针根据文件大小和存储需求的不同，可以是直接指针、间接指针、双重间接指针或三重间接指针
- **inode 编号**：一个唯一的标识符，用于在文件系统中唯一标识一个文件或目录
- **文件类型**：标识文件是普通文件、目录、链接等

> [!IMPORTANT]
> 在 Linux 系统中，文件和目录都由 inode（索引节点）进行管理，但 inode 本身并不存储文件名。文件名实际上存储在目录中，而目录本身也是一种特殊的文件。当查看目录内容时，实际上是在查看目录文件中包含的文件名列表。
>
> 当使用 `cd` 命令跳转到一个目录时，实际上是在改变当前工作目录的路径。然后，使用 `ls` 命令可以列出当前目录文件中的文件名。这些文件名指向目录中的 inode 条目，每个 inode 都有一个唯一的编号，系统使用这个编号来识别和管理文件。
>
> 对于用户来说，文件名是 inode 编号的友好表示，它使得用户能够更容易地识别和引用文件。系统内部并不直接使用文件名，而是通过 inode 编号来访问和管理文件的数据。这种机制允许文件系统在保持文件名的灵活性的同时，确保文件的高效管理和访问。

block（块）是文件系统中用于存储实际数据的基本单位。文件的数据被分成多个块，每个块都有一个唯一的编号。块的大小通常是 4KB，但可以根据文件系统的配置进行调整。

block 的组成和作用：

- **数据存储**：文件系统中的存储空间被分成固定大小的块，每个块可以存储一定数量的数据。当文件被创建时，文件系统会为文件分配一个或多个块来存储文件数据
- **块大小**：块的大小可以是 512 字节、1KB、2KB、4KB 等，取决于文件系统和磁盘的配置。块的大小决定了文件系统中可以存储的最大文件大小和文件的存储效率
- **块指针**：在 inode 中，块指针用于指向文件数据所在的块。小文件可能只需要直接指针，而大文件可能需要间接指针或多级间接指针来索引更多的块
- **块分配**：文件系统使用各种算法来管理块的分配和回收，确保文件数据可以有效地存储和检索

当创建一个文件时，文件系统会分配一个 inode 和若干个数据块。inode 存储文件的元数据，并包含指向数据块的指针。通过这些指针，文件系统可以找到并读取文件的实际数据。

---

```shell
 ln [OPTION]... TARGET... DIRECTORY
```

| 常见选项 | 功能说明                                         |
| -------- | ------------------------------------------------ |
| `-s`     | 创建软链接（符号链接）                           |
| `-v`     | 详细模式，在创建链接时显示额外的信息             |
| `-f`     | 强制执行，如果目标文件已存在，先删除它           |
| `-b`     | 备份模式，如果目标文件已存在，为其创建一个备份   |
| `-i`     | 交互模式，如果目标文件已存在，会提示用户是否覆盖 |
| `-t`     | 指定链接的目标目录，通常与多个目标一起使用       |

*默认情况下，`ln` 命令会创建硬链接。如果想创建软链接（符号链接），需要使用 `-s` 选项。*

| 参数        | 功能说明                                                                       |
| ----------- | ------------------------------------------------------------------------------ |
| `TARGET`    | 链接的源文件或目录。它可以是一个文件或多个文件或目录的路径。也就是要链接的对象 |
| `DIRECTORY` | 链接放置的目标目录。它是链接文件或目录的存放位置。也就是创建链接的名称         |

### 硬链接

硬链接是文件的另一个名称，它们共享相同的 inode。硬链接只能在同一个文件系统或分区中创建。一个文件可以有一个或多个硬链接。通常情况下，每个 inode 对应一个文件名，但 Linux 允许多个文件名指向同一个 inode 。这意味着可以使用不同的文件名访问相同的内容。

硬链接的特点：

- **共享数据块**：硬链接指向的是文件的数据块，而不是文件名或 inode 号码。因此，即使文件的一个链接被删除，只要还有其他硬链接存在，文件的数据块就不会被删除，文件内容仍然可以被访问
- **删除行为**：当删除一个硬链接时，文件的链接数会减少 1。只有当文件的链接数减少到 0 时，文件的数据块才会被删除，文件内容才会被释放
- **独立文件名**：每个硬链接都有自己独立的文件名，但它们都指向同一个 inode。因此，对任何一个硬链接的修改都会影响到其他所有硬链接，因为它们本质上是同一个文件

```shell
ln 源文件 目标文件
```

运行该命令后，源文件与目标文件的 inode 相同，都指向同一个 inode。此时，inode 信息中的链接数会增加 1。

当一个文件拥有多个硬链接时，对文件内容的修改会影响所有文件名；但是删除一个文件名，不会影响另一个文件名的访问。删除一个文件名只会使 inode 中的链接数减 1。

> [!WARNING]
> 不能对目录创建硬链接。硬链接只能用于文件，而不能用于目录。这是因为硬链接会导致文件系统的循环引用问题，从而使文件系统变得复杂和不稳定。
>
> 硬链接不能跨越不同的文件系统。硬链接是通过文件的 inode 号码来实现的，而 inode 是文件系统级别的概念。不同的文件系统可能有不同的结构和 inode 实现，因此无法确保硬链接在不同文件系统间的一致性和有效性。

通过 `mkdir` 命令创建一个新目录，其硬链接数应该有 2 个，因为目录本身有 1 个硬链接，而目录下的隐藏目录 `.` 是该目录的另一个硬链接，也算作 1 个硬链接。

```bash
mkdir /oldboy
ls -ld /oldboy/
```

```console
drwxr-xr-x. 2 root root 6 Sep 20 11:14 /oldboy/
```

```bash
ls -al /oldboy/
```

```console
total 0
drwxr-xr-x.  2 root root   6 Sep 20 11:14 .
dr-xr-xr-x. 19 root root 249 Sep 20 11:14 ..
```

`..` 表示父目录，`/oldboy/` 目录的父目录是根目录 `/`，这表示根目录 `/` 中有 18 个子目录，再加上根目录本身，总共有 19 个硬链接。

如果目标文件被删除，硬链接仍然有效。这是因为硬链接和目标文件共享同一个 inode，它们指向的是相同的数据块。每个硬链接都像是目标文件的一个独立的名称，但它们实际上访问的是同一块磁盘空间。

创建一个名为 original.txt 的文件：

```bash
echo "hello,linux!" > original.txt
cat original.txt
```

```console
hello,linux!
```

> [!TIP] echo
> `echo` 命令用于将字符串写入标准输出，配合 `>` 重定向输出到文件，可以实现创建文件并写入内容。在 Shell 章节会介绍。

然后为 original.txt 创建一个硬链接 link.txt：

```bash
ln original.txt link.txt
```

可以使用参数 `-i` 查看文件的 inode 号：

```bash
ls -il original.txt link.txt
```

```console
34134659 -rw-r--r--. 2 root root 13 Sep 20 22:39 link.txt
34134659 -rw-r--r--. 2 root root 13 Sep 20 22:39 original.txt
```

可以看到 original.txt 和 link.txt 文件都有相同的权限 (-rw-r--r--)，相同的所有者 (root)，相同的组 (root)，相同的大小 (13 字节），并且它们指向相同的 inode 号码 (34134659)。这表明它们是硬链接。

此时，original.txt 和 link.txt 是两个不同的文件名，但它们指向同一个 inode 和同一块数据。如果删除了 original.txt，link.txt 仍然可以访问文件内容，因为 link.txt 仍然是指向相同数据块的有效链接。

```bash
rm -f original.txt
cat link.txt 
```

```console
hello,linux!
```

>[!IMPORTANT] rm 与 inode 关系
> 在 Linux 文件系统中，`rm` 命令的本质不是直接删除文件的实际数据，而是删除文件名与 inode 的关联关系，并减少 inode 的链接数（link count）。只有当 inode 的链接计数减到 0，且没有进程正在打开该文件（即没有进程持有该文件的文件描述符）时，内核才会将这个 inode 标记为未使用，并在后续的磁盘空间回收中释放它所占用的资源（包括 inode 本身和对应的数据块）。
>
> 所以当执行 `rm original.txt` 时：
>
> 1. 删除文件 original.txt 的文件名，并减少 original.txt 的链接数（即解除它与 inode 的关联）
> 2. 同时，inode 的链接计数会减 1（从 2 变成 1）
>
> 此时，虽然 original.txt 这个名字消失了，但 link.txt 仍然指向该 inode（链接计数为 1，不为 0）。由于 inode 仍然被引用（有文件名指向它），系统不会删除 inode 及对应的数据块，因为数据还有用。
>
> 只有当 inode 的链接计数减到 0 时（即没有任何文件名指向它），系统才会认为这个 inode 和对应的数据块 “无用”，并在后续的磁盘清理中真正释放它们所占用的空间。

### 软链接

软链接也称为符号链接，是将一个路径名链接到一个文件。实际上，软链接只是一个文本文件，其中包含它提供链接的另一个文件的路径名（另一个文件是实际包含所有数据的文件）。所有读、写文件内容的命令被用于软链接时，将沿着链接方向前进来访问实际的文件。类似于 Windows 的快捷方式，可以快速链接到目标文件或目录。

软链接（符号链接）与硬链接不同，它是一个全新的文件，具有自己的 inode 号码。软链接包含了目标文件或目录的路径，而不是直接指向它们的 inode。这给了软链接一些独特的特性：

- **跨文件系统**：软链接可以跨越不同的文件系统，因为它们通过路径引用目标，而不是通过 inode
- **链接目录**：软链接可以链接到目录，而硬链接则不能链接到目录
- **路径引用**：软链接包含了目标文件或目录的路径。当系统尝试访问软链接时，它会跟随链接中的路径找到实际的目标文件或目录
- **独立文件**：软链接本身是一个独立的文件，拥有自己的 inode。这意味着软链接可以被删除或移动，而不会影响目标文件
- **易碎性**：如果目标文件被移动或删除，软链接会变成「悬空」的，不再指向一个有效的目标，这被称为「断链」

创建软链接时，建议使用绝对路径，这样可以确保从任何工作目录下都能正确找到目标文件。如果使用相对路径，软链接将基于当前工作目录的位置来解析，这可能会导致在不同目录下无法正确访问目标。

创建名为 example.txt 的文件，然后再创建一个指向它的软链接 symbolic_link.txt：

```bash
touch example.txt
```

```bash
ln -s example.txt symbolic_link.txt
```

```bash
ls -l symbolic_link.txt
```

```console
lrwxrwxrwx. 1 root root 11 Sep 20 22:53 symbolic_link.txt -> example.txt
```

> [NOTE]
> Linux 中，符号链接的权限位（rwx）是没有实际意义的，系统会完全忽略这些权限。无论显示什么权限，都不影响对链接的访问。默认显示 `rwxrwxrwx`，是因为符号链接的核心作用是指向的目标文件，系统设计时让它的权限不参与权限判断，所以干脆默认显示为全权限，避免用户误解它的权限会生效。

可以看到 symbolic_link.txt 显示为一个指向 example.txt 的软链接。现在，如果删除 example.txt 文件：

```bash
rm -f example.txt
```

```bash
ls -l symbolic_link.txt
```

```console
lrwxrwxrwx. 1 root root 11 Sep 20 22:53 symbolic_link.txt -> example.txt
```

```bash
cat symbolic_link.txt 
```

```console
cat: symbolic_link.txt: No such file or directory
```

虽然还是能看到软链接，但是颜色变成了红色，说明软链接已经变成了「悬空」的链接，即它指向的目标文件不再存在。当尝试访问空链接 link.txt 将会失败，因为 example.txt 不再存在。

## cp（复制文件和目录）

`cp` 命令用于复制文件和目录的常用工具。它不仅能够复制单个文件，还能够通过递归选项复制整个目录结构。此外，`cp` 命令提供了多种选项来控制复制过程。

```shell
cp [OPTION]... SOURCE... DIRECTORY
```

| 常见选项 | 作用                                                                                       |
| -------- | ------------------------------------------------------------------------------------------ |
| `-a`     | 归档模式，递归复制目录及其内容，并保留文件的属性（如权限、时间戳等）                       |
| `-f`     | 强制覆盖，在​​目标文件不可写​​时尝试删除后复制                                             |
| `-i`     | 交互模式，在覆盖文件之前提示用户确认                                                       |
| `-r/R`   | 递归复制目录及其内容。如果目录中包含软链接，默认情况下会复制软链接本身，而不是它指向的目标 |
| `-b`     | 在覆盖文件之前创建备份                                                                     |
| `-d`     | 复制软链接本身，而不是它指向的目标                                                         |
| `-L`     | 复制软链接指向的目标，而不是软链接本身                                                     |
| `-l`     | 创建硬链接而不是复制文件。硬链接是指向同一文件数据的多个目录项                             |
| `-s`     | 创建软链接而不是复制文件。软链接是指向另一个文件或目录的路径                               |
| `-p`     | 复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）                           |
| `-u`     | 仅当源文件比目标文件新，或者目标文件不存在时，才复制文件                                   |

> [!TIP] 归档模式
> 核心作用是尽可能完整地复制文件或目录，包括其所有属性、结构和关联信息，就像打包归档一样保留原始数据的所有特征。专为「需要精确复制」的场景设计，最常见的是备份文件或目录。因为它能保证复制后的文件 `/` 目录与原始内容几乎完全一致，包括结构、链接关系和所有属性，不会丢失任何关键信息。

| 参数        | 作用                                                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `SOURCE`    | 一个或多个要复制的源文件或目录的名称。默认情况下，`cp` 命令不能复制目录，如果要复制目录，则必须使用 `-r` 选项      |
| `DIRECTORY` | 指定目标文件。当源文件为多个文件时，要求目标文件为指定的目录，且目录必须已存在。如果目录不存在，系统会显示出错信息 |

1. 复制文件

    把 `/etc/passwd` 文件不改名复制到 `/opt/` 目录下：

    ```bash
    cp /etc/passwd /opt/
    ```

    如果需要改名复制，需要补充文件名即可：

    ```bash
    cp /etc/passwd /opt/passwd.bak
    ```

    ```bash
    ls /opt/
    ```

    ```console
    passwd  passwd.bak
    ```

    > [!WARNING]
    > 所有目标文件指定的目录必须是己经存在的，`cp` 命令不能创建目录。如果没有文件复制的权限，则系统会显示出错信息。

    如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 `cp` 命令默认执行的是 `cp -i` 的别名，例如：

    ```bash
    cp /etc/passwd /opt/
    ```

    ```console
    cp: overwrite '/opt/passwd'? 
    ```

2. 复制目录

    复制目录只需使用 `-r` 选项即可，例如，将目录 `/etc/ssh/` 下的所有文件及其子目录复制到目录 `/opt/` 中：

    ```bash
    cp -r /etc/ssh/ /opt/
    ```

    但是如果需要覆盖一些同名文件，覆盖文件的时候都会有提示，需要输入 `y` 来确定执行覆盖：

    ```bash
    cp -r /etc/ssh/ /opt/
    ```

    ```console
    cp: overwrite '/opt/ssh/ssh_host_rsa_key'? y
    cp: overwrite '/opt/ssh/ssh_host_rsa_key.pub'? y
    cp: overwrite '/opt/ssh/moduli'? y
    cp: overwrite '/opt/ssh/ssh_config'? y
    cp: overwrite '/opt/ssh/sshd_config'? y
    cp: overwrite '/opt/ssh/ssh_host_ecdsa_key'? y
    cp: overwrite '/opt/ssh/ssh_host_ecdsa_key.pub'? y
    cp: overwrite '/opt/ssh/ssh_host_ed25519_key'? y
    cp: overwrite '/opt/ssh/ssh_host_ed25519_key.pub'? y
    cp: overwrite '/opt/ssh/sshd_config.d/50-redhat.conf'? y
    cp: overwrite '/opt/ssh/sshd_config.d/01-permitrootlogin.conf'? y
    cp: overwrite '/opt/ssh/ssh_config.d/50-redhat.conf'? y
    ```

    这是因为系统中默认给 `cp` 命令设置了别名 `alias cp='cp -i'`：

    ```bash
    alias cp
    ```

    ```console
    alias cp='cp -i'
    ```

    所以当执行 `cp -r /etc/ssh/ /opt/` 时，系统会先解析默认别名，实际执行的命令是：

    ```bash
    cp -i -r /etc/ssh/ /opt/
    ```

    所以可以通过反斜杠用作转义字符，它可以取消特殊字符（如 `cp` 命令中的 `-i` 选项）的含义：

    ```bash
    \cp -r /etc/ssh/ /opt/
    ```

    除此自外，还可以使用 `unalias cp` 命令来临时取消 `cp` 命令的别名，然后再次运行：

    ```bash
    unalias cp
    cp -r /etc/ssh/ /opt/
    ```

    > [!WARNING] -f 选项
    > `cp` 命令中的 `-f` 和 `rm` 命令的选项 `-f` 是不同的。
    >
    > `cp` 命令中的 `-f` 选项定义是：​​如果无法直接打开目标文件进行写入，则先删除它再复制​。不是用来跳过交互式提示的​​，而是用来处理 ​​文件写入权限问题​​。

3. 复制软链接

    如果源文件是一个软链接文件，默认情况下 `cp` 命令会复制软链接指向的目标文件内容，而不是软链接本身。这意味着在目标位置会创建一个新的文件，内容与软链接指向的文件相同。

    建立一个测试文件 `link.md`，然后使用创建该文件的软链接 `/tmp/new_link.md`：

    ```bash
    touch link.md
    ln -s /root/link.md /tmp/new_link.md
    ll /tmp/new_link.md 
    ```

    ```console
    lrwxrwxrwx. 1 root root 13 Sep 22 19:11 /tmp/new_link.md -> /root/link.md
    ```

    然后使用 `cp` 命令复制 `/tmp/new_link.md` 这个软链接：

    ```bash
    cp /tmp/new_link.md /tmp/new_link1.md 
    ll /tmp/new_link1.md 
    ```

    ```console
    -rw-r--r--. 1 root root 0 Sep 22 19:14 /tmp/new_link1.md
    ```

    可以看到 `/tmp/new_link1.md` 是一个新的文件，而不是链接符号。如果想要复制软链接本身，而不是它指向的目标文件，可以使用 `-d` 选项：

    ```bash
    cp -d /tmp/new_link.md /tmp/new_link2.md 
    ll /tmp/new_link2.md 
    ```

    ```console
    lrwxrwxrwx. 1 root root 13 Sep 22 19:23 /tmp/new_link2.md -> /root/link.md
    ```

    这样，`/tmp/new_link2.md` 将会是一个新的软链接，指向 `/root/link.md`。

4. 复制软链接（目录）

    如果软链接是目录的话，就需要添加 `-r` 选项，所以当使用 `cp -r` 选项复制软链接目录时，默认情况下会复制软链接本身，而不是它指向的实际目录。

    首先，创建一个测试目录和文件：

    ```bash
    mkdir test_dir
    echo "Hello, this is a test file" > test_dir/test_file.txt
    ```

    再创建一个指向它的软链接：

    ```bash
    ln -s /root/test_dir /opt/test_link
    ll /opt/test_link
    ```

    ```console
    lrwxrwxrwx. 1 root root 14 Sep 22 18:30 /opt/test_link -> /root/test_dir
    ```

    ```bash
    cat /opt/test_link/test_file.txt
    ```

    ```console
    Hello, this is a test file
    ```

    > [!WARNING]
    > 这里创建软链接的时候要使用绝对路径 `/root/test_dir`，否则复制软链接会无法找到源目录。

    可以看到复制后的目录是软链接，而不是实际的目录。如果只是想要复制实际的目录，而不是软链接本身，那么就可以使用 `-L` 选项：

    ```bash
    cp -rL /opt/test_link/ /opt/test_link1/
    ll /opt/
    ```

    ```console
    lrwxrwxrwx. 1 root root 14 Sep 22 20:01 test_link -> /root/test_dir
    drwxr-xr-x. 2 root root 27 Sep 22 20:03 test_link1
    ```

    这样，`cp` 会递归复制软链接指向的实际目录及其内容，而不是复制软链接本身。

5. 保留源文件属性复制

    默认情况下，在执行复制命令后，目标文件的时间戳、所有者和用户组都会发生改变：

    ```bash
    ll /var/log/lastlog
    ```

    ```console
    -rw-rw-r--. 1 root utmp 292292 Oct 14 15:03 /var/log/lastlog
    ```

    ```bash
    cp /var/log/lastlog /root/
    ll /var/log/lastlog /root/lastlog 
    ```

    ```console
    -rw-r--r--. 1 root root 292292 Oct 14 15:03 /root/lastlog
    -rw-rw-r--. 1 root utmp 292292 Oct 14 15:03 /var/log/lastlog
    ```

    由于复制命令由 root 用户执行，所以目标文件的所属组为了 root，而且时间也变成了复制命令的执行时间。而当执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 `-p` 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如：

    ```bash
    cp -p /var/log/lastlog /root/lastlog.bak
    ll /var/log/lastlog /root/lastlog /root/lastlog.bak
    ```

    ```console
    -rw-r--r--. 1 root root 292292 Oct 14 15:03 /root/lastlog
    -rw-rw-r--. 1 root utmp 292292 Oct 14 15:03 /root/lastlog.bak
    -rw-rw-r--. 1 root utmp 292292 Oct 14 15:03 /var/log/lastlog
    ```

    源文件和目标文件的所有属性都一致，包括时间、所有者和用户组。

## mv（移动或重命名文件和目录）

`mv` 命令是 Linux 系统中用于移动或重命名文件和目录。

```shell
mv [OPTION]... SOURCE... DIRECTORY
```

| 常见选项 | 功能说明                                                   |
| -------- | ---------------------------------------------------------- |
| `-f`     | 强制移动，如果目标文件已经存在，则不询问，直接强制覆盖     |
| `-i`     | 交互模式，如果目标位置已存在文件，会提示用户是否覆盖       |
| `-n`     | 如果目标文件已经存在，则不会覆盖移动，而且不询问用户       |
| `-u`     | 如果源文件比目标文件新，或者目标文件不存在，则执行移动操作 |

| 参数        | 功能说明                                                     |
| ----------- | ------------------------------------------------------------ |
| `SOURCE`    | 表示一个或多个源文件或目录，这些是要移动或重命名的文件或目录 |
| `DIRECTORY` | 目标目录，这是要将源文件或目录移动到的位置                   |

> [!WARNING]
> 正如 `rm` 命令，`mv` 命令也是一个功能强大的工具，但如果使用不当，也可能对系统造成严重破坏。虽然 mv 主要用于移动或重命名文件和目录，但若操作失误，比如错误地将重要文件移动到了不适当的位置或覆盖了关键数据，同样可能导致数据丢失或系统功能受损。

1. 移动文件和目录

    ```bash
    touch file1.txt file2.txt
    ls
    ```

    ```console
    file1.txt  file2.txt
    ```

    ```bash
    mv file1.txt file2.txt /opt/
    ls /opt/
    ```

    ```console
    file1.txt  file2.txt
    ```

    `mv` 也可以移动目录，但和 `rm`、`cp` 不同的是，`mv` 移动目录不需要加入 `-r` 选项，如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 `mv` 命令默认执行的也是 `mv -i` 的别名，例如：

    ```bash
    mkdir test
    mkdir /opt/test
    ```

    ```bash
    mv test/ /opt/
    ```

    ```console
    mv: overwrite '/opt/test'? y
    ```

2. 强制移动

    当目标目录中已存在同名文件时，`mv` 命令默认会提示用户是否覆盖现有文件，这需要用户逐一进行确认。如果存在大量同名文件需要移动，这一过程可能会变得繁琐。

    为了简化操作，可以利用 `-f` 选项来强制移动文件，从而避免逐一确认的步骤。使用 `-f` 选项后，`mv` 命令将自动覆盖目标目录中存在的同名文件，而不再提示用户确认：

    ```shell
    mv -f test/ /opt/
    ```

3. 不覆盖移动

    尽管 `mv` 命令提供了强制覆盖移动的功能，但在某些情况下，可能希望保留目标目录中已存在的同名文件。例如，当需要移动大量文件到一个目录，但同时希望避免覆盖任何现有文件时，可以使用 `-n` 选项，`mv` 命令将跳过任何已存在于目标目录中的同名文件，从而确保现有数据的完整性。

    ```bash
    touch 1.md 2.md 3.md 4.md 5.md
    touch /opt/3.md /opt/4.md /opt/5.md
    ```

    ```bash
    mv -nv 1.md 2.md 3.md 4.md 5.md /opt/
    ```

    ```console
    renamed '1.md' -> '/opt/1.md'
    renamed '2.md' -> '/opt/2.md'
    ```

    `-v` 选项用于显示命令执行的详细过程，它可以帮助了解哪些文件被移动以及移动的结果。

4. 修改目录或文件名

    当源文件和目标文件在同一目录中时，使用 `mv` 命令实际上是在重命名文件：

    ```bash
    touch oldfilename.txt
    ls oldfilename.txt
    ```

    ```console
    oldfilename.txt
    ```

    ```bash
    mv oldfilename.txt newfilename.txt
    ls oldfilename.txt newfilename.txt
    ```

    ```console
    ls: cannot access 'oldfilename.txt': No such file or directory
    newfilename.txt
    ```

    这个命令将同一目录下的 oldfilename.txt 重命名为 newfilename.txt。

    `mv` 命令不仅可以用于重命名文件，还可以用来修改（重命名）目录名。操作方式与重命名文件类似，只需确保指定的是目录路径。

## tree（树状图列出目录）

tree 命令是 Linux 系统用于以树形结构显示目录内容的工具。它可以清晰地展示目录和文件之间的层次关系，就像一棵树的枝干（目录）和树叶（文件）一样。

> [!NOTE]
> 注意有的发行版默认没有安装 `tree` 命令的，例如 Rocky Linux 可以使用 DNF 包管理器来安装 `dnf -y install tree`

```shell
tree [OPTION]... FILE...
```

| 常见选项 | 功能说明                                                                                      |
| -------- | --------------------------------------------------------------------------------------------- |
| `-L`     | 用于指定显示的目录层次深度                                                                    |
| `-d`     | 只显示目录，不显示文件                                                                        |
| `-f`     | 显示完整的路径                                                                                |
| `-a`     | 显示所有文件和目录，包括隐藏文件。如果不使用这个选项，`tree` 命令默认是不显示隐藏文件和目录的 |
| `-s`     | 显示每个文件或目录的大小                                                                      |

| 参数   | 功能说明                                                                          |
| ------ | --------------------------------------------------------------------------------- |
| `FILE` | 表示是要显示树形结构的目录，如果不指定目录路径，tree 命令默认会从当前目录开始显示 |

1. 显示当前目录结构

    ```bash
    tree
    ```

    ```console
    .
    └── anaconda-ks.cfg
    ```

2. 显示指定目录结构

    ```bash
    tree /etc/ssh/
    ```

    ```console
    /etc/ssh/
    ├── moduli
    ├── ssh_config
    ├── ssh_config.d
    │   └── 50-redhat.conf
    ├── ssh_host_ecdsa_key
    ├── ssh_host_ecdsa_key.pub
    ├── ssh_host_ed25519_key
    ├── ssh_host_ed25519_key.pub
    ├── ssh_host_rsa_key
    ├── ssh_host_rsa_key.pub
    ├── sshd_config
    └── sshd_config.d
        ├── 01-permitrootlogin.conf
        └── 50-redhat.conf
    ```

3. 限制显示深度

    ```bash
    tree -L 1 /usr/local/
    ```

    ```console
    /usr/local/
    ├── bin
    ├── etc
    ├── games
    ├── include
    ├── lib
    ├── lib64
    ├── libexec
    ├── sbin
    ├── share
    └── src
    ```

    这将只显示指定目录下的第一级子目录和文件。

4. 显示隐藏文件：

    ```bash
    tree -a 
    ```

    ```console
    .
    ├── .bash_history
    ├── .bash_logout
    ├── .bash_profile
    ├── .bashrc
    ├── .cshrc
    ├── .lesshst
    ├── .ssh
    ├── .tcshrc
    ├── .vim
    │   └── autoload
    └── anaconda-ks.cfg
    ```

## find（查找文件或目录）

find 是一个功能强大的 Linux 命令行工具，用于在文件系统中搜索和查找文件或目录。它可以根据多种条件（如文件名、大小、类型、权限、时间戳等）进行搜索，并且可以结合其他命令进行复杂的文件操作。

```shell
find [options] [path...] [expression]
```

- `options`：控制 `find` 命令的​​全局行为​（如符号链接处理），必须放在最开头
- `path`：指定搜索的起始目录，可多个路径。默认值为当前目录
- `expression`：文档核心，由「表达式选项 + 测试条件 + 操作符 + 动作」组成，用于筛选文件并执行操作

### 选项（Options）​

`find` 的选项分为​​全局选项​​和​​表达式选项​​。

全局选项控制 `find` 的全局行为，如符号链接处理、调试模式等，它们本身不是测试条件，不会影响文件的匹配结果。注意，全局选项必须放在命令的最开头（在 `path` 和 `expression` 之前）。

| 选项           | 功能说明                                                                                                                                       |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `-H`           | 不跟随符号链接（默认行为）                                                                                                                     |
| `-L`           | 跟随符号链接（解析链接指向的实际文件）。若链接指向上级目录（如 `link -> ..`），会导致无限循环，需谨慎                                          |
| `-P`           | 明确不跟随符号链接（同 `-H`，仅为兼容性保留）                                                                                                  |
| `-D debugopts` | 启用调试模式（如 `-D exec` 显示 `-exec` 执行的具体命令，`-D tree` 显示搜索树）                                                                 |
| `-Olevel`      | 设置优化级别（0 = 不优化；1 = 默认；2 = 优化路径；3 = 深度优化）。搜索大量文件时，`-O3` 可提升效率，但复杂表达式可能影响结果，建议默认用 `-O1` |

例如，`/bin` 是一个符号链接，使用 `find` 命令默认不会搜索符号链接指向的实际文件：

```bash
ls -l /bin
```

```console
lrwxrwxrwx. 1 root root 7 Oct 29  2024 /bin -> usr/bin
```

```bash
find /bin  -name find
```

因为 `/bin` 是一个符号链接，而 `find` 命令默认不搜索符号链接，所以命令不会返回任何结果，当加上 `-L` 选项后，`find` 命令会搜索符号链接指向的实际文件：

```bash
find -L /bin -name find
```

```console
/bin/find
```

可以看到，加上了选项`-L`，`find` 命令会搜索符号链接指向的实际文件，返回结果。

> [!WARNING]
> `-L` 选项会导致 `find` 命令递归搜索符号链接指向的目录，可能会导致无限循环。因此，在使用 `-L` 选项时，要确保搜索路径中不包含循环符号链接。

表达式选项属于表达式的一部分​​，通常出现在 `expression` 中，与测试条件、动作混合使用。用于限制搜索范围（如深度、文件系统边界等），部分选项（如 `-maxdepth`）会直接影响是否进入子目录。

| 选项                | 功能说明                                                                           |
| ------------------- | ---------------------------------------------------------------------------------- |
| `-maxdepth N`       | 最大搜索深度（N=0 表示仅当前路径；N=1 表示当前路径 + 1 级子目录）                  |
| `-mindepth N`       | 最小搜索深度（N=2 表示跳过当前路径和 1 级子目录，从 2 级开始搜索）                 |
| `-mount` 或 `-xdev` | 仅搜索当前文件系统，不跨挂载点，如避免从 / 搜索到 `/mnt/usb` 等外部设备            |
| `-daystart`         | 时间计算基准改为「当天 0 点」，默认基准是当前时间                                  |
| `-noleaf`           | 关闭「目录至少有 2 个节点（`.` 和 `..`）」的优化，适配非 Unix 文件系统（如 FAT32） |

例如，在 `/var` 目录下搜索以 `.log` 结尾的文件，并限制搜索深度为 2 层：

```bash
find /var -maxdepth 2 -name "*.log"
```

```console
/var/log/dnf.log
/var/log/dnf.librepo.log
/var/log/dnf.rpm.log
/var/log/test.log
/var/log/hawkey.log
```

### 测试条件（Tests）

文件名匹配：

| 测试条件            | 说明                                                                                  |
| ------------------- | ------------------------------------------------------------------------------------- |
| `-name "PATTERN"`   | 区分大小写，支持通配符（`*`= 任意字符；`?`= 单个字符；`[]`= 字符范围）                |
| `-iname "PATTERN"`  | 不区分大小写，功能同 `-name`                                                          |
| `-path "PATTERN"`   | 匹配完整路径（含目录），而非仅文件名                                                  |
| `-ipath "PATTERN"`  | 不区分大小写匹配完整路径                                                              |
| `-regex "PATTERN"`  | 用正则表达式匹配完整路径，默认是 Emacs 正则，需扩展正则加 `-regextype posix-extended` |
| `-iregex "PATTERN"` | 不区分大小写匹配正则表达式                                                            |

例如，查找 `/etc` 目录下的所有 `.conf` 文件：

```bash
find /etc -name "*.conf"  
```

```console
/etc/lvm/lvm.conf
……
```

查找 `/etc` 目录下所有 README、readme 等文件：

```bash
find /etc -iname "readme*" 
```

```console
/etc/pki/ca-trust/extracted/edk2/README
/etc/pki/ca-trust/extracted/java/README
/etc/pki/ca-trust/extracted/openssl/README
……
```

使用正则表达式匹配 `/var/log` 目录下所有以 `.log` 结尾的文件：

```bash
find /var/log -regex ".*\.log"
```

```console
/var/log/audit/audit.log
/var/log/anaconda/anaconda.log
/var/log/anaconda/program.log
/var/log/anaconda/packaging.log
```

文件类型​​：

| 测试条件  | 说明                         |
| --------- | ---------------------------- |
| `-type f` | 普通文件（文档、脚本等）     |
| `-type d` | 目录                         |
| `-type l` | 符号链接（不跟随原文件）     |
| `-type s` | 套接字文件（进程间通信）     |
| `-type p` | 管道文件（匿名管道）         |
| `-type b` | 块设备文件（磁盘、U 盘等）   |
| `-type c` | 字符设备文件（键盘、串口等） |

例如，查找所有块设备文件：

```bash
find /dev -type b
```

```console
[root@localhost ~]# find / -type b
/dev/nvme0n3
/dev/nvme0n2
……
```

查找家目录下所有目录：

```bash
find ~ -type d
```

```console
/root
/root/.ssh
/root/.config
/root/.config/procps
```

时间相关：​​

| 测试条件       | 说明                                      |
| -------------- | ----------------------------------------- |
| `-mtime N`     | 文件内容修改时间（N 天前）                |
| `-amin N`      | 文件内容修改时间（N 分钟前）              |
| `-atime N`     | 文件访问时间（N 天前）                    |
| `-ctime N`     | 文件状态（权限/所有者）修改时间（N 天前） |
| `-mmin N`      | 文件内容修改时间（N 分钟前）              |
| `-amin N`      | 文件访问时间（N 分钟前）                  |
| `-cmin N`      | 文件状态修改时间（N 分钟前）              |
| `-newer FILE`  | 比 FILE 更晚修改​​（即​​更新​​）的文件    |
| `-anewer FILE` | 比 FILE  ​更晚被访问的文件                |
| `-cnewer FILE` | 比 FILE ​​更晚变更状态​​的文件            |

​​时间单位说明​​：

- `+N`：超过 N 天/分钟
- `-N`：N 天/分钟以内
- `N`：正好 N 天/分钟

例如，查找 /var/log 目录下，修改时间小于 1 天的文件：

```bash
find /var/log -mtime -1
```

```console
/var/log/wtmp
/var/log/lastlog
/var/log/audit/audit.log
/var/log/cron
/var/log/messages
/var/log/secure
```

查找家目录下，最近 30 分钟内访问的文件：

```bash
find ~ -amin -30 
```

```console
/root
/root/.bash_profile
/root/.bashrc
/root/.bash_history
```

查找 `/etc` 目录下，比 `/etc/passwd` 文件更晚更新的文件：

```bash
find /etc -newer /etc/passwd
```

```console
/etc
/etc/lvm/devices
/etc/lvm/devices/system.devices
/etc/lvm/devices/backup
……
```

文件大小​：

| 测试条件        | 说明                                                                      |
| --------------- | ------------------------------------------------------------------------- |
| -size N[cwbkMG] | `c`= 字节，`w`= 字（2 字节），`b`= 块（512 字节），`k`=KB，`M`=MB，`G`=GB |

*`-size` 选项和 `-mtime`、-`atime` 等时间测试条件一样，也支持 `+N`、`-N` 和 `N` 三种形式，用于更灵活地匹配文件大小。*

例如，查找 / 目录下，大小 30M 的文件：

```bash
find / -size +100M
```

```console
find: ‘/proc/1762/task/1762/fd/6’: No such file or directory
find: ‘/proc/1762/task/1762/fdinfo/6’: No such file or directory
find: ‘/proc/1762/fd/5’: No such file or directory
find: ‘/proc/1762/fdinfo/5’: No such file or directory
/usr/lib/sysimage/rpm/rpmdb.sqlite
```

> [!TIP] No such file or directory
> 前面几行的错误信息是 `find` 命令在搜索过程中遇到的正常现象，​​并非命令本身有问题​​，而是由于 Linux 系统的 `/proc` 目录特性导致的。`/proc` 下的文件并非真实存储在磁盘上，而是内核动态生成的进程和系统信息，当 find 扫描到这些路径时，可能进程已退出，导致文件描述符失效，提示 `No such file or directory`（如果权限不足也报错）。

权限与用户​：

| 测试条件      | 说明                                                                                                                                  |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `-perm MODE`  | 精确匹配权限（ MODE 为 8 进制，如 644、755，必须完全一致），例如 `-perm 644` 仅匹配所有者读写、其他只读的文件                         |
| `-perm -MODE` | 匹配「包含 MODE 所有权限位」的文件，即至少有这些权限，例如 `-perm -644` 匹配 644、755 等文件，只要包含 `rw-r--r--` 的所有位           |
| `-perm /MODE` | 匹配「包含 MODE 任意一个权限位」的文件，即至少有一个权限符合，例如，`-perm /222` 匹配所有可写文件，所有者 / 组 / 其他任意一方有写权限 |
| `-user NAME`  | 按所有者查找，NAME = 用户名，UID = 用户 ID，如 `-user 1000`                                                                           |
| `-group NAME` | 按所属组查找，同 `-user`，支持组名或 GID                                                                                              |
| `-nouser`     | 无有效所有者的文件，如所有者被删除，但文件残留                                                                                        |
| `-nogroup`    | 无有效所属组的文件，同理，组被删除但文件残留                                                                                          |

查找家目录下，权限为 600 的文件：

```bash
find ~ -perm 600
```

```console
/root/anaconda-ks.cfg
/root/.bash_history
/root/.lesshst
/root/.viminfo
```

查找属于 alice 的文件：

```bash
find / -user alice
```

```console
find: ‘/proc/2462/task/2462/fd/6’: No such file or directory
find: ‘/proc/2462/task/2462/fdinfo/6’: No such file or directory
find: ‘/proc/2462/fd/5’: No such file or directory
find: ‘/proc/2462/fdinfo/5’: No such file or directory
/var/spool/mail/eva
/home/eva
/home/eva/.bash_logout
/home/eva/.bash_profile
/home/eva/.bashrc
/home/eva/.bash_history
```

其他测试条件​：

| 测试条件      | 说明                                                                           |
| ------------- | ------------------------------------------------------------------------------ |
| `-empty`      | 匹配空文件（大小 0 字节）或空目录（无任何子文件 / 子目录）                     |
| `-readable`   | 匹配当前用户可读取的文件（依赖执行 `find` 的用户权限）                         |
| `-writable`   | 匹配当前用户可写入的文件                                                       |
| `-executable` | 匹配当前用户可执行的文件 / 目录，目录的执行权限 = 进入权限                     |
| `-false`      | 永远返回 False，仅用于调试表达式逻辑，如 `find ~ -false -name "*.log"` 无结果  |
| `-true`       | 永远返回 True，匹配所有文件，如 `find ~ -true -type f` 等价于 `find ~ -type f` |

查找空文件：

```bash
find /opt -empty
```

查找可执行文件：

```bash
find ~ -executable
```

```console
/root
/root/.ssh
/root/.config
/root/.config/procps
/root/testdir
```

注意，`-executable` 选项匹配的是具有执行权限（`x`）的文件或目录，而不仅仅是可执行程序文件。如果只想查找可执行文件（排除目录），可以结合 `-type f` 选项：

```bash
find / -executable -type f
```

### 操作符（Operators）​

操作符用于组合多个测试条件。

| 操作符                                 | 说明                                                               |
| -------------------------------------- | ------------------------------------------------------------------ |
| `( EXPR )`                             | 分组（改变优先级），必须加反斜杠转义（`\( EXPR \)`）               |
| `! EXPR` 或 `-not EXPR`                | 逻辑非（取反）                                                     |
| `EXPR1 -a EXPR2` 或 `EXPR1 -and EXPR2` | 逻辑与（默认，可省略）                                             |
| `EXPR1 -o EXPR2` 或 `EXPR1 -or EXPR2`  | 逻辑或                                                             |
| `EXPR1 , EXPR2`                        | 先执行 EXPR1，再执行 EXPR2，最终返回 EXPR2 结果（忽略 EXPR1 结果） |

查找大于 1MB 且 7 天未修改的文件：

```bash
find / -type f -size +50M -a -mtime +7
```

```console
/boot/initramfs-0-rescue-75f8a7118c184e0e883b6e348a884a5c.img
find: ‘/proc/1578/task/1578/fdinfo/6’: No such file or directory
find: ‘/proc/1578/fdinfo/5’: No such file or directory
/usr/lib/locale/locale-archive
/usr/lib/locale/locale-archive.real
……
```

查找 `/etc` 目录下 `.conf` 或 `.log` 文件

```bash
find / \( -name "*.conf" -o -name "*.log" \)
```

```console
/etc/lvm/lvm.conf
/etc/lvm/lvmlocal.conf
……
```

### 动作（Actions）​

动作指定对匹配文件执行的操作。

| 动作                  | 说明                                                               |
| --------------------- | ------------------------------------------------------------------ |
| `-print`              | 打印匹配文件的路径（默认动作，可省略）                             |
| `-print0`             | 用「null 字符（\0）」分隔路径（解决文件名含空格 / 特殊字符的问题） |
| `-ls`                 | 以 `ls -dils` 格式显示文件详情（inode、权限、大小、时间、路径）    |
| `-delete`             | 删除匹配的文件（内置动作，不依赖外部命令）                         |
| `-exec COMMAND {} \;` | 对每个文件单独执行一次 COMMAND（`{}`= 文件名，`\;`= 命令结束）     |
| `-exec COMMAND {} +`  | 批量执行 COMMAND（所有文件一次性传给 COMMAND，减少进程创建）       |
| `-ok COMMAND {} \;`   | 交互式执行 COMMAND（每个文件都需手动输入 `y` 确认，避免误操作）    |
| `-prune`              | 跳过指定目录（不进入该目录搜索，需配合 `-type d` 使用）            |
| `-quit`               | 找到第一个匹配文件后立即退出（不继续搜索）                         |

显示大于 200M 的文件，并且显示详细文件信息：

```bash
find /usr -size +200M -ls
```

```console
 50333252 224372 -rw-r--r--   2 root     root     229754784 Jan 24  2025 /usr/lib/locale/locale-archive
 50333252 224372 -rw-r--r--   2 root     root     229754784 Jan 24  2025 /usr/lib/locale/locale-archive.real
```

删除家目录下空文件：

```bash
find ~ -empty -type f -delete
```

将 `/var/log` 目录下的所有日志文件 `.log` 复制到 `/tmp` 目录下：

```bash
find /var/log -type f -name "*.log" -exec cp {} /tmp/ \;
```

```bash
ls /tmp
```

```console
access.log
anaconda.log
audit.log
dbus.log
dnf.librepo.log
dnf.log
……
```

`{}` 会替换成具体的日志文件名（如 syslog、auth.log），复制后目标目录中会保留原文件名。

结尾使用 `\;`，即使复制 100 个文件，也会执行 100 次 `cp`（效率低，但逻辑简单，适合文件数量少的场景），可以将 `\;` 换成 `+`），让 `cp` 一次性处理多个文件，减少进程创建开销

当需要对每个匹配文件单独执行命令，并获取每个文件的独立结果时（比如统计单个文件行数、查看单个文件详情），就适合用 `\;`。如果只是批量处理（比如批量删除、批量复制且不关心单个结果），可以用 `+` 提高效率。
